import {
  PhysicsPrestepType,
  PhysicsShape,
  PhysicsShapeCapsule
} from "./chunk-DJVHLNEV.js";
import {
  BoundingBox,
  TransformNode
} from "./chunk-NXIYY4FJ.js";
import {
  Axis
} from "./chunk-CCQAAKQU.js";
import {
  BuildArray,
  Matrix,
  Quaternion,
  TmpVectors,
  Vector3
} from "./chunk-J2RRKUBS.js";
import {
  _WarnImport
} from "./chunk-3QDG7GWC.js";
import {
  Logger
} from "./chunk-OJJXGLTO.js";
import {
  WithinEpsilon
} from "./chunk-47GQF5OD.js";

// node_modules/@babylonjs/core/Physics/castingResult.js
var CastingResult = class {
  constructor() {
    this._hasHit = false;
    this._hitNormal = Vector3.Zero();
    this._hitPoint = Vector3.Zero();
    this._triangleIndex = -1;
  }
  /**
   * Gets the hit point.
   */
  get hitPoint() {
    return this._hitPoint;
  }
  /**
   * Gets the hit normal.
   */
  get hitNormal() {
    return this._hitNormal;
  }
  /**
   * Gets if there was a hit
   */
  get hasHit() {
    return this._hasHit;
  }
  /*
   * The index of the original triangle which was hit. Will be -1 if contact point is not on a mesh shape
   */
  get triangleIndex() {
    return this._triangleIndex;
  }
  /**
   * Sets the hit data
   * @param hitNormal defines the normal in world space
   * @param hitPoint defines the point in world space
   * @param triangleIndex defines the index of the triangle in case of mesh shape
   */
  setHitData(hitNormal, hitPoint, triangleIndex) {
    this._hasHit = true;
    this._hitNormal.set(hitNormal.x, hitNormal.y, hitNormal.z);
    this._hitPoint.set(hitPoint.x, hitPoint.y, hitPoint.z);
    this._triangleIndex = triangleIndex ?? -1;
  }
  /**
   * Resets all the values to default
   */
  reset() {
    this._hasHit = false;
    this._hitNormal.setAll(0);
    this._hitPoint.setAll(0);
    this._triangleIndex = -1;
    this.body = void 0;
    this.bodyIndex = void 0;
    this.shape = void 0;
  }
};

// node_modules/@babylonjs/core/Physics/physicsRaycastResult.js
var PhysicsRaycastResult = class extends CastingResult {
  constructor() {
    super(...arguments);
    this._hitDistance = 0;
    this._rayFromWorld = Vector3.Zero();
    this._rayToWorld = Vector3.Zero();
  }
  /**
   * Gets the distance from the hit
   */
  get hitDistance() {
    return this._hitDistance;
  }
  /**
   * Gets the hit normal/direction in the world
   */
  get hitNormalWorld() {
    return this._hitNormal;
  }
  /**
   * Gets the hit point in the world
   */
  get hitPointWorld() {
    return this._hitPoint;
  }
  /**
   * Gets the ray "start point" of the ray in the world
   */
  get rayFromWorld() {
    return this._rayFromWorld;
  }
  /**
   * Gets the ray "end point" of the ray in the world
   */
  get rayToWorld() {
    return this._rayToWorld;
  }
  /**
   * Sets the distance from the start point to the hit point
   * @param distance defines the distance to set
   */
  setHitDistance(distance) {
    this._hitDistance = distance;
  }
  /**
   * Calculates the distance manually
   */
  calculateHitDistance() {
    this._hitDistance = Vector3.Distance(this._rayFromWorld, this._hitPoint);
  }
  /**
   * Resets all the values to default
   * @param from The from point on world space
   * @param to The to point on world space
   */
  reset(from = Vector3.Zero(), to = Vector3.Zero()) {
    super.reset();
    this._rayFromWorld.copyFrom(from);
    this._rayToWorld.copyFrom(to);
    this._hitDistance = 0;
  }
};

// node_modules/@babylonjs/core/Physics/v2/physicsEngine.js
var PhysicsEngine = class _PhysicsEngine {
  /**
   *
   * @returns physics plugin version
   */
  getPluginVersion() {
    return this._physicsPlugin.getPluginVersion();
  }
  // eslint-disable-next-line jsdoc/require-returns-check
  /**
   * Factory used to create the default physics plugin.
   * @returns The default physics plugin
   */
  static DefaultPluginFactory() {
    throw _WarnImport("");
  }
  /**
   * Creates a new Physics Engine
   * @param gravity defines the gravity vector used by the simulation
   * @param _physicsPlugin defines the plugin to use (CannonJS by default)
   */
  constructor(gravity, _physicsPlugin = _PhysicsEngine.DefaultPluginFactory()) {
    this._physicsPlugin = _physicsPlugin;
    this._physicsBodies = [];
    this._subTimeStep = 0;
    gravity = gravity || new Vector3(0, -9.807, 0);
    this.setGravity(gravity);
    this.setTimeStep();
  }
  /**
   * Sets the gravity vector used by the simulation
   * @param gravity defines the gravity vector to use
   */
  setGravity(gravity) {
    this.gravity = gravity;
    this._physicsPlugin.setGravity(this.gravity);
  }
  /**
   * Set the time step of the physics engine.
   * Default is 1/60.
   * To slow it down, enter 1/600 for example.
   * To speed it up, 1/30
   * Unit is seconds.
   * @param newTimeStep defines the new timestep to apply to this world.
   */
  setTimeStep(newTimeStep = 1 / 60) {
    this._physicsPlugin.setTimeStep(newTimeStep);
  }
  /**
   * Get the time step of the physics engine.
   * @returns the current time step
   */
  getTimeStep() {
    return this._physicsPlugin.getTimeStep();
  }
  /**
   * Set the sub time step of the physics engine.
   * Default is 0 meaning there is no sub steps
   * To increase physics resolution precision, set a small value (like 1 ms)
   * @param subTimeStep defines the new sub timestep used for physics resolution.
   */
  setSubTimeStep(subTimeStep = 0) {
    this._subTimeStep = subTimeStep;
  }
  /**
   * Get the sub time step of the physics engine.
   * @returns the current sub time step
   */
  getSubTimeStep() {
    return this._subTimeStep;
  }
  /**
   * Release all resources
   */
  dispose() {
    this._physicsPlugin.dispose();
  }
  /**
   * Gets the name of the current physics plugin
   * @returns the name of the plugin
   */
  getPhysicsPluginName() {
    return this._physicsPlugin.name;
  }
  /**
   * Set the maximum allowed linear and angular velocities
   * @param maxLinearVelocity maximum allowed linear velocity
   * @param maxAngularVelocity maximum allowed angular velocity
   */
  setVelocityLimits(maxLinearVelocity, maxAngularVelocity) {
    this._physicsPlugin.setVelocityLimits(maxLinearVelocity, maxAngularVelocity);
  }
  /**
   * @returns maximum allowed linear velocity
   */
  getMaxLinearVelocity() {
    return this._physicsPlugin.getMaxLinearVelocity();
  }
  /**
   * @returns maximum allowed angular velocity
   */
  getMaxAngularVelocity() {
    return this._physicsPlugin.getMaxAngularVelocity();
  }
  /**
   * Adding a new impostor for the impostor tracking.
   * This will be done by the impostor itself.
   * @param impostor the impostor to add
   */
  /**
   * Called by the scene. No need to call it.
   * @param delta defines the timespan between frames
   */
  _step(delta) {
    if (delta > 0.1) {
      delta = 0.1;
    } else if (delta <= 0) {
      delta = 1 / 60;
    }
    this._physicsPlugin.executeStep(delta, this._physicsBodies);
  }
  /**
   * Add a body as an active component of this engine
   * @param physicsBody The body to add
   */
  addBody(physicsBody) {
    this._physicsBodies.push(physicsBody);
  }
  /**
   * Removes a particular body from this engine
   * @param physicsBody The body to remove from the simulation
   */
  removeBody(physicsBody) {
    const index = this._physicsBodies.indexOf(physicsBody);
    if (index > -1) {
      this._physicsBodies.splice(index, 1);
    }
  }
  /**
   * @returns an array of bodies added to this engine
   */
  getBodies() {
    return this._physicsBodies;
  }
  /**
   * Gets the current plugin used to run the simulation
   * @returns current plugin
   */
  getPhysicsPlugin() {
    return this._physicsPlugin;
  }
  /**
   * Does a raycast in the physics world
   * @param from when should the ray start?
   * @param to when should the ray end?
   * @param result resulting PhysicsRaycastResult
   * @param query raycast query object
   */
  raycastToRef(from, to, result, query) {
    this._physicsPlugin.raycast(from, to, result, query);
  }
  /**
   * Does a raycast in the physics world
   * @param from when should the ray start?
   * @param to when should the ray end?
   * @param query raycast query object
   * @returns PhysicsRaycastResult
   */
  raycast(from, to, query) {
    const result = new PhysicsRaycastResult();
    this._physicsPlugin.raycast(from, to, result, query);
    return result;
  }
};

// node_modules/@babylonjs/core/Physics/v2/physicsBody.js
var PhysicsBody = class _PhysicsBody {
  /**
   * Disable pre-step that consists in updating Physics Body from Transform Node Translation/Orientation.
   * True by default for maximum performance.
   */
  get disablePreStep() {
    return this._prestepType == PhysicsPrestepType.DISABLED;
  }
  set disablePreStep(value) {
    this._prestepType = value ? PhysicsPrestepType.DISABLED : PhysicsPrestepType.TELEPORT;
  }
  /**
   * Constructs a new physics body for the given node.
   * @param transformNode - The Transform Node to construct the physics body for. For better performance, it is advised that this node does not have a parent.
   * @param motionType - The motion type of the physics body. The options are:
   *  - PhysicsMotionType.STATIC - Static bodies are not moving and unaffected by forces or collisions. They are good for level boundaries or terrain.
   *  - PhysicsMotionType.DYNAMIC - Dynamic bodies are fully simulated. They can move and collide with other objects.
   *  - PhysicsMotionType.ANIMATED - They behave like dynamic bodies, but they won't be affected by other bodies, but still push other bodies out of the way.
   * @param startsAsleep - Whether the physics body should start in a sleeping state (not a guarantee). Defaults to false.
   * @param scene - The scene containing the physics engine.
   *
   * This code is useful for creating a physics body for a given Transform Node in a scene.
   * It checks the version of the physics engine and the physics plugin, and initializes the body accordingly.
   * It also sets the node's rotation quaternion if it is not already set. Finally, it adds the body to the physics engine.
   */
  constructor(transformNode, motionType, startsAsleep, scene) {
    this._pluginData = void 0;
    this._pluginDataInstances = [];
    this._collisionCBEnabled = false;
    this._collisionEndedCBEnabled = false;
    this.disableSync = false;
    this._isDisposed = false;
    this._shape = null;
    this._prestepType = PhysicsPrestepType.DISABLED;
    if (!scene) {
      return;
    }
    const physicsEngine = scene.getPhysicsEngine();
    if (!physicsEngine) {
      throw new Error("No Physics Engine available.");
    }
    this._physicsEngine = physicsEngine;
    if (physicsEngine.getPluginVersion() != 2) {
      throw new Error("Plugin version is incorrect. Expected version 2.");
    }
    const physicsPlugin = physicsEngine.getPhysicsPlugin();
    if (!physicsPlugin) {
      throw new Error("No Physics Plugin available.");
    }
    this._physicsPlugin = physicsPlugin;
    if (!transformNode.rotationQuaternion) {
      transformNode.rotationQuaternion = Quaternion.FromEulerAngles(transformNode.rotation.x, transformNode.rotation.y, transformNode.rotation.z);
    }
    this.startAsleep = startsAsleep;
    this._motionType = motionType;
    this.disableSync = motionType == 0;
    const m = transformNode;
    if (m.hasThinInstances) {
      this._physicsPlugin.initBodyInstances(this, motionType, m);
    } else {
      if (transformNode.parent) {
        transformNode.computeWorldMatrix(true);
      }
      this._physicsPlugin.initBody(this, motionType, transformNode.absolutePosition, transformNode.absoluteRotationQuaternion);
    }
    this.transformNode = transformNode;
    transformNode.physicsBody = this;
    physicsEngine.addBody(this);
    this._nodeDisposeObserver = transformNode.onDisposeObservable.add(() => {
      this.dispose();
    });
  }
  /**
   * Returns the string "PhysicsBody".
   * @returns "PhysicsBody"
   */
  getClassName() {
    return "PhysicsBody";
  }
  /**
   * Clone the PhysicsBody to a new body and assign it to the transformNode parameter
   * @param transformNode transformNode that will be used for the cloned PhysicsBody
   * @returns the newly cloned PhysicsBody
   */
  clone(transformNode) {
    const clonedBody = new _PhysicsBody(transformNode, this.getMotionType(), this.startAsleep, this.transformNode.getScene());
    clonedBody.shape = this.shape;
    clonedBody.setMassProperties(this.getMassProperties());
    clonedBody.setLinearDamping(this.getLinearDamping());
    clonedBody.setAngularDamping(this.getAngularDamping());
    return clonedBody;
  }
  /**
   * If a physics body is connected to an instanced node, update the number physic instances to match the number of node instances.
   */
  updateBodyInstances() {
    const m = this.transformNode;
    if (m.hasThinInstances) {
      this._physicsPlugin.updateBodyInstances(this, m);
    }
  }
  /**
   * This returns the number of internal instances of the physics body
   */
  get numInstances() {
    return this._pluginDataInstances.length;
  }
  /**
   * Get the motion type of the physics body. Can be STATIC, DYNAMIC, or ANIMATED.
   */
  get motionType() {
    return this._motionType;
  }
  /**
   * Sets the shape of the physics body.
   * @param shape - The shape of the physics body.
   *
   * This method is useful for setting the shape of the physics body, which is necessary for the physics engine to accurately simulate the body's behavior.
   * The shape is used to calculate the body's mass, inertia, and other properties.
   */
  set shape(shape) {
    this._shape = shape;
    if (shape) {
      this._physicsPlugin.setShape(this, shape);
    }
  }
  /**
   * Retrieves the physics shape associated with this object.
   *
   * @returns The physics shape associated with this object, or `undefined` if no
   * shape is associated.
   *
   * This method is useful for retrieving the physics shape associated with this object,
   * which can be used to apply physical forces to the object or to detect collisions.
   */
  get shape() {
    return this._shape;
  }
  /**
   * Returns the bounding box of the physics body.
   * @returns The bounding box of the physics body.
   */
  getBoundingBox() {
    return this._physicsPlugin.getBodyBoundingBox(this);
  }
  /**
   * Sets the event mask for the physics engine.
   *
   * @param eventMask - A bitmask that determines which events will be sent to the physics engine.
   * @param instanceIndex - If this body is instanced, the index of the instance to set the event mask for.
   *
   * This method is useful for setting the event mask for the physics engine, which determines which events
   * will be sent to the physics engine. This allows the user to control which events the physics engine will respond to.
   */
  setEventMask(eventMask, instanceIndex) {
    this._physicsPlugin.setEventMask(this, eventMask, instanceIndex);
  }
  /**
   * Gets the event mask of the physics engine.
   * @param instanceIndex - If this body is instanced, the index of the instance to get the event mask for.
   * @returns The event mask of the physics engine.
   *
   * This method is useful for getting the event mask of the physics engine,
   * which is used to determine which events the engine will respond to.
   * This is important for ensuring that the engine is responding to the correct events and not
   * wasting resources on unnecessary events.
   */
  getEventMask(instanceIndex) {
    return this._physicsPlugin.getEventMask(this, instanceIndex);
  }
  /**
   * Sets the motion type of the physics body. Can be STATIC, DYNAMIC, or ANIMATED.
   * @param motionType - The motion type to set.
   * @param instanceIndex - If this body is instanced, the index of the instance to set the motion type for.
   */
  setMotionType(motionType, instanceIndex) {
    this.disableSync = motionType == 0;
    this._physicsPlugin.setMotionType(this, motionType, instanceIndex);
  }
  /**
   * Gets the motion type of the physics body. Can be STATIC, DYNAMIC, or ANIMATED.
   * @param instanceIndex - If this body is instanced, the index of the instance to get the motion type for.
   * @returns The motion type of the physics body.
   */
  getMotionType(instanceIndex) {
    return this._physicsPlugin.getMotionType(this, instanceIndex);
  }
  /**
   * Set the prestep type of the body
   * @param prestepType prestep type provided by PhysicsPrestepType
   */
  setPrestepType(prestepType) {
    this._prestepType = prestepType;
  }
  /**
   * Get the current prestep type of the body
   * @returns the type of prestep associated with the body and its instance index
   */
  getPrestepType() {
    return this._prestepType;
  }
  /**
   * Computes the mass properties of the physics object, based on the set of physics shapes this body uses.
   * This method is useful for computing the initial mass properties of a physics object, such as its mass,
   * inertia, and center of mass; these values are important for accurately simulating the physics of the
   * object in the physics engine, and computing values based on the shape will provide you with reasonable
   * initial values, which you can then customize.
   * @param instanceIndex - The index of the instance to compute the mass properties for.
   * @returns The mass properties of the object.
   */
  computeMassProperties(instanceIndex) {
    return this._physicsPlugin.computeMassProperties(this, instanceIndex);
  }
  /**
   * Sets the mass properties of the physics object.
   *
   * @param massProps - The mass properties to set.
   * @param instanceIndex - The index of the instance to set the mass properties for. If not defined, the mass properties will be set for all instances.
   *
   * This method is useful for setting the mass properties of a physics object, such as its mass,
   * inertia, and center of mass. This is important for accurately simulating the physics of the object in the physics engine.
   */
  setMassProperties(massProps, instanceIndex) {
    this._physicsPlugin.setMassProperties(this, massProps, instanceIndex);
  }
  /**
   * Retrieves the mass properties of the object.
   * @param instanceIndex - If this body is instanced, the index of the instance to get the mass properties for.
   * @returns The mass properties of the object.
   *
   * This method is useful for physics simulations, as it allows the user to
   * retrieve the mass properties of the object, such as its mass, center of mass,
   * and moment of inertia. This information is necessary for accurate physics
   * simulations.
   */
  getMassProperties(instanceIndex) {
    return this._physicsPlugin.getMassProperties(this, instanceIndex);
  }
  /**
   * Sets the linear damping of the physics body.
   *
   * @param damping - The linear damping value.
   * @param instanceIndex - If this body is instanced, the index of the instance to set the linear damping for.
   *
   * This method is useful for controlling the linear damping of the physics body,
   * which is the rate at which the body's velocity decreases over time. This is useful for simulating
   * the effects of air resistance or other forms of friction.
   */
  setLinearDamping(damping, instanceIndex) {
    this._physicsPlugin.setLinearDamping(this, damping, instanceIndex);
  }
  /**
   * Gets the linear damping of the physics body.
   * @param instanceIndex - If this body is instanced, the index of the instance to get the linear damping for.
   * @returns The linear damping of the physics body.
   *
   * This method is useful for retrieving the linear damping of the physics body, which is the amount of
   * resistance the body has to linear motion. This is useful for simulating realistic physics behavior
   * in a game.
   */
  getLinearDamping(instanceIndex) {
    return this._physicsPlugin.getLinearDamping(this, instanceIndex);
  }
  /**
   * Sets the angular damping of the physics body.
   * @param damping The angular damping of the body.
   * @param instanceIndex - If this body is instanced, the index of the instance to set the angular damping for.
   *
   * This method is useful for controlling the angular velocity of a physics body.
   * By setting the damping, the body's angular velocity will be reduced over time, simulating the effect of friction.
   * This can be used to create realistic physical behavior in a physics engine.
   */
  setAngularDamping(damping, instanceIndex) {
    this._physicsPlugin.setAngularDamping(this, damping, instanceIndex);
  }
  /**
   * Gets the angular damping of the physics body.
   * @param instanceIndex - If this body is instanced, the index of the instance to get the angular damping for.
   *
   * @returns The angular damping of the physics body.
   *
   * This method is useful for getting the angular damping of the physics body,
   * which is the rate of reduction of the angular velocity over time.
   * This is important for simulating realistic physics behavior in a game.
   */
  getAngularDamping(instanceIndex) {
    return this._physicsPlugin.getAngularDamping(this, instanceIndex);
  }
  /**
   * Sets the linear velocity of the physics object.
   * @param linVel - The linear velocity to set.
   * @param instanceIndex - If this body is instanced, the index of the instance to set the linear velocity for.
   *
   * This method is useful for setting the linear velocity of a physics object,
   * which is necessary for simulating realistic physics in a game engine.
   * By setting the linear velocity, the physics object will move in the direction and speed specified by the vector.
   * This allows for realistic physics simulations, such as simulating the motion of a ball rolling down a hill.
   */
  setLinearVelocity(linVel, instanceIndex) {
    this._physicsPlugin.setLinearVelocity(this, linVel, instanceIndex);
  }
  /**
   * Gets the linear velocity of the physics body and stores it in the given vector3.
   * @param linVel - The vector3 to store the linear velocity in.
   * @param instanceIndex - If this body is instanced, the index of the instance to get the linear velocity for.
   *
   * This method is useful for getting the linear velocity of a physics body in a physics engine.
   * This can be used to determine the speed and direction of the body, which can be used to calculate the motion of the body.
   */
  getLinearVelocityToRef(linVel, instanceIndex) {
    this._physicsPlugin.getLinearVelocityToRef(this, linVel, instanceIndex);
  }
  /**
   * Gets the linear velocity of the physics body as a new vector3.
   * @param instanceIndex - If this body is instanced, the index of the instance to get the linear velocity for.
   * @returns The linear velocity of the physics body.
   *
   * This method is useful for getting the linear velocity of a physics body in a physics engine.
   * This can be used to determine the speed and direction of the body, which can be used to calculate the motion of the body.
   */
  getLinearVelocity(instanceIndex) {
    const ref = new Vector3();
    this.getLinearVelocityToRef(ref, instanceIndex);
    return ref;
  }
  /**
   * Sets the angular velocity of the physics object.
   * @param angVel - The angular velocity to set.
   * @param instanceIndex - If this body is instanced, the index of the instance to set the angular velocity for.
   *
   * This method is useful for setting the angular velocity of a physics object, which is necessary for
   * simulating realistic physics behavior. The angular velocity is used to determine the rate of rotation of the object,
   * which is important for simulating realistic motion.
   */
  setAngularVelocity(angVel, instanceIndex) {
    this._physicsPlugin.setAngularVelocity(this, angVel, instanceIndex);
  }
  /**
   * Gets the angular velocity of the physics body and stores it in the given vector3.
   * @param angVel - The vector3 to store the angular velocity in.
   * @param instanceIndex - If this body is instanced, the index of the instance to get the angular velocity for.
   *
   * This method is useful for getting the angular velocity of a physics body, which can be used to determine the body's
   * rotational speed. This information can be used to create realistic physics simulations.
   */
  getAngularVelocityToRef(angVel, instanceIndex) {
    this._physicsPlugin.getAngularVelocityToRef(this, angVel, instanceIndex);
  }
  /**
   * Gets the angular velocity of the physics body as a new vector3.
   * @param instanceIndex - If this body is instanced, the index of the instance to get the angular velocity for.
   * @returns The angular velocity of the physics body.
   *
   * This method is useful for getting the angular velocity of a physics body, which can be used to determine the body's
   * rotational speed. This information can be used to create realistic physics simulations.
   */
  getAngularVelocity(instanceIndex) {
    const ref = new Vector3();
    this.getAngularVelocityToRef(ref, instanceIndex);
    return ref;
  }
  /**
   * Applies an impulse to the physics object.
   *
   * @param impulse The impulse vector.
   * @param location The location of the impulse.
   * @param instanceIndex For a instanced body, the instance to where the impulse should be applied. If not specified, the impulse is applied to all instances.
   *
   * This method is useful for applying an impulse to a physics object, which can be used to simulate physical forces such as gravity,
   * collisions, and explosions. This can be used to create realistic physics simulations in a game or other application.
   */
  applyImpulse(impulse, location, instanceIndex) {
    this._physicsPlugin.applyImpulse(this, impulse, location, instanceIndex);
  }
  /**
   * Add torque to a physics body
   * @param angularImpulse The angular impulse vector.
   * @param instanceIndex For a instanced body, the instance to where the impulse should be applied. If not specified, the impulse is applied to all instances.
   */
  applyAngularImpulse(angularImpulse, instanceIndex) {
    this._physicsPlugin.applyAngularImpulse(this, angularImpulse, instanceIndex);
  }
  /**
   * Applies a force to the physics object.
   *
   * @param force The force vector.
   * @param location The location of the force.
   * @param instanceIndex For a instanced body, the instance to where the force should be applied. If not specified, the force is applied to all instances.
   *
   * This method is useful for applying a force to a physics object, which can be used to simulate physical forces such as gravity,
   * collisions, and explosions. This can be used to create realistic physics simulations in a game or other application.
   */
  applyForce(force, location, instanceIndex) {
    this._physicsPlugin.applyForce(this, force, location, instanceIndex);
  }
  /**
   * Retrieves the geometry of the body from the physics plugin.
   *
   * @returns The geometry of the body.
   *
   * This method is useful for retrieving the geometry of the body from the physics plugin, which can be used for various physics calculations.
   */
  getGeometry() {
    return this._physicsPlugin.getBodyGeometry(this);
  }
  /**
   * Returns an observable that will be notified for when a collision starts or continues for this PhysicsBody
   * @returns Observable
   */
  getCollisionObservable() {
    return this._physicsPlugin.getCollisionObservable(this);
  }
  /**
   * Returns an observable that will be notified when the body has finished colliding with another body
   * @returns
   */
  getCollisionEndedObservable() {
    return this._physicsPlugin.getCollisionEndedObservable(this);
  }
  /**
   * Enable or disable collision callback for this PhysicsBody.
   * @param enabled true if PhysicsBody's collision will rise a collision event and notifies the observable
   */
  setCollisionCallbackEnabled(enabled) {
    this._collisionCBEnabled = enabled;
    this._physicsPlugin.setCollisionCallbackEnabled(this, enabled);
  }
  /**
   * Enable or disable collision ended callback for this PhysicsBody.
   * @param enabled true if PhysicsBody's collision ended will rise a collision event and notifies the observable
   */
  setCollisionEndedCallbackEnabled(enabled) {
    this._collisionEndedCBEnabled = enabled;
    this._physicsPlugin.setCollisionEndedCallbackEnabled(this, enabled);
  }
  /**
   * Get the center of the object in world space.
   * @param instanceIndex - If this body is instanced, the index of the instance to get the center for.
   * @returns geometric center of the associated mesh
   */
  getObjectCenterWorld(instanceIndex) {
    const ref = new Vector3();
    return this.getObjectCenterWorldToRef(ref, instanceIndex);
  }
  /**
   * Get the center of the object in world space.
   * @param ref - The vector3 to store the result in.
   * @param instanceIndex - If this body is instanced, the index of the instance to get the center for.
   * @returns geometric center of the associated mesh
   */
  getObjectCenterWorldToRef(ref, instanceIndex) {
    var _a;
    if (((_a = this._pluginDataInstances) == null ? void 0 : _a.length) > 0) {
      const index = instanceIndex || 0;
      const matrixData = this.transformNode._thinInstanceDataStorage.matrixData;
      if (matrixData) {
        ref.set(matrixData[index * 16 + 12], matrixData[index * 16 + 13], matrixData[index * 16 + 14]);
      }
    } else {
      ref.copyFrom(this.transformNode.position);
    }
    return ref;
  }
  /**
   * Adds a constraint to the physics engine.
   *
   * @param childBody - The body to which the constraint will be applied.
   * @param constraint - The constraint to be applied.
   * @param instanceIndex - If this body is instanced, the index of the instance to which the constraint will be applied. If not specified, no constraint will be applied.
   * @param childInstanceIndex - If the child body is instanced, the index of the instance to which the constraint will be applied. If not specified, no constraint will be applied.
   *
   */
  addConstraint(childBody, constraint, instanceIndex, childInstanceIndex) {
    this._physicsPlugin.addConstraint(this, childBody, constraint, instanceIndex, childInstanceIndex);
  }
  /**
   * Sync with a bone
   * @param bone The bone that the impostor will be synced to.
   * @param boneMesh The mesh that the bone is influencing.
   * @param jointPivot The pivot of the joint / bone in local space.
   * @param distToJoint Optional distance from the impostor to the joint.
   * @param adjustRotation Optional quaternion for adjusting the local rotation of the bone.
   * @param boneAxis Optional vector3 axis the bone is aligned with
   */
  syncWithBone(bone, boneMesh, jointPivot, distToJoint, adjustRotation, boneAxis) {
    const mesh = this.transformNode;
    if (mesh.rotationQuaternion) {
      if (adjustRotation) {
        const tempQuat = TmpVectors.Quaternion[0];
        bone.getRotationQuaternionToRef(1, boneMesh, tempQuat);
        tempQuat.multiplyToRef(adjustRotation, mesh.rotationQuaternion);
      } else {
        bone.getRotationQuaternionToRef(1, boneMesh, mesh.rotationQuaternion);
      }
    }
    const pos = TmpVectors.Vector3[0];
    const boneDir = TmpVectors.Vector3[1];
    if (!boneAxis) {
      boneAxis = TmpVectors.Vector3[2];
      boneAxis.x = 0;
      boneAxis.y = 1;
      boneAxis.z = 0;
    }
    bone.getDirectionToRef(boneAxis, boneMesh, boneDir);
    bone.getAbsolutePositionToRef(boneMesh, pos);
    if ((distToJoint === void 0 || distToJoint === null) && jointPivot) {
      distToJoint = jointPivot.length();
    }
    if (distToJoint !== void 0 && distToJoint !== null) {
      pos.x += boneDir.x * distToJoint;
      pos.y += boneDir.y * distToJoint;
      pos.z += boneDir.z * distToJoint;
    }
    mesh.setAbsolutePosition(pos);
  }
  /**
   * Executes a callback on the body or all of the instances of a body
   * @param callback the callback to execute
   */
  iterateOverAllInstances(callback) {
    var _a;
    if (((_a = this._pluginDataInstances) == null ? void 0 : _a.length) > 0) {
      for (let i = 0; i < this._pluginDataInstances.length; i++) {
        callback(this, i);
      }
    } else {
      callback(this, void 0);
    }
  }
  /**
   * Sets the gravity factor of the physics body
   * @param factor the gravity factor to set
   * @param instanceIndex the instance of the body to set, if undefined all instances will be set
   */
  setGravityFactor(factor, instanceIndex) {
    this._physicsPlugin.setGravityFactor(this, factor, instanceIndex);
  }
  /**
   * Gets the gravity factor of the physics body
   * @param instanceIndex the instance of the body to get, if undefined the value of first instance will be returned
   * @returns the gravity factor
   */
  getGravityFactor(instanceIndex) {
    return this._physicsPlugin.getGravityFactor(this, instanceIndex);
  }
  /**
   * Set the target transformation (position and rotation) of the body, such that the body will set its velocity to reach that target
   * @param position The target position
   * @param rotation The target rotation
   * @param instanceIndex The index of the instance in an instanced body
   */
  setTargetTransform(position, rotation, instanceIndex) {
    this._physicsPlugin.setTargetTransform(this, position, rotation, instanceIndex);
  }
  /**
   * Returns if the body has been disposed.
   * @returns true if disposed, false otherwise.
   */
  get isDisposed() {
    return this._isDisposed;
  }
  /**
   * Disposes the body from the physics engine.
   *
   * This method is useful for cleaning up the physics engine when a body is no longer needed. Disposing the body will free up resources and prevent memory leaks.
   */
  dispose() {
    if (this._isDisposed) {
      return;
    }
    if (this._collisionCBEnabled) {
      this.setCollisionCallbackEnabled(false);
    }
    if (this._collisionEndedCBEnabled) {
      this.setCollisionEndedCallbackEnabled(false);
    }
    if (this._nodeDisposeObserver) {
      this.transformNode.onDisposeObservable.remove(this._nodeDisposeObserver);
      this._nodeDisposeObserver = null;
    }
    this._physicsEngine.removeBody(this);
    this._physicsPlugin.removeBody(this);
    this._physicsPlugin.disposeBody(this);
    this.transformNode.physicsBody = null;
    this._pluginData = null;
    this._pluginDataInstances.length = 0;
    this._isDisposed = true;
    this.shape = null;
  }
};

// node_modules/@babylonjs/core/Physics/v2/physicsConstraint.js
var PhysicsConstraint = class {
  /**
   * Constructs a new constraint for the physics constraint.
   * @param type The type of constraint to create.
   * @param options The options for the constraint.
   * @param scene The scene the constraint belongs to.
   *
   * This code is useful for creating a new constraint for the physics engine. It checks if the scene has a physics engine, and if the plugin version is correct.
   * If all checks pass, it initializes the constraint with the given type and options.
   */
  constructor(type, options, scene) {
    this._pluginData = void 0;
    if (!scene) {
      throw new Error("Missing scene parameter for constraint constructor.");
    }
    const physicsEngine = scene.getPhysicsEngine();
    if (!physicsEngine) {
      throw new Error("No Physics Engine available.");
    }
    if (physicsEngine.getPluginVersion() != 2) {
      throw new Error("Plugin version is incorrect. Expected version 2.");
    }
    const physicsPlugin = physicsEngine.getPhysicsPlugin();
    if (!physicsPlugin) {
      throw new Error("No Physics Plugin available.");
    }
    this._physicsPlugin = physicsPlugin;
    this._options = options;
    this._type = type;
  }
  /**
   * Gets the type of the constraint.
   *
   * @returns The type of the constraint.
   *
   */
  get type() {
    return this._type;
  }
  /**
   * Retrieves the options of the physics constraint.
   *
   * @returns The physics constraint parameters.
   *
   */
  get options() {
    return this._options;
  }
  /**
   * Enable/disable the constraint
   * @param isEnabled value for the constraint
   */
  set isEnabled(isEnabled) {
    this._physicsPlugin.setEnabled(this, isEnabled);
  }
  /**
   *
   * @returns true if constraint is enabled
   */
  get isEnabled() {
    return this._physicsPlugin.getEnabled(this);
  }
  /**
   * Enables or disables collisions for the physics engine.
   *
   * @param isEnabled - A boolean value indicating whether collisions should be enabled or disabled.
   *
   */
  set isCollisionsEnabled(isEnabled) {
    this._physicsPlugin.setCollisionsEnabled(this, isEnabled);
  }
  /**
   * Gets whether collisions are enabled for this physics object.
   *
   * @returns `true` if collisions are enabled, `false` otherwise.
   *
   */
  get isCollisionsEnabled() {
    return this._physicsPlugin.getCollisionsEnabled(this);
  }
  /**
   * Gets all bodies that are using this constraint
   * @returns
   */
  getBodiesUsingConstraint() {
    return this._physicsPlugin.getBodiesUsingConstraint(this);
  }
  /**
   * Disposes the constraint from the physics engine.
   *
   * This method is useful for cleaning up the physics engine when a body is no longer needed. Disposing the body will free up resources and prevent memory leaks.
   */
  dispose() {
    this._physicsPlugin.disposeConstraint(this);
  }
};
var Physics6DoFLimit = class {
};
var Physics6DoFConstraint = class extends PhysicsConstraint {
  constructor(constraintParams, limits, scene) {
    super(7, constraintParams, scene);
    this.limits = limits;
  }
  /**
   * Sets the friction of the given axis of the physics engine.
   * @param axis - The axis of the physics engine to set the friction for.
   * @param friction - The friction to set for the given axis.
   *
   */
  setAxisFriction(axis, friction) {
    this._physicsPlugin.setAxisFriction(this, axis, friction);
  }
  /**
   * Gets the friction of the given axis of the physics engine.
   * @param axis - The axis of the physics engine.
   * @returns The friction of the given axis, or null if the constraint hasn't been initialized yet.
   *
   */
  getAxisFriction(axis) {
    return this._physicsPlugin.getAxisFriction(this, axis);
  }
  /**
   * Sets the limit mode for the given axis of the constraint.
   * @param axis The axis to set the limit mode for.
   * @param limitMode The limit mode to set.
   *
   * This method is useful for setting the limit mode for a given axis of the constraint. This is important for
   * controlling the behavior of the physics engine when the constraint is reached. By setting the limit mode,
   * the engine can be configured to either stop the motion of the objects, or to allow them to continue
   * moving beyond the constraint.
   */
  setAxisMode(axis, limitMode) {
    this._physicsPlugin.setAxisMode(this, axis, limitMode);
  }
  /**
   * Gets the limit mode of the given axis of the constraint.
   *
   * @param axis - The axis of the constraint.
   * @returns The limit mode of the given axis, or null if the constraint hasn't been initialized yet.
   *
   */
  getAxisMode(axis) {
    return this._physicsPlugin.getAxisMode(this, axis);
  }
  /**
   * Sets the minimum limit of a given axis of a constraint.
   * @param axis - The axis of the constraint.
   * @param minLimit - The minimum limit of the axis.
   *
   */
  setAxisMinLimit(axis, minLimit) {
    this._physicsPlugin.setAxisMinLimit(this, axis, minLimit);
  }
  /**
   * Gets the minimum limit of the given axis of the physics engine.
   * @param axis - The axis of the physics engine.
   * @returns The minimum limit of the given axis, or null if the constraint hasn't been initialized yet.
   *
   */
  getAxisMinLimit(axis) {
    return this._physicsPlugin.getAxisMinLimit(this, axis);
  }
  /**
   * Sets the maximum limit of the given axis for the physics engine.
   * @param axis - The axis to set the limit for.
   * @param limit - The maximum limit of the axis.
   *
   * This method is useful for setting the maximum limit of the given axis for the physics engine,
   * which can be used to control the movement of the physics object. This helps to ensure that the
   * physics object does not move beyond the given limit.
   */
  setAxisMaxLimit(axis, limit) {
    this._physicsPlugin.setAxisMaxLimit(this, axis, limit);
  }
  /**
   * Gets the maximum limit of the given axis of the physics engine.
   * @param axis - The axis of the physics engine.
   * @returns The maximum limit of the given axis, or null if the constraint hasn't been initialized yet.
   *
   */
  getAxisMaxLimit(axis) {
    return this._physicsPlugin.getAxisMaxLimit(this, axis);
  }
  /**
   * Sets the motor type of the given axis of the constraint.
   * @param axis - The axis of the constraint.
   * @param motorType - The type of motor to use.
   */
  setAxisMotorType(axis, motorType) {
    this._physicsPlugin.setAxisMotorType(this, axis, motorType);
  }
  /**
   * Gets the motor type of the specified axis of the constraint.
   *
   * @param axis - The axis of the constraint.
   * @returns The motor type of the specified axis, or null if the constraint hasn't been initialized yet.
   *
   */
  getAxisMotorType(axis) {
    return this._physicsPlugin.getAxisMotorType(this, axis);
  }
  /**
   * Sets the target velocity of the motor associated with the given axis of the constraint.
   * @param axis - The axis of the constraint.
   * @param target - The target velocity of the motor.
   *
   * This method is useful for setting the target velocity of the motor associated with the given axis of the constraint.
   */
  setAxisMotorTarget(axis, target) {
    this._physicsPlugin.setAxisMotorTarget(this, axis, target);
  }
  /**
   * Gets the target velocity of the motor associated to the given constraint axis.
   * @param axis - The constraint axis associated to the motor.
   * @returns The target velocity of the motor, or null if the constraint hasn't been initialized yet.
   *
   */
  getAxisMotorTarget(axis) {
    return this._physicsPlugin.getAxisMotorTarget(this, axis);
  }
  /**
   * Sets the maximum force of the motor of the given axis of the constraint.
   * @param axis - The axis of the constraint.
   * @param maxForce - The maximum force of the motor.
   *
   */
  setAxisMotorMaxForce(axis, maxForce) {
    this._physicsPlugin.setAxisMotorMaxForce(this, axis, maxForce);
  }
  /**
   * Gets the maximum force of the motor of the given axis of the constraint.
   * @param axis - The axis of the constraint.
   * @returns The maximum force of the motor, or null if the constraint hasn't been initialized yet.
   *
   */
  getAxisMotorMaxForce(axis) {
    return this._physicsPlugin.getAxisMotorMaxForce(this, axis);
  }
};
var BallAndSocketConstraint = class extends PhysicsConstraint {
  constructor(pivotA, pivotB, axisA, axisB, scene) {
    super(1, { pivotA, pivotB, axisA, axisB }, scene);
  }
};
var DistanceConstraint = class extends PhysicsConstraint {
  constructor(maxDistance, scene) {
    super(2, { maxDistance }, scene);
  }
};
var HingeConstraint = class extends PhysicsConstraint {
  constructor(pivotA, pivotB, axisA, axisB, scene) {
    super(3, { pivotA, pivotB, axisA, axisB }, scene);
  }
};
var SliderConstraint = class extends PhysicsConstraint {
  constructor(pivotA, pivotB, axisA, axisB, scene) {
    super(4, { pivotA, pivotB, axisA, axisB }, scene);
  }
};
var LockConstraint = class extends PhysicsConstraint {
  constructor(pivotA, pivotB, axisA, axisB, scene) {
    super(5, { pivotA, pivotB, axisA, axisB }, scene);
  }
};
var PrismaticConstraint = class extends PhysicsConstraint {
  constructor(pivotA, pivotB, axisA, axisB, scene) {
    super(6, { pivotA, pivotB, axisA, axisB }, scene);
  }
};
var SpringConstraint = class extends Physics6DoFConstraint {
  constructor(pivotA, pivotB, axisA, axisB, minDistance, maxDistance, stiffness, damping, scene) {
    super({ pivotA, pivotB, axisA, axisB }, [{ axis: 6, minLimit: minDistance, maxLimit: maxDistance, stiffness, damping }], scene);
  }
};

// node_modules/@babylonjs/core/Physics/v2/physicsMaterial.js
var PhysicsMaterialCombineMode;
(function(PhysicsMaterialCombineMode2) {
  PhysicsMaterialCombineMode2[PhysicsMaterialCombineMode2["GEOMETRIC_MEAN"] = 0] = "GEOMETRIC_MEAN";
  PhysicsMaterialCombineMode2[PhysicsMaterialCombineMode2["MINIMUM"] = 1] = "MINIMUM";
  PhysicsMaterialCombineMode2[PhysicsMaterialCombineMode2["MAXIMUM"] = 2] = "MAXIMUM";
  PhysicsMaterialCombineMode2[PhysicsMaterialCombineMode2["ARITHMETIC_MEAN"] = 3] = "ARITHMETIC_MEAN";
  PhysicsMaterialCombineMode2[PhysicsMaterialCombineMode2["MULTIPLY"] = 4] = "MULTIPLY";
})(PhysicsMaterialCombineMode || (PhysicsMaterialCombineMode = {}));

// node_modules/@babylonjs/core/Physics/v2/physicsAggregate.js
var PhysicsAggregate = class {
  constructor(transformNode, type, _options = { mass: 0 }, _scene) {
    this.transformNode = transformNode;
    this.type = type;
    this._options = _options;
    this._scene = _scene;
    this._disposeShapeWhenDisposed = true;
    if (!this.transformNode) {
      Logger.Error("No object was provided. A physics object is obligatory");
      return;
    }
    const m = transformNode;
    if (this.transformNode.parent && this._options.mass !== 0 && m.hasThinInstances) {
      Logger.Warn("A physics body has been created for an object which has a parent and thin instances. Babylon physics currently works in local space so unexpected issues may occur.");
    }
    if (!this._scene && transformNode.getScene) {
      this._scene = transformNode.getScene();
    }
    if (!this._scene) {
      return;
    }
    this._options.mass = _options.mass === void 0 ? 0 : _options.mass;
    this._options.friction = _options.friction === void 0 ? 0.2 : _options.friction;
    this._options.restitution = _options.restitution === void 0 ? 0.2 : _options.restitution;
    const motionType = this._options.mass === 0 ? 0 : 2;
    const startAsleep = this._options.startAsleep ?? false;
    this.body = new PhysicsBody(transformNode, motionType, startAsleep, this._scene);
    this._addSizeOptions();
    if (type.getClassName && type.getClassName() === "PhysicsShape") {
      this.shape = type;
      this._disposeShapeWhenDisposed = false;
    } else {
      this.shape = new PhysicsShape({ type, parameters: this._options }, this._scene);
    }
    if (this._options.isTriggerShape) {
      this.shape.isTrigger = true;
    }
    this.material = { friction: this._options.friction, restitution: this._options.restitution };
    this.body.shape = this.shape;
    this.shape.material = this.material;
    this.body.setMassProperties({ mass: this._options.mass });
    this._nodeDisposeObserver = this.transformNode.onDisposeObservable.add(() => {
      this.dispose();
    });
  }
  _getObjectBoundingBox() {
    if (this.transformNode.getRawBoundingInfo) {
      return this.transformNode.getRawBoundingInfo().boundingBox;
    } else {
      return new BoundingBox(new Vector3(-0.5, -0.5, -0.5), new Vector3(0.5, 0.5, 0.5));
    }
  }
  _hasVertices(node) {
    return (node == null ? void 0 : node.getTotalVertices()) > 0;
  }
  _addSizeOptions() {
    this.transformNode.computeWorldMatrix(true);
    const bb = this._getObjectBoundingBox();
    const extents = TmpVectors.Vector3[0];
    extents.copyFrom(bb.extendSize);
    extents.scaleInPlace(2);
    extents.multiplyInPlace(this.transformNode.absoluteScaling);
    extents.x = Math.abs(extents.x);
    extents.y = Math.abs(extents.y);
    extents.z = Math.abs(extents.z);
    const min = TmpVectors.Vector3[1];
    min.copyFrom(bb.minimum);
    min.multiplyInPlace(this.transformNode.absoluteScaling);
    if (!this._options.center) {
      const center = new Vector3();
      center.copyFrom(bb.center);
      center.multiplyInPlace(this.transformNode.absoluteScaling);
      this._options.center = center;
    }
    switch (this.type) {
      case 0:
        if (!this._options.radius && WithinEpsilon(extents.x, extents.y, 1e-4) && WithinEpsilon(extents.x, extents.z, 1e-4)) {
          this._options.radius = extents.x / 2;
        } else if (!this._options.radius) {
          Logger.Warn("Non uniform scaling is unsupported for sphere shapes. Setting the radius to the biggest bounding box extent.");
          this._options.radius = Math.max(extents.x, extents.y, extents.z) / 2;
        }
        break;
      case 1:
        {
          const capRadius = extents.x / 2;
          this._options.radius = this._options.radius ?? capRadius;
          this._options.pointA = this._options.pointA ?? new Vector3(0, min.y + capRadius, 0);
          this._options.pointB = this._options.pointB ?? new Vector3(0, min.y + extents.y - capRadius, 0);
        }
        break;
      case 2:
        {
          const capRadius = extents.x / 2;
          this._options.radius = this._options.radius ?? capRadius;
          this._options.pointA = this._options.pointA ?? new Vector3(0, min.y, 0);
          this._options.pointB = this._options.pointB ?? new Vector3(0, min.y + extents.y, 0);
        }
        break;
      case 6:
      case 4:
      case 7:
        if (!this._options.mesh && this._hasVertices(this.transformNode)) {
          this._options.mesh = this.transformNode;
        } else if (!this._options.mesh || !this._hasVertices(this._options.mesh)) {
          throw new Error("No valid mesh was provided for mesh or convex hull shape parameter. Please provide a mesh with valid geometry (number of vertices greater than 0).");
        }
        break;
      case 3:
        this._options.extents = this._options.extents ?? new Vector3(extents.x, extents.y, extents.z);
        this._options.rotation = this._options.rotation ?? Quaternion.Identity();
        break;
    }
  }
  /**
   * Releases the body, shape and material
   */
  dispose() {
    if (this._nodeDisposeObserver) {
      this.body.transformNode.onDisposeObservable.remove(this._nodeDisposeObserver);
      this._nodeDisposeObserver = null;
    }
    this.body.dispose();
    if (this._disposeShapeWhenDisposed) {
      this.shape.dispose();
    }
  }
};

// node_modules/@babylonjs/core/Physics/v2/ragdoll.js
var RagdollBoneProperties = class {
};
var Ragdoll = class {
  /**
   * Construct a new Ragdoll object. Once ready, it can be made dynamic by calling `Ragdoll` method
   * @param skeleton The skeleton containing bones to be physicalized
   * @param rootTransformNode The mesh or its transform used by the skeleton
   * @param config an array of `RagdollBoneProperties` corresponding to bones and their properties used to instanciate physics bodies
   */
  constructor(skeleton, rootTransformNode, config) {
    this._boxConfigs = new Array();
    this._joints = new Array();
    this._bones = new Array();
    this._initialRotation = new Array();
    this._initialRotation2 = new Array();
    this._boneNames = [];
    this._transforms = new Array();
    this._aggregates = new Array();
    this._ragdollMode = false;
    this._rootBoneName = "";
    this._rootBoneIndex = -1;
    this._mass = 10;
    this._restitution = 0;
    this.pauseSync = false;
    this._defaultJoint = 3;
    this._defaultJointMin = -90;
    this._defaultJointMax = 90;
    this._skeleton = skeleton;
    this._scene = skeleton.getScene();
    this._rootTransformNode = rootTransformNode;
    this._config = config;
    this._boxConfigs = [];
    this._putBoxesInBoneCenter = false;
    this._defaultJoint = 3;
    this._init();
  }
  /**
   * Returns the aggregate corresponding to the ragdoll bone index
   * @param index ragdoll bone aggregate index
   * @returns the aggregate for the bone index for the root aggregate if index is invalid
   */
  getAggregate(index) {
    if (index < 0 || index >= this._aggregates.length) {
      return this._aggregates[this._rootBoneIndex];
    }
    return this._aggregates[index];
  }
  _createColliders() {
    this._rootTransformNode.computeWorldMatrix();
    this._skeleton.computeAbsoluteMatrices(true);
    this._skeleton.prepare(true);
    const config = this._config;
    for (let i = 0; i < config.length; i++) {
      const boneNames = config[i].bone !== void 0 ? [config[i].bone] : config[i].bones;
      for (let ii = 0; ii < boneNames.length; ii++) {
        const currentBone = this._skeleton.bones[this._skeleton.getBoneIndexByName(boneNames[ii])];
        if (currentBone == void 0) {
          return;
        }
        const currentRagdollBoneProperties = {
          width: this._config[i].width,
          depth: this._config[i].depth,
          height: this._config[i].height,
          size: this._config[i].size
        };
        currentRagdollBoneProperties.width = currentRagdollBoneProperties.width ?? currentRagdollBoneProperties.size;
        currentRagdollBoneProperties.depth = currentRagdollBoneProperties.depth ?? currentRagdollBoneProperties.size;
        currentRagdollBoneProperties.height = currentRagdollBoneProperties.height ?? currentRagdollBoneProperties.size;
        const transform = new TransformNode(boneNames[ii] + "_transform", this._scene);
        currentRagdollBoneProperties.joint = config[i].joint !== void 0 ? config[i].joint : this._defaultJoint;
        currentRagdollBoneProperties.rotationAxis = config[i].rotationAxis !== void 0 ? config[i].rotationAxis : Axis.X;
        currentRagdollBoneProperties.min = config[i].min !== void 0 ? config[i].min : this._defaultJointMin;
        currentRagdollBoneProperties.max = config[i].max !== void 0 ? config[i].max : this._defaultJointMax;
        let boxOffset = 0;
        if (config[i].putBoxInBoneCenter !== void 0 && config[i].putBoxInBoneCenter || this._putBoxesInBoneCenter) {
          if (currentBone.length === void 0) {
            Logger.Log("The length property is not defined for bone " + currentBone.name);
          }
          boxOffset = currentBone.length / 2;
        } else if (config[i].boxOffset !== void 0) {
          boxOffset = config[i].boxOffset;
        }
        currentRagdollBoneProperties.boxOffset = boxOffset;
        const boneOffsetAxis = config[i].boneOffsetAxis !== void 0 ? config[i].boneOffsetAxis : Axis.Y;
        const boneDir = currentBone.getDirection(boneOffsetAxis, this._rootTransformNode);
        currentRagdollBoneProperties.boneOffsetAxis = boneOffsetAxis;
        transform.position = currentBone.getAbsolutePosition(this._rootTransformNode).add(boneDir.scale(boxOffset));
        const mass = config[i].mass !== void 0 ? config[i].mass : this._mass;
        const restitution = config[i].restitution !== void 0 ? config[i].restitution : this._restitution;
        const aggregate = new PhysicsAggregate(transform, 3, {
          mass,
          restitution,
          friction: 0.6,
          extents: new Vector3(currentRagdollBoneProperties.width, currentRagdollBoneProperties.height, currentRagdollBoneProperties.depth)
        }, this._scene);
        aggregate.body.setCollisionCallbackEnabled(true);
        aggregate.body.disablePreStep = false;
        aggregate.body.setMotionType(
          1
          /* PhysicsMotionType.ANIMATED */
        );
        this._aggregates.push(aggregate);
        this._bones.push(currentBone);
        this._boneNames.push(currentBone.name);
        this._transforms.push(transform);
        this._boxConfigs.push(currentRagdollBoneProperties);
        this._initialRotation.push(currentBone.getRotationQuaternion(1, this._rootTransformNode));
        this._initialRotation2.push(currentBone.getRotationQuaternion(
          1
          /* Space.WORLD */
        ));
      }
    }
  }
  _initJoints() {
    this._rootTransformNode.computeWorldMatrix();
    for (let i = 0; i < this._bones.length; i++) {
      if (i == this._rootBoneIndex)
        continue;
      const nearestParent = this._findNearestParent(i);
      if (nearestParent == null) {
        Logger.Warn("Couldn't find a nearest parent bone in the configs for bone called " + this._boneNames[i]);
        return;
      }
      const boneParentIndex = this._boneNames.indexOf(nearestParent.name);
      let distanceFromParentBoxToBone = this._bones[i].getAbsolutePosition(this._rootTransformNode).subtract(this._transforms[boneParentIndex].position);
      const wmat = this._transforms[boneParentIndex].computeWorldMatrix();
      const invertedWorldMat = Matrix.Invert(wmat);
      distanceFromParentBoxToBone = Vector3.TransformCoordinates(this._bones[i].getAbsolutePosition(this._rootTransformNode), invertedWorldMat);
      const boneAbsPos = this._bones[i].getAbsolutePosition(this._rootTransformNode);
      const boxAbsPos = this._transforms[i].position.clone();
      const myConnectedPivot = boneAbsPos.subtract(boxAbsPos);
      const joint = new PhysicsConstraint(1, {
        pivotA: distanceFromParentBoxToBone,
        pivotB: myConnectedPivot,
        axisA: this._boxConfigs[i].rotationAxis,
        axisB: this._boxConfigs[i].rotationAxis,
        collision: false
      }, this._scene);
      this._aggregates[boneParentIndex].body.addConstraint(this._aggregates[i].body, joint);
      joint.isEnabled = false;
      this._joints.push(joint);
    }
  }
  // set physics body orientation/position from bones
  _syncBonesToPhysics() {
    const rootMatrix = this._rootTransformNode.getWorldMatrix();
    for (let i = 0; i < this._bones.length; i++) {
      const transform = this._aggregates[i].transformNode;
      const rootPos = this._bones[i].getAbsolutePosition();
      Vector3.TransformCoordinatesToRef(rootPos, rootMatrix, transform.position);
      this._bones[i].getDirectionToRef(this._boxConfigs[i].boneOffsetAxis, this._rootTransformNode, TmpVectors.Vector3[0]);
      TmpVectors.Vector3[0].scaleInPlace(this._boxConfigs[i].boxOffset ?? 0);
      transform.position.addInPlace(TmpVectors.Vector3[0]);
      this._setBoneOrientationToBody(i);
    }
  }
  _setBoneOrientationToBody(boneIndex) {
    const transform = this._aggregates[boneIndex].transformNode;
    const bone = this._bones[boneIndex];
    this._initialRotation[boneIndex].conjugateToRef(TmpVectors.Quaternion[0]);
    bone.getRotationQuaternionToRef(1, this._rootTransformNode, TmpVectors.Quaternion[1]);
    TmpVectors.Quaternion[1].multiplyToRef(TmpVectors.Quaternion[0], transform.rotationQuaternion);
    transform.rotationQuaternion.normalize();
  }
  _syncBonesAndBoxes() {
    if (this.pauseSync) {
      return;
    }
    if (this._ragdollMode) {
      this._setBodyOrientationToBone(this._rootBoneIndex);
      const rootPos = this._aggregates[this._rootBoneIndex].body.transformNode.position;
      this._rootTransformNode.getWorldMatrix().invertToRef(TmpVectors.Matrix[0]);
      Vector3.TransformCoordinatesToRef(rootPos, TmpVectors.Matrix[0], TmpVectors.Vector3[0]);
      this._bones[this._rootBoneIndex].setAbsolutePosition(TmpVectors.Vector3[0]);
      for (let i = 0; i < this._bones.length; i++) {
        if (i == this._rootBoneIndex)
          continue;
        this._setBodyOrientationToBone(i);
      }
    } else {
      this._syncBonesToPhysics();
    }
  }
  _setBodyOrientationToBone(boneIndex) {
    var _a, _b;
    const qmesh = this._rootTransformNode.rotationQuaternion ?? Quaternion.FromEulerAngles(this._rootTransformNode.rotation.x, this._rootTransformNode.rotation.y, this._rootTransformNode.rotation.z);
    const qbind = this._initialRotation2[boneIndex];
    const qphys = (_b = (_a = this._aggregates[boneIndex].body) == null ? void 0 : _a.transformNode) == null ? void 0 : _b.rotationQuaternion;
    qmesh.multiplyToRef(qbind, TmpVectors.Quaternion[1]);
    qphys.multiplyToRef(TmpVectors.Quaternion[1], TmpVectors.Quaternion[0]);
    this._bones[boneIndex].setRotationQuaternion(TmpVectors.Quaternion[0], 1, this._rootTransformNode);
  }
  // Return true if root bone is valid/exists in this.bonesNames. false otherwise.
  _defineRootBone() {
    const skeletonRoots = this._skeleton.getChildren();
    if (skeletonRoots.length != 1) {
      Logger.Log("Ragdoll creation failed: there can only be one root in the skeleton.");
      return false;
    }
    this._rootBoneName = skeletonRoots[0].name;
    this._rootBoneIndex = this._boneNames.indexOf(this._rootBoneName);
    if (this._rootBoneIndex == -1) {
      Logger.Log("Ragdoll creation failed: the array boneNames doesn't have the root bone. The root bone is " + this._skeleton.getChildren());
      return false;
    }
    return true;
  }
  _findNearestParent(boneIndex) {
    let nearestParent = this._bones[boneIndex].getParent();
    do {
      if (nearestParent != null && this._boneNames.includes(nearestParent.name)) {
        break;
      }
      nearestParent = nearestParent == null ? void 0 : nearestParent.getParent();
    } while (nearestParent != null);
    return nearestParent;
  }
  _init() {
    this._createColliders();
    if (!this._defineRootBone()) {
      return;
    }
    this._initJoints();
    this._scene.registerBeforeRender(() => {
      this._syncBonesAndBoxes();
    });
    this._syncBonesToPhysics();
  }
  /**
   * Enable ragdoll mode. Create physics objects and make them dynamic.
   */
  ragdoll() {
    this._ragdollMode = true;
    this._skeleton.bones.forEach((bone) => {
      bone.linkTransformNode(null);
    });
    for (let i = 0; i < this._joints.length; i++) {
      this._joints[i].isEnabled = true;
    }
    for (let i = 0; i < this._aggregates.length; i++) {
      this._aggregates[i].body.setMotionType(
        2
        /* PhysicsMotionType.DYNAMIC */
      );
    }
  }
  /**
   * Dispose resources and remove physics objects
   */
  dispose() {
    this._aggregates.forEach((aggregate) => {
      aggregate.dispose();
    });
  }
};

// node_modules/@babylonjs/core/Physics/v2/characterController.js
var CharacterSupportedState;
(function(CharacterSupportedState2) {
  CharacterSupportedState2[CharacterSupportedState2["UNSUPPORTED"] = 0] = "UNSUPPORTED";
  CharacterSupportedState2[CharacterSupportedState2["SLIDING"] = 1] = "SLIDING";
  CharacterSupportedState2[CharacterSupportedState2["SUPPORTED"] = 2] = "SUPPORTED";
})(CharacterSupportedState || (CharacterSupportedState = {}));
var SurfaceConstraintInteractionStatus;
(function(SurfaceConstraintInteractionStatus2) {
  SurfaceConstraintInteractionStatus2[SurfaceConstraintInteractionStatus2["OK"] = 0] = "OK";
  SurfaceConstraintInteractionStatus2[SurfaceConstraintInteractionStatus2["FAILURE_3D"] = 1] = "FAILURE_3D";
  SurfaceConstraintInteractionStatus2[SurfaceConstraintInteractionStatus2["FAILURE_2D"] = 2] = "FAILURE_2D";
})(SurfaceConstraintInteractionStatus || (SurfaceConstraintInteractionStatus = {}));
var SimplexSolverOutput = class {
};
var SimplexSolverActivePlanes = class {
  /** @internal */
  copyFrom(other) {
    this.index = other.index;
    this.constraint = other.constraint;
    this.interaction = other.interaction;
  }
};
var SimplexSolverInfo = class {
  constructor() {
    this.supportPlanes = new Array(4);
    this.numSupportPlanes = 0;
    this.currentTime = 0;
  }
  /** @internal */
  getOutput(constraint) {
    return this.outputInteractions[this.inputConstraints.indexOf(constraint)];
  }
};
function contactFromCast(hp, cp, castPath, hitFraction, keepDistance) {
  const bodyMap = hp._bodies;
  const normal = Vector3.FromArray(cp[4]);
  const dist = -hitFraction * castPath.dot(normal);
  return {
    position: Vector3.FromArray(cp[3]),
    normal,
    distance: dist,
    fraction: hitFraction,
    bodyB: bodyMap.get(cp[0][0]),
    allowedPenetration: Math.min(Math.max(keepDistance - dist, 0), keepDistance)
  };
}
var PhysicsCharacterController = class {
  /**
   * instanciate a new characterController
   * @param position Initial position
   * @param characterShapeOptions character physics shape options
   * @param scene Scene
   */
  constructor(position, characterShapeOptions, scene) {
    this._orientation = Quaternion.Identity();
    this._manifold = [];
    this._contactAngleSensitivity = 10;
    this._tmpMatrix = new Matrix();
    this._tmpVecs = BuildArray(31, Vector3.Zero);
    this.keepDistance = 0.05;
    this.keepContactTolerance = 0.1;
    this.maxCastIterations = 10;
    this.penetrationRecoverySpeed = 1;
    this.staticFriction = 0;
    this.dynamicFriction = 1;
    this.maxSlopeCosine = 0.5;
    this.maxCharacterSpeedForSolver = 10;
    this.up = new Vector3(0, 1, 0);
    this.characterStrength = 1e38;
    this.characterMass = 0;
    this._position = position.clone();
    this._velocity = Vector3.Zero();
    this._lastVelocity = Vector3.Zero();
    const r = characterShapeOptions.capsuleRadius ?? 0.6;
    const h = characterShapeOptions.capsuleHeight ?? 1.8;
    this._tmpVecs[0].set(0, h * 0.5 - r, 0);
    this._tmpVecs[1].set(0, -h * 0.5 + r, 0);
    this._shape = characterShapeOptions.shape ?? new PhysicsShapeCapsule(this._tmpVecs[0], this._tmpVecs[1], r, scene);
    this._lastInvDeltaTime = 1 / 60;
    this._lastDisplacement = Vector3.Zero();
    this._scene = scene;
    const hk = this._scene.getPhysicsEngine().getPhysicsPlugin();
    const hknp = hk._hknp;
    this._startCollector = hknp.HP_QueryCollector_Create(16)[1];
    this._castCollector = hknp.HP_QueryCollector_Create(16)[1];
  }
  /**
   * Character position
   * @returns Character position
   */
  getPosition() {
    return this._position;
  }
  /**
   * Character velocity
   * @returns Character velocity vector
   */
  getVelocity() {
    return this._velocity;
  }
  /**
   * Set velocity vector
   * @param velocity vector
   */
  setVelocity(velocity) {
    this._velocity.copyFrom(velocity);
  }
  _validateManifold() {
    const newManifold = [];
    for (let i = 0; i < this._manifold.length; i++) {
      if (!this._manifold[i].bodyB.body.isDisposed) {
        newManifold.push(this._manifold[i]);
      }
    }
    this._manifold = newManifold;
  }
  _getPointVelocityToRef(body, pointWorld, result) {
    const comWorld = this._tmpVecs[10];
    this._getComWorldToRef(body, comWorld);
    const relPos = this._tmpVecs[11];
    pointWorld.subtractToRef(comWorld, relPos);
    const av = this._tmpVecs[12];
    body.body.getAngularVelocityToRef(av, body.index);
    const arm = this._tmpVecs[13];
    Vector3.CrossToRef(av, relPos, arm);
    arm.addToRef(body.body.getLinearVelocity(body.index), result);
  }
  _compareContacts(contactA, contactB) {
    const angSquared = (1 - contactA.normal.dot(contactB.normal)) * this._contactAngleSensitivity * this._contactAngleSensitivity;
    const planeDistSquared = (contactA.distance - contactB.distance) * (contactA.distance * contactB.distance);
    const p1Vel = this._tmpVecs[7];
    this._getPointVelocityToRef(contactA.bodyB, contactA.position, p1Vel);
    const p2Vel = this._tmpVecs[8];
    this._getPointVelocityToRef(contactB.bodyB, contactB.position, p2Vel);
    const velocityDiff = this._tmpVecs[9];
    p1Vel.subtractToRef(p2Vel, velocityDiff);
    const velocityDiffSquared = velocityDiff.lengthSquared();
    const fitness = angSquared * 10 + velocityDiffSquared * 0.1 + planeDistSquared;
    return fitness;
  }
  _findContact(referenceContact, contactList, threshold) {
    let bestIdx = -1;
    let bestFitness = threshold;
    for (let i = 0; i < contactList.length; i++) {
      const fitness = this._compareContacts(referenceContact, contactList[i]);
      if (fitness < bestFitness) {
        bestFitness = fitness;
        bestIdx = i;
      }
    }
    return bestIdx;
  }
  _updateManifold(startCollector, castCollector, castPath) {
    const hk = this._scene.getPhysicsEngine().getPhysicsPlugin();
    const hknp = hk._hknp;
    const numProximityHits = hknp.HP_QueryCollector_GetNumHits(startCollector)[1];
    if (numProximityHits > 0) {
      const newContacts = [];
      let minDistance = 1e38;
      const bodyMap = hk._bodies;
      for (let i = 0; i < numProximityHits; i++) {
        const [distance, , contactWorld] = hknp.HP_QueryCollector_GetShapeProximityResult(startCollector, i)[1];
        minDistance = Math.min(minDistance, distance);
        newContacts.push({
          position: Vector3.FromArray(contactWorld[3]),
          normal: Vector3.FromArray(contactWorld[4]),
          distance,
          fraction: 0,
          bodyB: bodyMap.get(contactWorld[0][0]),
          allowedPenetration: Math.min(Math.max(this.keepDistance - distance, 0), this.keepDistance)
        });
      }
      for (let i = this._manifold.length - 1; i >= 0; i--) {
        const currentContact = this._manifold[i];
        const bestMatch = this._findContact(currentContact, newContacts, 1.1);
        if (bestMatch >= 0) {
          const newAllowedPenetration = Math.min(Math.max(this.keepDistance - newContacts[bestMatch].distance, 0), currentContact.allowedPenetration);
          this._manifold[i] = newContacts[bestMatch];
          this._manifold[i].allowedPenetration = newAllowedPenetration;
          newContacts.splice(bestMatch, 1);
        } else {
          this._manifold.splice(i, 1);
        }
      }
      const closestContactIndex = newContacts.findIndex((c) => c.distance == minDistance);
      if (closestContactIndex >= 0) {
        const bestMatch = this._findContact(newContacts[closestContactIndex], this._manifold, 0.1);
        if (bestMatch >= 0) {
          const newAllowedPenetration = Math.min(Math.max(this.keepDistance - newContacts[closestContactIndex].distance, 0), this._manifold[bestMatch].allowedPenetration);
          this._manifold[bestMatch] = newContacts[closestContactIndex];
          this._manifold[bestMatch].allowedPenetration = newAllowedPenetration;
        } else {
          this._manifold.push(newContacts[closestContactIndex]);
        }
      }
    } else {
      this._manifold.length = 0;
    }
    let numHitBodies = 0;
    const numCastHits = hknp.HP_QueryCollector_GetNumHits(castCollector)[1];
    if (numCastHits > 0) {
      let closestHitBody = null;
      for (let i = 0; i < numCastHits; i++) {
        const [fraction, , hitWorld] = hknp.HP_QueryCollector_GetShapeCastResult(castCollector, i)[1];
        if (closestHitBody == null) {
          const contact = contactFromCast(hk, hitWorld, castPath, fraction, this.keepDistance);
          closestHitBody = hitWorld[0][0];
          const bestMatch = this._findContact(contact, this._manifold, 0.1);
          if (bestMatch == -1) {
            this._manifold.push(contact);
          }
          if (contact.bodyB.body.getMotionType(contact.bodyB.index) == 0) {
            break;
          }
        } else if (closestHitBody._pluginData && hitWorld[0] != closestHitBody._pluginData.hpBodyId) {
          numHitBodies++;
          break;
        }
      }
    }
    for (let e1 = this._manifold.length - 1; e1 >= 0; e1--) {
      let e2 = e1 - 1;
      for (; e2 >= 0; e2--) {
        const fitness = this._compareContacts(this._manifold[e1], this._manifold[e2]);
        if (fitness < 0.1)
          break;
      }
      if (e2 >= 0) {
        this._manifold.slice(e1, 1);
      }
    }
    return numHitBodies;
  }
  _createSurfaceConstraint(contact, timeTravelled) {
    const constraint = {
      //let distance = contact.distance - this.keepDistance;
      planeNormal: contact.normal.clone(),
      planeDistance: contact.distance,
      staticFriction: this.staticFriction,
      dynamicFriction: this.dynamicFriction,
      extraUpStaticFriction: 0,
      extraDownStaticFriction: 0,
      velocity: Vector3.Zero(),
      angularVelocity: Vector3.Zero(),
      priority: 0
    };
    const maxSlopeCosEps = 0.1;
    const maxSlopeCosine = Math.max(this.maxSlopeCosine, maxSlopeCosEps);
    const normalDotUp = contact.normal.dot(this.up);
    const contactPosition = contact.position.clone();
    if (normalDotUp > maxSlopeCosine) {
      const com = this.getPosition();
      const contactArm = this._tmpVecs[20];
      contact.position.subtractToRef(com, contactArm);
      const scale = contact.normal.dot(contactArm);
      contactPosition.x = com.x + this.up.x * scale;
      contactPosition.y = com.y + this.up.y * scale;
      contactPosition.z = com.z + this.up.z * scale;
    }
    const motionType = contact.bodyB.body.getMotionType(contact.bodyB.index);
    if (motionType != 0) {
    }
    const shift = constraint.velocity.dot(constraint.planeNormal) * timeTravelled;
    constraint.planeDistance -= shift;
    if (motionType == 0) {
      constraint.priority = 2;
    } else if (motionType == 1) {
      constraint.priority = 1;
    }
    return constraint;
  }
  _addMaxSlopePlane(maxSlopeCos, up, index, constraints, allowedPenetration) {
    const verticalComponent = constraints[index].planeNormal.dot(up);
    if (verticalComponent > 0.01 && verticalComponent < maxSlopeCos) {
      const newConstraint = {
        planeNormal: constraints[index].planeNormal.clone(),
        planeDistance: constraints[index].planeDistance,
        velocity: constraints[index].velocity.clone(),
        angularVelocity: constraints[index].angularVelocity.clone(),
        priority: constraints[index].priority,
        dynamicFriction: constraints[index].dynamicFriction,
        staticFriction: constraints[index].staticFriction,
        extraDownStaticFriction: constraints[index].extraDownStaticFriction,
        extraUpStaticFriction: constraints[index].extraUpStaticFriction
      };
      const distance = newConstraint.planeDistance;
      newConstraint.planeNormal.subtractInPlace(up.scale(verticalComponent));
      newConstraint.planeNormal.normalize();
      if (distance >= 0) {
        newConstraint.planeDistance = distance * newConstraint.planeNormal.dot(constraints[index].planeNormal);
      } else {
        const penetrationToResolve = Math.min(0, distance + allowedPenetration);
        newConstraint.planeDistance = penetrationToResolve / newConstraint.planeNormal.dot(constraints[index].planeNormal);
        constraints[index].planeDistance = 0;
        this._resolveConstraintPenetration(newConstraint, this.penetrationRecoverySpeed);
      }
      constraints.push(newConstraint);
      return true;
    }
    return false;
  }
  _resolveConstraintPenetration(constraint, penetrationRecoverySpeed) {
    const eps = 1e-6;
    if (constraint.planeDistance < -eps) {
      constraint.planeNormal.scaleToRef(constraint.planeDistance * penetrationRecoverySpeed, this._tmpVecs[6]);
      constraint.velocity.subtractInPlace(this._tmpVecs[6]);
    }
  }
  _createConstraintsFromManifold(dt, timeTravelled) {
    const constraints = [];
    for (let i = 0; i < this._manifold.length; i++) {
      const surfaceConstraint = this._createSurfaceConstraint(this._manifold[i], timeTravelled);
      constraints.push(surfaceConstraint);
      this._addMaxSlopePlane(this.maxSlopeCosine, this.up, i, constraints, this._manifold[i].allowedPenetration);
      this._resolveConstraintPenetration(surfaceConstraint, this.penetrationRecoverySpeed);
    }
    return constraints;
  }
  _simplexSolverSortInfo(info) {
    for (let i = 0; i < info.numSupportPlanes - 1; i++) {
      for (let j = i + 1; j < info.numSupportPlanes; j++) {
        const p0 = info.supportPlanes[i];
        const p1 = info.supportPlanes[j];
        if (p0.constraint.priority < p1.constraint.priority) {
          continue;
        }
        if (p0.constraint.priority == p1.constraint.priority) {
          const vel0 = p0.constraint.velocity.lengthSquared();
          const vel1 = p1.constraint.velocity.lengthSquared();
          if (vel0 < vel1) {
            continue;
          }
        }
        info.supportPlanes[i] = p1;
        info.supportPlanes[j] = p0;
      }
    }
  }
  _simplexSolverSolve1d(info, sci, velocityIn, velocityOut) {
    const eps = 1e-5;
    const groundVelocity = sci.velocity;
    const relativeVelocity = this._tmpVecs[22];
    velocityIn.subtractToRef(groundVelocity, relativeVelocity);
    const planeVel = relativeVelocity.dot(sci.planeNormal);
    const origVelocity2 = relativeVelocity.lengthSquared();
    relativeVelocity.subtractInPlace(sci.planeNormal.scale(planeVel));
    {
      const vp2 = planeVel * planeVel;
      const extraStaticFriction = relativeVelocity.dot(this.up) > 0 ? sci.extraUpStaticFriction : sci.extraDownStaticFriction;
      if (extraStaticFriction > 0) {
        const horizontal = this.up.cross(sci.planeNormal);
        const hor2 = horizontal.lengthSquared();
        let horVel = 0;
        if (hor2 > eps) {
          horizontal.scaleInPlace(1 / Math.sqrt(hor2));
          horVel = relativeVelocity.dot(horizontal);
          {
            const horVel2 = horVel * horVel;
            const f2 = sci.staticFriction * sci.staticFriction;
            if (vp2 * f2 >= horVel2) {
              relativeVelocity.subtractInPlace(horizontal.scale(horVel));
              horVel = 0;
            }
          }
        }
        {
          const vertVel2 = origVelocity2 - horVel * horVel - vp2;
          const f2 = (sci.staticFriction + extraStaticFriction) * (sci.staticFriction + extraStaticFriction);
          if (vp2 * f2 >= vertVel2) {
            if (horVel == 0) {
              velocityOut.copyFrom(groundVelocity);
              return;
            }
          }
        }
      } else {
        const f2 = sci.staticFriction * sci.staticFriction;
        if (vp2 * (1 + f2) >= origVelocity2) {
          velocityOut.copyFrom(groundVelocity);
          return;
        }
      }
    }
    if (sci.dynamicFriction < 1) {
      const velOut2 = relativeVelocity.lengthSquared();
      if (velOut2 >= eps) {
        if (velOut2 > 1e-4 * origVelocity2) {
          let f = Math.sqrt(origVelocity2 / velOut2);
          f = sci.dynamicFriction + (1 - sci.dynamicFriction) * f;
          relativeVelocity.scaleInPlace(f);
          const p = sci.planeNormal.dot(relativeVelocity);
          relativeVelocity.subtractInPlace(sci.planeNormal.scale(p));
        }
      }
    }
    velocityOut.copyFrom(relativeVelocity);
    velocityOut.addInPlace(groundVelocity);
  }
  _simplexSolverSolveTest1d(sci, velocityIn) {
    const eps = 1e-3;
    const relativeVelocity = this._tmpVecs[23];
    velocityIn.subtractToRef(sci.velocity, relativeVelocity);
    return relativeVelocity.dot(sci.planeNormal) < -eps;
  }
  _simplexSolverSolve2d(info, maxSurfaceVelocity, sci0, sci1, velocityIn, velocityOut) {
    const eps = 1e-5;
    const axis = sci0.planeNormal.cross(sci1.planeNormal);
    const axisLen2 = axis.lengthSquared();
    let solveSequentially = false;
    let axisVel = null;
    while (true) {
      if (axisLen2 <= eps || solveSequentially) {
        info.getOutput(sci0).status = 2;
        info.getOutput(sci1).status = 2;
        if (sci0.priority > sci1.priority) {
          this._simplexSolverSolve1d(info, sci1, velocityIn, velocityOut);
          this._simplexSolverSolve1d(info, sci0, velocityIn, velocityOut);
        } else {
          this._simplexSolverSolve1d(info, sci0, velocityIn, velocityOut);
          this._simplexSolverSolve1d(info, sci1, velocityIn, velocityOut);
        }
        return;
      }
      const invAxisLen = 1 / Math.sqrt(axisLen2);
      axis.scaleInPlace(invAxisLen);
      {
        const r0 = sci0.planeNormal.cross(sci1.planeNormal);
        const r1 = sci1.planeNormal.cross(axis);
        const r2 = axis.cross(sci0.planeNormal);
        const sVel = sci0.velocity.add(sci1.velocity);
        const t = this._tmpVecs[2];
        t.set(0.5 * axis.dot(sVel), sci0.planeNormal.dot(sci0.velocity), sci1.planeNormal.dot(sci1.velocity));
        const m = Matrix.FromValues(r0.x, r1.x, r2.x, 0, r0.y, r1.y, r2.y, 0, r0.z, r1.z, r2.z, 0, 0, 0, 0, 1);
        axisVel = Vector3.TransformNormal(t, m);
        axisVel.scaleInPlace(invAxisLen);
        if (Math.abs(axisVel.x) > maxSurfaceVelocity.x || Math.abs(axisVel.y) > maxSurfaceVelocity.y || Math.abs(axisVel.z) > maxSurfaceVelocity.z) {
          solveSequentially = true;
        } else {
          break;
        }
      }
    }
    const groundVelocity = axisVel;
    const relativeVelocity = this._tmpVecs[24];
    velocityIn.subtractToRef(groundVelocity, relativeVelocity);
    const vel2 = relativeVelocity.lengthSquared();
    const axisVert = this.up.dot(axis);
    let axisProjVelocity = relativeVelocity.dot(axis);
    let staticFriction = sci0.staticFriction + sci1.staticFriction;
    if (axisVert * axisProjVelocity > 0) {
      staticFriction += (sci0.extraUpStaticFriction + sci1.extraUpStaticFriction) * axisVert;
    } else {
      staticFriction += (sci0.extraDownStaticFriction + sci1.extraDownStaticFriction) * axisVert;
    }
    staticFriction *= 0.5;
    const dynamicFriction = (sci0.dynamicFriction + sci1.dynamicFriction) * 0.5;
    const f2 = staticFriction * staticFriction;
    const av2 = axisProjVelocity * axisProjVelocity;
    if ((vel2 - av2) * f2 >= av2) {
      velocityOut.copyFrom(groundVelocity);
      return;
    }
    if (dynamicFriction < 1) {
      if (axisProjVelocity * axisProjVelocity > 1e-4 * vel2) {
        const tmp = 1 / axisProjVelocity;
        const f = Math.abs(tmp) * Math.sqrt(vel2) * (1 - dynamicFriction) + dynamicFriction;
        axisProjVelocity *= f;
      }
    }
    velocityOut.copyFrom(groundVelocity);
    velocityOut.addInPlace(axis.scale(axisProjVelocity));
  }
  _simplexSolverSolve3d(info, maxSurfaceVelocity, sci0, sci1, sci2, allowResort, velocityIn, velocityOut) {
    const eps = 1e-5;
    let pointVel = null;
    {
      const r0 = sci1.planeNormal.cross(sci2.planeNormal);
      const r1 = sci2.planeNormal.cross(sci0.planeNormal);
      const r2 = sci0.planeNormal.cross(sci1.planeNormal);
      const det = r0.dot(sci0.planeNormal);
      let solveSequentially = false;
      while (true) {
        if (Math.abs(det) < eps || solveSequentially) {
          if (allowResort) {
            this._simplexSolverSortInfo(info);
            sci0 = info.supportPlanes[0].constraint;
            sci1 = info.supportPlanes[1].constraint;
            sci2 = info.supportPlanes[2].constraint;
          }
          info.getOutput(sci0).status = 1;
          info.getOutput(sci1).status = 1;
          info.getOutput(sci2).status = 1;
          const oldNum = info.numSupportPlanes;
          this._simplexSolverSolve2d(info, maxSurfaceVelocity, sci0, sci1, velocityIn, velocityOut);
          if (oldNum == info.numSupportPlanes) {
            this._simplexSolverSolve2d(info, maxSurfaceVelocity, sci0, sci2, velocityIn, velocityOut);
          }
          if (oldNum == info.numSupportPlanes) {
            this._simplexSolverSolve2d(info, maxSurfaceVelocity, sci1, sci2, velocityIn, velocityOut);
          }
          return;
        }
        const t = this._tmpVecs[2];
        t.set(sci0.planeNormal.dot(sci0.velocity), sci1.planeNormal.dot(sci1.velocity), sci2.planeNormal.dot(sci2.velocity));
        const m = Matrix.FromValues(r0.x, r0.y, r0.z, 0, r1.x, r1.y, r1.z, 0, r2.x, r2.y, r2.z, 0, 0, 0, 0, 1);
        pointVel = Vector3.TransformNormal(t, m);
        pointVel.scaleInPlace(1 / det);
        if (Math.abs(pointVel.x) > maxSurfaceVelocity.x || Math.abs(pointVel.y) > maxSurfaceVelocity.y || Math.abs(pointVel.z) > maxSurfaceVelocity.z) {
          solveSequentially = true;
        } else {
          break;
        }
      }
    }
    velocityOut.copyFrom(pointVel);
  }
  _simplexSolverExamineActivePlanes(info, maxSurfaceVelocity, velocityIn, velocityOut) {
    while (true) {
      switch (info.numSupportPlanes) {
        case 1: {
          const sci = info.supportPlanes[0].constraint;
          this._simplexSolverSolve1d(info, sci, velocityIn, velocityOut);
          return;
        }
        case 2: {
          const velocity = Vector3.Zero();
          this._simplexSolverSolve1d(info, info.supportPlanes[1].constraint, velocityIn, velocity);
          const plane0Used = this._simplexSolverSolveTest1d(info.supportPlanes[0].constraint, velocity);
          if (!plane0Used) {
            info.supportPlanes[0].copyFrom(info.supportPlanes[1]);
            info.numSupportPlanes = 1;
            velocityOut.copyFrom(velocity);
          } else {
            this._simplexSolverSolve2d(info, maxSurfaceVelocity, info.supportPlanes[0].constraint, info.supportPlanes[1].constraint, velocityIn, velocityOut);
          }
          return;
        }
        case 3: {
          {
            const velocity = Vector3.Zero();
            this._simplexSolverSolve1d(info, info.supportPlanes[2].constraint, velocityIn, velocityOut);
            const plane0Used = this._simplexSolverSolveTest1d(info.supportPlanes[0].constraint, velocity);
            if (!plane0Used) {
              const plane1Used = this._simplexSolverSolveTest1d(info.supportPlanes[1].constraint, velocity);
              if (!plane1Used) {
                velocityOut.copyFrom(velocity);
                info.supportPlanes[0].copyFrom(info.supportPlanes[2]);
                info.numSupportPlanes = 1;
                continue;
              }
            }
          }
          {
            let droppedAPlane = false;
            for (let testPlane = 0; testPlane < 2; testPlane++) {
              const velocity = Vector3.Zero();
              this._simplexSolverSolve2d(info, maxSurfaceVelocity, info.supportPlanes[testPlane].constraint, info.supportPlanes[2].constraint, velocityIn, velocityOut);
              const planeUsed = this._simplexSolverSolveTest1d(info.supportPlanes[1 - testPlane].constraint, velocity);
              if (!planeUsed) {
                info.supportPlanes[0].copyFrom(info.supportPlanes[testPlane]);
                info.supportPlanes[1].copyFrom(info.supportPlanes[2]);
                info.numSupportPlanes--;
                droppedAPlane = true;
                break;
              }
            }
            if (droppedAPlane) {
              continue;
            }
          }
          this._simplexSolverSolve3d(info, maxSurfaceVelocity, info.supportPlanes[0].constraint, info.supportPlanes[1].constraint, info.supportPlanes[2].constraint, true, velocityIn, velocityOut);
          return;
        }
        case 4: {
          this._simplexSolverSortInfo(info);
          let droppedAPlane = false;
          for (let i = 0; i < 3; i++) {
            const velocity = Vector3.Zero();
            this._simplexSolverSolve3d(info, maxSurfaceVelocity, info.supportPlanes[(i + 1) % 3].constraint, info.supportPlanes[(i + 2) % 3].constraint, info.supportPlanes[3].constraint, false, velocityIn, velocity);
            const planeUsed = this._simplexSolverSolveTest1d(info.supportPlanes[i].constraint, velocity);
            if (!planeUsed) {
              info.supportPlanes[i].copyFrom(info.supportPlanes[2]);
              info.supportPlanes[2].copyFrom(info.supportPlanes[3]);
              info.numSupportPlanes = 3;
              droppedAPlane = true;
              break;
            }
          }
          if (droppedAPlane) {
            continue;
          }
          {
            const velocity = velocityIn.clone();
            const sci0 = info.supportPlanes[0].constraint;
            const sci1 = info.supportPlanes[1].constraint;
            const sci2 = info.supportPlanes[2].constraint;
            const sci3 = info.supportPlanes[3].constraint;
            const oldNum = info.numSupportPlanes;
            if (oldNum == info.numSupportPlanes) {
              this._simplexSolverSolve3d(info, maxSurfaceVelocity, sci0, sci1, sci2, false, velocity, velocity);
            } else if (oldNum == info.numSupportPlanes) {
              this._simplexSolverSolve3d(info, maxSurfaceVelocity, sci0, sci1, sci3, false, velocity, velocity);
            } else if (oldNum == info.numSupportPlanes) {
              this._simplexSolverSolve3d(info, maxSurfaceVelocity, sci0, sci2, sci3, false, velocity, velocity);
            } else if (oldNum == info.numSupportPlanes) {
              this._simplexSolverSolve3d(info, maxSurfaceVelocity, sci1, sci2, sci3, false, velocity, velocity);
            }
            velocityOut.copyFrom(velocity);
          }
          {
            let maxStatus = 0;
            for (let i2 = 0; i2 < 4; i2++) {
              maxStatus = Math.max(maxStatus, info.supportPlanes[i2].interaction.status);
            }
            let i = 0;
            for (; i < 4; i++) {
              if (maxStatus == info.supportPlanes[i].interaction.status) {
                info.supportPlanes[i].copyFrom(info.supportPlanes[3]);
                break;
              }
              info.numSupportPlanes--;
            }
          }
          for (let i = 0; i < 3; i++) {
            info.supportPlanes[i].interaction.status = 0;
          }
          continue;
        }
      }
    }
  }
  _simplexSolverSolve(constraints, velocity, deltaTime, minDeltaTime, up, maxSurfaceVelocity) {
    const eps = 1e-6;
    const output = new SimplexSolverOutput();
    output.position = Vector3.Zero();
    output.velocity = velocity.clone();
    output.planeInteractions = [];
    let remainingTime = deltaTime;
    for (let i = 0; i < constraints.length; i++) {
      output.planeInteractions.push({
        touched: false,
        stopped: false,
        surfaceTime: 0,
        penaltyDistance: 0,
        status: 0
      });
    }
    const info = new SimplexSolverInfo();
    info.inputConstraints = constraints;
    info.outputInteractions = output.planeInteractions;
    info.supportPlanes[0] = new SimplexSolverActivePlanes();
    info.supportPlanes[1] = new SimplexSolverActivePlanes();
    info.supportPlanes[2] = new SimplexSolverActivePlanes();
    info.supportPlanes[3] = new SimplexSolverActivePlanes();
    while (remainingTime > 0) {
      let hitIndex = -1;
      let minCollisionTime = remainingTime;
      for (let i = 0; i < constraints.length; i++) {
        if (info.numSupportPlanes >= 1 && info.supportPlanes[0].index == i)
          continue;
        if (info.numSupportPlanes >= 2 && info.supportPlanes[1].index == i)
          continue;
        if (info.numSupportPlanes >= 3 && info.supportPlanes[2].index == i)
          continue;
        if (output.planeInteractions[i].status != 0) {
          continue;
        }
        const sci = constraints[i];
        const relativeVel = this._tmpVecs[25];
        output.velocity.subtractToRef(sci.velocity, relativeVel);
        const relativeProjectedVel = -relativeVel.dot(sci.planeNormal);
        if (relativeProjectedVel <= 0) {
          continue;
        }
        const relativePos = this._tmpVecs[26];
        sci.velocity.scaleToRef(info.currentTime, this._tmpVecs[27]);
        output.position.subtractToRef(this._tmpVecs[27], relativePos);
        let projectedPos = sci.planeNormal.dot(relativePos);
        const penaltyDist = output.planeInteractions[i].penaltyDistance;
        if (penaltyDist < eps) {
          projectedPos = 0;
        }
        projectedPos += penaltyDist;
        if (projectedPos < minCollisionTime * relativeProjectedVel) {
          minCollisionTime = projectedPos / relativeProjectedVel;
          hitIndex = i;
        }
      }
      const minAcceptableCollisionTime = 1e-4;
      if (minCollisionTime > minAcceptableCollisionTime) {
        info.currentTime += minCollisionTime;
        remainingTime -= minCollisionTime;
        output.position.addInPlace(output.velocity.scale(minCollisionTime));
        for (let i = 0; i < info.numSupportPlanes; i++) {
          info.supportPlanes[i].interaction.surfaceTime += minCollisionTime;
          info.supportPlanes[i].interaction.touched = true;
        }
        output.deltaTime = info.currentTime;
        if (info.currentTime > minDeltaTime) {
          return output;
        }
      }
      if (hitIndex < 0) {
        output.deltaTime = deltaTime;
        break;
      }
      const supportPlane = info.supportPlanes[info.numSupportPlanes++];
      supportPlane.constraint = constraints[hitIndex];
      supportPlane.interaction = output.planeInteractions[hitIndex];
      supportPlane.interaction.penaltyDistance = (supportPlane.interaction.penaltyDistance + eps) * 2;
      supportPlane.index = hitIndex;
      this._simplexSolverExamineActivePlanes(info, maxSurfaceVelocity, velocity, output.velocity);
    }
    return output;
  }
  /**
   * Compute a CharacterSurfaceInfo from current state and a direction
   * @param deltaTime frame delta time in seconds. When using scene.deltaTime divide by 1000.0
   * @param direction direction to check, usually gravity direction
   * @returns a CharacterSurfaceInfo object
   */
  checkSupport(deltaTime, direction) {
    const surfaceInfo = {
      isSurfaceDynamic: false,
      supportedState: 0,
      averageSurfaceNormal: Vector3.Zero(),
      averageSurfaceVelocity: Vector3.Zero(),
      averageAngularSurfaceVelocity: Vector3.Zero()
    };
    this.checkSupportToRef(deltaTime, direction, surfaceInfo);
    return surfaceInfo;
  }
  /**
   * Compute a CharacterSurfaceInfo from current state and a direction
   * @param deltaTime frame delta time in seconds. When using scene.deltaTime divide by 1000.0
   * @param direction direction to check, usually gravity direction
   * @param surfaceInfo output for surface info
   */
  checkSupportToRef(deltaTime, direction, surfaceInfo) {
    const eps = 1e-4;
    this._validateManifold();
    const constraints = this._createConstraintsFromManifold(deltaTime, 0);
    const storedVelocities = [];
    for (let i = 0; i < constraints.length; i++) {
      storedVelocities.push(constraints[i].velocity.clone());
      constraints[i].velocity.setAll(0);
    }
    const maxSurfaceVelocity = this._tmpVecs[3];
    maxSurfaceVelocity.set(this.maxCharacterSpeedForSolver, this.maxCharacterSpeedForSolver, this.maxCharacterSpeedForSolver);
    const output = this._simplexSolverSolve(constraints, direction, deltaTime, deltaTime, this.up, maxSurfaceVelocity);
    surfaceInfo.averageSurfaceVelocity.setAll(0);
    surfaceInfo.averageAngularSurfaceVelocity.setAll(0);
    surfaceInfo.averageSurfaceNormal.setAll(0);
    if (output.velocity.equalsWithEpsilon(direction, eps)) {
      surfaceInfo.supportedState = 0;
      return;
    }
    if (output.velocity.lengthSquared() < eps) {
      surfaceInfo.supportedState = 2;
    } else {
      output.velocity.normalize();
      const angleSin = output.velocity.dot(direction);
      const cosSqr = 1 - angleSin * angleSin;
      if (cosSqr < this.maxSlopeCosine * this.maxSlopeCosine) {
        surfaceInfo.supportedState = 1;
      } else {
        surfaceInfo.supportedState = 2;
      }
    }
    let numTouching = 0;
    for (let i = -0; i < constraints.length; i++) {
      if (output.planeInteractions[i].touched && constraints[i].planeNormal.dot(direction) < -0.08) {
        surfaceInfo.averageSurfaceNormal.addInPlace(constraints[i].planeNormal);
        surfaceInfo.averageSurfaceVelocity.addInPlace(storedVelocities[i]);
        surfaceInfo.averageAngularSurfaceVelocity.addInPlace(constraints[i].angularVelocity);
        numTouching++;
      }
    }
    if (numTouching > 0) {
      surfaceInfo.averageSurfaceNormal.normalize();
      surfaceInfo.averageSurfaceVelocity.scaleInPlace(1 / numTouching);
      surfaceInfo.averageAngularSurfaceVelocity.scaleInPlace(1 / numTouching);
    }
  }
  _castWithCollectors(startPos, endPos, castCollector, startCollector) {
    const hk = this._scene.getPhysicsEngine().getPhysicsPlugin();
    const hknp = hk._hknp;
    const startNative = [startPos.x, startPos.y, startPos.z];
    const orientation = [this._orientation.x, this._orientation.y, this._orientation.z, this._orientation.w];
    if (startCollector != null) {
      const query = [
        this._shape._pluginData,
        //@ts-ignore
        startNative,
        //@ts-ignore
        orientation,
        this.keepDistance + this.keepContactTolerance,
        // max distance
        false,
        // should hit triggers
        [BigInt(0)]
        // body to ignore //<todo allow for a proxy body!
      ];
      hknp.HP_World_ShapeProximityWithCollector(hk.world, startCollector, query);
    }
    {
      const query = [
        this._shape._pluginData,
        //@ts-ignore
        orientation,
        //@ts-ignore
        startNative,
        [endPos.x, endPos.y, endPos.z],
        false,
        // should hit triggers
        [BigInt(0)]
        // body to ignore //<todo allow for proxy body
      ];
      hknp.HP_World_ShapeCastWithCollector(hk.world, castCollector, query);
    }
  }
  _resolveContacts(deltaTime, gravity) {
    const eps = 1e-12;
    for (let i = 0; i < this._manifold.length; i++) {
      const contact = this._manifold[i];
      const bodyB = this._manifold[i].bodyB;
      if (bodyB.body.getMotionType(bodyB.index) != 2) {
        continue;
      }
      {
        let inputObjectMassInv = 0;
        let inputObjectImpulse = 0;
        let outputObjectImpulse = Vector3.Zero();
        const outputImpulsePosition = contact.position;
        const pointRelVel = this._tmpVecs[19];
        this._getPointVelocityToRef(bodyB, contact.position, pointRelVel);
        pointRelVel.subtractInPlace(this._velocity);
        const inputProjectedVelocity = pointRelVel.dot(contact.normal);
        const dampFactor = 0.9;
        let deltaVelocity = -inputProjectedVelocity * dampFactor;
        if (contact.distance < 0) {
          const recoveryTau = 0.4;
          deltaVelocity += contact.distance * recoveryTau / deltaTime;
        }
        if (deltaVelocity < 0) {
          const invInertia = this._getInverseInertiaWorld(bodyB);
          const comWorld = this._tmpVecs[15];
          this._getComWorldToRef(bodyB, comWorld);
          const r = this._tmpVecs[16];
          contact.position.subtractToRef(comWorld, r);
          const jacAng = this._tmpVecs[17];
          Vector3.CrossToRef(r, contact.normal, jacAng);
          const rc = this._tmpVecs[18];
          Vector3.TransformNormalToRef(jacAng, invInertia, rc);
          inputObjectMassInv = rc.dot(jacAng) + this._getInvMass(bodyB);
          inputObjectImpulse = deltaVelocity / inputObjectMassInv;
          const maxPushImpulse = -this.characterStrength * deltaTime;
          if (inputObjectImpulse < maxPushImpulse) {
            inputObjectImpulse = maxPushImpulse;
          }
          outputObjectImpulse = contact.normal.scale(inputObjectImpulse);
        } else {
          inputObjectImpulse = 0;
          inputObjectMassInv = this._getInvMass(bodyB);
        }
        {
          let relVelN = contact.normal.dot(gravity.scale(deltaTime));
          if (inputProjectedVelocity < 0) {
            relVelN -= inputProjectedVelocity;
          }
          if (relVelN < -eps) {
            outputObjectImpulse.addInPlace(contact.normal.scale(this.characterMass * relVelN));
          }
        }
        bodyB.body.applyImpulse(outputObjectImpulse, outputImpulsePosition, bodyB.index);
      }
    }
  }
  _getInverseInertiaWorld(body) {
    const mp = body.body.getMassProperties(body.index);
    if (!mp.inertia || !mp.inertiaOrientation) {
      return Matrix.IdentityReadOnly;
    }
    const invOrientation = Matrix.FromQuaternionToRef(mp.inertiaOrientation, TmpVectors.Matrix[0]).invert();
    const it = TmpVectors.Matrix[1];
    const ir = invOrientation.getRowToRef(0, TmpVectors.Vector4[0]);
    it.setRowFromFloats(0, mp.inertia.x * ir.x, mp.inertia.x * ir.y, mp.inertia.x * ir.z, 0);
    invOrientation.getRowToRef(1, ir);
    it.setRowFromFloats(0, mp.inertia.y * ir.x, mp.inertia.y * ir.y, mp.inertia.y * ir.z, 0);
    invOrientation.getRowToRef(2, ir);
    it.setRowFromFloats(0, mp.inertia.z * ir.x, mp.inertia.z * ir.y, mp.inertia.z * ir.z, 0);
    invOrientation.multiplyToRef(it, this._tmpMatrix);
    return this._tmpMatrix;
  }
  _getComWorldToRef(body, result) {
    const mp = body.body.getMassProperties(body.index);
    Vector3.TransformCoordinatesToRef(mp.centerOfMass, body.body.transformNode.getWorldMatrix(), result);
  }
  _getInvMass(body) {
    return 1 / body.body.getMassProperties(body.index).mass;
  }
  /**
   * Update internal state. Must be called once per frame
   * @param deltaTime frame delta time in seconds. When using scene.deltaTime divide by 1000.0
   * @param surfaceInfo surface information returned by checkSupport
   * @param gravity gravity applied to the character. Can be different that world gravity
   */
  integrate(deltaTime, surfaceInfo, gravity) {
    const hk = this._scene.getPhysicsEngine().getPhysicsPlugin();
    const invDeltaTime = 1 / deltaTime;
    let remainingTime = deltaTime;
    let newVelocity = Vector3.Zero();
    const displacementEps = 1e-4;
    const epsSqrd = 1e-8;
    {
      const tolerance = displacementEps * invDeltaTime;
      if (this._velocity.equalsWithEpsilon(this._lastVelocity, tolerance)) {
        this._lastDisplacement.scaleInPlace(remainingTime * this._lastInvDeltaTime);
      } else {
        const displacementVelocity = this._velocity;
        if (surfaceInfo.supportedState == 2) {
          const relativeVelocity = this._tmpVecs[28];
          this._velocity.subtractToRef(surfaceInfo.averageSurfaceVelocity, relativeVelocity);
          const normalDotVelocity = surfaceInfo.averageSurfaceNormal.dot(relativeVelocity);
          if (normalDotVelocity < 0) {
            relativeVelocity.subtractInPlace(surfaceInfo.averageSurfaceNormal.scale(normalDotVelocity));
            displacementVelocity.copyFrom(relativeVelocity);
            displacementVelocity.addInPlace(surfaceInfo.averageSurfaceVelocity);
          }
        }
        this._lastDisplacement.copyFrom(displacementVelocity);
        this._lastDisplacement.scaleInPlace(remainingTime);
      }
      this._lastVelocity.copyFrom(this._velocity);
      this._lastInvDeltaTime = invDeltaTime;
    }
    this._validateManifold();
    for (let iter = 0; iter < this.maxCastIterations && remainingTime > 1e-5; iter++) {
      this._castWithCollectors(this._position, this._position.add(this._lastDisplacement), this._castCollector, this._startCollector);
      const updateResult = this._updateManifold(this._startCollector, this._castCollector, this._lastDisplacement);
      const constraints = this._createConstraintsFromManifold(deltaTime, deltaTime - remainingTime);
      const maxSurfaceVelocity = this._tmpVecs[3];
      maxSurfaceVelocity.set(this.maxCharacterSpeedForSolver, this.maxCharacterSpeedForSolver, this.maxCharacterSpeedForSolver);
      const minDeltaTime = this._velocity.lengthSquared() == 0 ? 0 : 0.5 * this.keepDistance / this._velocity.length();
      const solveResults = this._simplexSolverSolve(constraints, this._velocity, remainingTime, minDeltaTime, this.up, maxSurfaceVelocity);
      const newDisplacement = solveResults.position;
      const solverDeltaTime = solveResults.deltaTime;
      newVelocity = solveResults.velocity;
      this._resolveContacts(deltaTime, gravity);
      let newContactIndex = -1;
      if (updateResult != 0 || newDisplacement.lengthSquared() > epsSqrd && !this._lastDisplacement.equalsWithEpsilon(newDisplacement, displacementEps)) {
        this._castWithCollectors(this._position, this._position.add(newDisplacement), this._castCollector, this._startCollector);
        const hknp = hk._hknp;
        const numCastHits = hknp.HP_QueryCollector_GetNumHits(this._castCollector)[1];
        if (numCastHits > 0) {
          for (let i = 0; i < numCastHits; i++) {
            const [fraction, _hitLocal, hitWorld] = hknp.HP_QueryCollector_GetShapeCastResult(this._castCollector, i)[1];
            const newContact = contactFromCast(hk, hitWorld, newDisplacement, fraction, this.keepDistance);
            if (this._findContact(newContact, this._manifold, 0.1) == -1) {
              newContactIndex = this._manifold.length;
              this._manifold.push(newContact);
              break;
            }
          }
        }
      }
      if (newContactIndex >= 0) {
        const newContact = this._manifold[newContactIndex];
        const displacementLengthInv = 1 / newDisplacement.length();
        const angleBetweenMovementAndSurface = newDisplacement.dot(newContact.normal) * displacementLengthInv;
        const keepDistanceAlongMovement = this.keepDistance / -angleBetweenMovementAndSurface;
        const distance = newContact.fraction;
        let fraction = distance - keepDistanceAlongMovement * displacementLengthInv;
        fraction = Math.min(Math.max(fraction, 0), 1);
        const displacement = newDisplacement.scale(fraction);
        this._position.addInPlace(displacement);
        remainingTime -= solverDeltaTime * fraction;
      } else {
        this._position.addInPlace(newDisplacement);
        remainingTime -= solverDeltaTime;
      }
      this._lastDisplacement.copyFrom(newDisplacement);
    }
    this._velocity.copyFrom(newVelocity);
  }
  /**
   * Helper function to calculate velocity based on surface informations and current velocity state and target
   * @param deltaTime frame delta time in seconds. When using scene.deltaTime divide by 1000.0
   * @param forwardWorld character forward in world coordinates
   * @param surfaceNormal surface normal direction
   * @param currentVelocity current velocity
   * @param surfaceVelocity velocity induced by the surface
   * @param desiredVelocity desired character velocity
   * @param upWorld up vector in world space
   * @param result resulting velocity vector
   * @returns boolean true if result has been computed
   */
  calculateMovementToRef(deltaTime, forwardWorld, surfaceNormal, currentVelocity, surfaceVelocity, desiredVelocity, upWorld, result) {
    const eps = 1e-5;
    let binorm = forwardWorld.cross(upWorld);
    if (binorm.lengthSquared() < eps) {
      return false;
    }
    binorm.normalize();
    const tangent = binorm.cross(surfaceNormal);
    tangent.normalize();
    binorm = tangent.cross(surfaceNormal);
    binorm.normalize();
    const surfaceFrame = Matrix.FromValues(tangent.x, tangent.y, tangent.z, 0, binorm.x, binorm.y, binorm.z, 0, surfaceNormal.x, surfaceNormal.y, surfaceNormal.z, 0, 0, 0, 0, 1);
    const invSurfaceFrame = surfaceFrame.clone().invert();
    currentVelocity.subtractToRef(surfaceVelocity, this._tmpVecs[29]);
    const relative = this._tmpVecs[30];
    Vector3.TransformNormalToRef(this._tmpVecs[29], invSurfaceFrame, relative);
    const sideVec = upWorld.cross(forwardWorld);
    const fwd = desiredVelocity.dot(forwardWorld);
    const side = desiredVelocity.dot(sideVec);
    const len = desiredVelocity.length();
    const desiredVelocitySF = this._tmpVecs[4];
    desiredVelocitySF.set(-fwd, side, 0);
    desiredVelocitySF.normalize();
    desiredVelocitySF.scaleInPlace(len);
    const diff = this._tmpVecs[5];
    desiredVelocitySF.subtractToRef(relative, diff);
    {
      const lenSq = diff.lengthSquared();
      const gain = 0.05;
      const maxVelocityDelta = 50 * deltaTime;
      let tmp;
      if (lenSq * gain * gain > maxVelocityDelta * maxVelocityDelta) {
        tmp = maxVelocityDelta / Math.sqrt(lenSq);
      } else {
        tmp = gain;
      }
      diff.scaleInPlace(tmp);
    }
    relative.addInPlace(diff);
    Vector3.TransformNormalToRef(relative, surfaceFrame, result);
    result.addInPlace(surfaceVelocity);
    return true;
  }
  /**
   * Helper function to calculate velocity based on surface informations and current velocity state and target
   * @param deltaTime frame delta time in seconds. When using scene.deltaTime divide by 1000.0
   * @param forwardWorld character forward in world coordinates
   * @param surfaceNormal surface normal direction
   * @param currentVelocity current velocity
   * @param surfaceVelocity velocity induced by the surface
   * @param desiredVelocity desired character velocity
   * @param upWorld up vector in world space
   * @returns a new velocity vector
   */
  calculateMovement(deltaTime, forwardWorld, surfaceNormal, currentVelocity, surfaceVelocity, desiredVelocity, upWorld) {
    const result = new Vector3(0, 0, 0);
    this.calculateMovementToRef(deltaTime, forwardWorld, surfaceNormal, currentVelocity, surfaceVelocity, desiredVelocity, upWorld, result);
    return result;
  }
};

export {
  CastingResult,
  PhysicsRaycastResult,
  PhysicsEngine,
  PhysicsBody,
  PhysicsConstraint,
  Physics6DoFLimit,
  Physics6DoFConstraint,
  BallAndSocketConstraint,
  DistanceConstraint,
  HingeConstraint,
  SliderConstraint,
  LockConstraint,
  PrismaticConstraint,
  SpringConstraint,
  PhysicsMaterialCombineMode,
  PhysicsAggregate,
  RagdollBoneProperties,
  Ragdoll,
  CharacterSupportedState,
  PhysicsCharacterController
};
//# sourceMappingURL=chunk-3WPB6A4X.js.map
