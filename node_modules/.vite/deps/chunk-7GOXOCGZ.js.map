{
  "version": 3,
  "sources": ["../../../dev/core/src/Animations/animationRange.ts", "../../../dev/core/src/Animations/animation.ts", "../../../dev/core/src/Bones/bone.ts"],
  "sourcesContent": ["/**\r\n * Represents the range of an animation\r\n */\r\nexport class AnimationRange {\r\n    /**\r\n     * Initializes the range of an animation\r\n     * @param name The name of the animation range\r\n     * @param from The starting frame of the animation\r\n     * @param to The ending frame of the animation\r\n     */\r\n    constructor(\r\n        /**The name of the animation range**/\r\n        public name: string,\r\n        /**The starting frame of the animation */\r\n        public from: number,\r\n        /**The ending frame of the animation*/\r\n        public to: number\r\n    ) {}\r\n\r\n    /**\r\n     * Makes a copy of the animation range\r\n     * @returns A copy of the animation range\r\n     */\r\n    public clone(): AnimationRange {\r\n        return new AnimationRange(this.name, this.from, this.to);\r\n    }\r\n}\r\n", "import type { IEasingFunction, EasingFunction } from \"./easing\";\r\nimport { Vector3, Quaternion, Vector2, Matrix, TmpVectors } from \"../Maths/math.vector\";\r\nimport { Color3, Color4 } from \"../Maths/math.color\";\r\nimport { Hermite, Lerp } from \"../Maths/math.scalar.functions\";\r\nimport type { DeepImmutable, Nullable } from \"../types\";\r\nimport type { Scene } from \"../scene\";\r\nimport { RegisterClass } from \"../Misc/typeStore\";\r\nimport type { IAnimationKey } from \"./animationKey\";\r\nimport { AnimationKeyInterpolation } from \"./animationKey\";\r\nimport { AnimationRange } from \"./animationRange\";\r\nimport type { AnimationEvent } from \"./animationEvent\";\r\nimport { Node } from \"../node\";\r\nimport type { IAnimatable } from \"./animatable.interface\";\r\nimport { Size } from \"../Maths/math.size\";\r\nimport { WebRequest } from \"../Misc/webRequest\";\r\nimport { Constants } from \"../Engines/constants\";\r\nimport type { Animatable } from \"./animatable\";\r\nimport type { RuntimeAnimation } from \"./runtimeAnimation\";\r\nimport { SerializationHelper } from \"../Misc/decorators.serialization\";\r\n\r\n// Static values to help the garbage collector\r\n\r\n// Quaternion\r\nexport const _staticOffsetValueQuaternion: DeepImmutable<Quaternion> = Object.freeze(new Quaternion(0, 0, 0, 0));\r\n\r\n// Vector3\r\nexport const _staticOffsetValueVector3: DeepImmutable<Vector3> = Object.freeze(Vector3.Zero());\r\n\r\n// Vector2\r\nexport const _staticOffsetValueVector2: DeepImmutable<Vector2> = Object.freeze(Vector2.Zero());\r\n\r\n// Size\r\nexport const _staticOffsetValueSize: DeepImmutable<Size> = Object.freeze(Size.Zero());\r\n\r\n// Color3\r\nexport const _staticOffsetValueColor3: DeepImmutable<Color3> = Object.freeze(Color3.Black());\r\n\r\n// Color4\r\nexport const _staticOffsetValueColor4: DeepImmutable<Color4> = Object.freeze(new Color4(0, 0, 0, 0));\r\n\r\n/**\r\n * Options to be used when creating an additive animation\r\n */\r\nexport interface IMakeAnimationAdditiveOptions {\r\n    /**\r\n     * The frame that the animation should be relative to (if not provided, 0 will be used)\r\n     */\r\n    referenceFrame?: number;\r\n    /**\r\n     * The name of the animation range to convert to additive. If not provided, fromFrame / toFrame will be used\r\n     * If fromFrame / toFrame are not provided either, the whole animation will be converted to additive\r\n     */\r\n    range?: string;\r\n    /**\r\n     * If true, the original animation will be cloned and converted to additive. If false, the original animation will be converted to additive (default is false)\r\n     */\r\n    cloneOriginalAnimation?: boolean;\r\n    /**\r\n     * The name of the cloned animation if cloneOriginalAnimation is true. If not provided, use the original animation name\r\n     */\r\n    clonedAnimationName?: string;\r\n    /**\r\n     * Together with toFrame, defines the range of the animation to convert to additive. Will only be used if range is not provided\r\n     * If range and fromFrame / toFrame are not provided, the whole animation will be converted to additive\r\n     */\r\n    fromFrame?: number;\r\n    /**\r\n     * Together with fromFrame, defines the range of the animation to convert to additive.\r\n     */\r\n    toFrame?: number;\r\n    /**\r\n     * If true, the key frames will be clipped to the range specified by range or fromFrame / toFrame (default is false)\r\n     */\r\n    clipKeys?: boolean;\r\n}\r\n\r\n/**\r\n * @internal\r\n */\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\nexport interface _IAnimationState {\r\n    key: number;\r\n    repeatCount: number;\r\n    workValue?: any;\r\n    loopMode?: number;\r\n    offsetValue?: any;\r\n    highLimitValue?: any;\r\n}\r\n\r\nconst evaluateAnimationState: _IAnimationState = {\r\n    key: 0,\r\n    repeatCount: 0,\r\n    loopMode: 2 /*Animation.ANIMATIONLOOPMODE_CONSTANT*/,\r\n};\r\n\r\n/**\r\n * Class used to store any kind of animation\r\n */\r\nexport class Animation {\r\n    private static _UniqueIdGenerator = 0;\r\n\r\n    /**\r\n     * Use matrix interpolation instead of using direct key value when animating matrices\r\n     */\r\n    public static AllowMatricesInterpolation = false;\r\n\r\n    /**\r\n     * When matrix interpolation is enabled, this boolean forces the system to use Matrix.DecomposeLerp instead of Matrix.Lerp. Interpolation is more precise but slower\r\n     */\r\n    public static AllowMatrixDecomposeForInterpolation = true;\r\n\r\n    /**\r\n     * Gets or sets the unique id of the animation (the uniqueness is solely among other animations)\r\n     */\r\n    public uniqueId: number;\r\n\r\n    /** Define the Url to load snippets */\r\n    public static SnippetUrl = Constants.SnippetUrl;\r\n\r\n    /** Snippet ID if the animation was created from the snippet server */\r\n    public snippetId: string;\r\n\r\n    /**\r\n     * Stores the key frames of the animation\r\n     */\r\n    private _keys: Array<IAnimationKey>;\r\n\r\n    /**\r\n     * Stores the easing function of the animation\r\n     */\r\n    private _easingFunction: Nullable<IEasingFunction> = null;\r\n\r\n    /**\r\n     * @internal Internal use only\r\n     */\r\n    public _runtimeAnimations = new Array<RuntimeAnimation>();\r\n\r\n    /**\r\n     * The set of event that will be linked to this animation\r\n     */\r\n    private _events = new Array<AnimationEvent>();\r\n\r\n    /**\r\n     * Stores an array of target property paths\r\n     */\r\n    public targetPropertyPath: string[];\r\n\r\n    /**\r\n     * Stores the blending speed of the animation\r\n     */\r\n    public blendingSpeed = 0.01;\r\n\r\n    /**\r\n     * Stores the animation ranges for the animation\r\n     */\r\n    private _ranges: { [name: string]: Nullable<AnimationRange> } = {};\r\n\r\n    /**\r\n     * @internal Internal use\r\n     */\r\n    public static _PrepareAnimation(\r\n        name: string,\r\n        targetProperty: string,\r\n        framePerSecond: number,\r\n        totalFrame: number,\r\n        from: any,\r\n        to: any,\r\n        loopMode?: number,\r\n        easingFunction?: EasingFunction\r\n    ): Nullable<Animation> {\r\n        let dataType = undefined;\r\n\r\n        if (!isNaN(parseFloat(from)) && isFinite(from)) {\r\n            dataType = Animation.ANIMATIONTYPE_FLOAT;\r\n        } else if (from instanceof Quaternion) {\r\n            dataType = Animation.ANIMATIONTYPE_QUATERNION;\r\n        } else if (from instanceof Vector3) {\r\n            dataType = Animation.ANIMATIONTYPE_VECTOR3;\r\n        } else if (from instanceof Vector2) {\r\n            dataType = Animation.ANIMATIONTYPE_VECTOR2;\r\n        } else if (from instanceof Color3) {\r\n            dataType = Animation.ANIMATIONTYPE_COLOR3;\r\n        } else if (from instanceof Color4) {\r\n            dataType = Animation.ANIMATIONTYPE_COLOR4;\r\n        } else if (from instanceof Size) {\r\n            dataType = Animation.ANIMATIONTYPE_SIZE;\r\n        }\r\n\r\n        if (dataType == undefined) {\r\n            return null;\r\n        }\r\n\r\n        const animation = new Animation(name, targetProperty, framePerSecond, dataType, loopMode);\r\n\r\n        const keys: Array<IAnimationKey> = [\r\n            { frame: 0, value: from },\r\n            { frame: totalFrame, value: to },\r\n        ];\r\n        animation.setKeys(keys);\r\n\r\n        if (easingFunction !== undefined) {\r\n            animation.setEasingFunction(easingFunction);\r\n        }\r\n\r\n        return animation;\r\n    }\r\n\r\n    /**\r\n     * Sets up an animation\r\n     * @param property The property to animate\r\n     * @param animationType The animation type to apply\r\n     * @param framePerSecond The frames per second of the animation\r\n     * @param easingFunction The easing function used in the animation\r\n     * @returns The created animation\r\n     */\r\n    public static CreateAnimation(property: string, animationType: number, framePerSecond: number, easingFunction: EasingFunction): Animation {\r\n        const animation: Animation = new Animation(property + \"Animation\", property, framePerSecond, animationType, Animation.ANIMATIONLOOPMODE_CONSTANT);\r\n\r\n        animation.setEasingFunction(easingFunction);\r\n\r\n        return animation;\r\n    }\r\n\r\n    /**\r\n     * Create and start an animation on a node\r\n     * @param name defines the name of the global animation that will be run on all nodes\r\n     * @param target defines the target where the animation will take place\r\n     * @param targetProperty defines property to animate\r\n     * @param framePerSecond defines the number of frame per second yo use\r\n     * @param totalFrame defines the number of frames in total\r\n     * @param from defines the initial value\r\n     * @param to defines the final value\r\n     * @param loopMode defines which loop mode you want to use (off by default)\r\n     * @param easingFunction defines the easing function to use (linear by default)\r\n     * @param onAnimationEnd defines the callback to call when animation end\r\n     * @param scene defines the hosting scene\r\n     * @returns the animatable created for this animation\r\n     */\r\n    public static CreateAndStartAnimation(\r\n        name: string,\r\n        target: any,\r\n        targetProperty: string,\r\n        framePerSecond: number,\r\n        totalFrame: number,\r\n        from: any,\r\n        to: any,\r\n        loopMode?: number,\r\n        easingFunction?: EasingFunction,\r\n        onAnimationEnd?: () => void,\r\n        scene?: Scene\r\n    ): Nullable<Animatable> {\r\n        const animation = Animation._PrepareAnimation(name, targetProperty, framePerSecond, totalFrame, from, to, loopMode, easingFunction);\r\n\r\n        if (!animation) {\r\n            return null;\r\n        }\r\n\r\n        if (target.getScene) {\r\n            scene = target.getScene();\r\n        }\r\n\r\n        if (!scene) {\r\n            return null;\r\n        }\r\n\r\n        return scene.beginDirectAnimation(target, [animation], 0, totalFrame, animation.loopMode !== Animation.ANIMATIONLOOPMODE_CONSTANT, 1.0, onAnimationEnd);\r\n    }\r\n\r\n    /**\r\n     * Create and start an animation on a node and its descendants\r\n     * @param name defines the name of the global animation that will be run on all nodes\r\n     * @param node defines the root node where the animation will take place\r\n     * @param directDescendantsOnly if true only direct descendants will be used, if false direct and also indirect (children of children, an so on in a recursive manner) descendants will be used\r\n     * @param targetProperty defines property to animate\r\n     * @param framePerSecond defines the number of frame per second to use\r\n     * @param totalFrame defines the number of frames in total\r\n     * @param from defines the initial value\r\n     * @param to defines the final value\r\n     * @param loopMode defines which loop mode you want to use (off by default)\r\n     * @param easingFunction defines the easing function to use (linear by default)\r\n     * @param onAnimationEnd defines the callback to call when an animation ends (will be called once per node)\r\n     * @returns the list of animatables created for all nodes\r\n     * @example https://www.babylonjs-playground.com/#MH0VLI\r\n     */\r\n    public static CreateAndStartHierarchyAnimation(\r\n        name: string,\r\n        node: Node,\r\n        directDescendantsOnly: boolean,\r\n        targetProperty: string,\r\n        framePerSecond: number,\r\n        totalFrame: number,\r\n        from: any,\r\n        to: any,\r\n        loopMode?: number,\r\n        easingFunction?: EasingFunction,\r\n        onAnimationEnd?: () => void\r\n    ): Nullable<Animatable[]> {\r\n        const animation = Animation._PrepareAnimation(name, targetProperty, framePerSecond, totalFrame, from, to, loopMode, easingFunction);\r\n\r\n        if (!animation) {\r\n            return null;\r\n        }\r\n\r\n        const scene = node.getScene();\r\n        return scene.beginDirectHierarchyAnimation(node, directDescendantsOnly, [animation], 0, totalFrame, animation.loopMode === 1, 1.0, onAnimationEnd);\r\n    }\r\n\r\n    /**\r\n     * Creates a new animation, merges it with the existing animations and starts it\r\n     * @param name Name of the animation\r\n     * @param node Node which contains the scene that begins the animations\r\n     * @param targetProperty Specifies which property to animate\r\n     * @param framePerSecond The frames per second of the animation\r\n     * @param totalFrame The total number of frames\r\n     * @param from The frame at the beginning of the animation\r\n     * @param to The frame at the end of the animation\r\n     * @param loopMode Specifies the loop mode of the animation\r\n     * @param easingFunction (Optional) The easing function of the animation, which allow custom mathematical formulas for animations\r\n     * @param onAnimationEnd Callback to run once the animation is complete\r\n     * @returns Nullable animation\r\n     */\r\n    public static CreateMergeAndStartAnimation(\r\n        name: string,\r\n        node: Node,\r\n        targetProperty: string,\r\n        framePerSecond: number,\r\n        totalFrame: number,\r\n        from: any,\r\n        to: any,\r\n        loopMode?: number,\r\n        easingFunction?: EasingFunction,\r\n        onAnimationEnd?: () => void\r\n    ): Nullable<Animatable> {\r\n        const animation = Animation._PrepareAnimation(name, targetProperty, framePerSecond, totalFrame, from, to, loopMode, easingFunction);\r\n\r\n        if (!animation) {\r\n            return null;\r\n        }\r\n\r\n        node.animations.push(animation);\r\n\r\n        return node.getScene().beginAnimation(node, 0, totalFrame, animation.loopMode === 1, 1.0, onAnimationEnd);\r\n    }\r\n\r\n    /**\r\n     * Convert the keyframes of an animation to be relative to a given reference frame.\r\n     * @param sourceAnimation defines the Animation containing keyframes to convert\r\n     * @param referenceFrame defines the frame that keyframes in the range will be relative to (default: 0)\r\n     * @param range defines the name of the AnimationRange belonging to the Animation to convert\r\n     * @param cloneOriginal defines whether or not to clone the animation and convert the clone or convert the original animation (default is false)\r\n     * @param clonedName defines the name of the resulting cloned Animation if cloneOriginal is true\r\n     * @returns a new Animation if cloneOriginal is true or the original Animation if cloneOriginal is false\r\n     */\r\n    public static MakeAnimationAdditive(sourceAnimation: Animation, referenceFrame?: number, range?: string, cloneOriginal?: boolean, clonedName?: string): Animation;\r\n\r\n    /**\r\n     * Convert the keyframes of an animation to be relative to a given reference frame.\r\n     * @param sourceAnimation defines the Animation containing keyframes to convert\r\n     * @param options defines the options to use when converting ey keyframes\r\n     * @returns a new Animation if options.cloneOriginalAnimation is true or the original Animation if options.cloneOriginalAnimation is false\r\n     */\r\n    public static MakeAnimationAdditive(sourceAnimation: Animation, options?: IMakeAnimationAdditiveOptions): Animation;\r\n\r\n    /** @internal */\r\n    public static MakeAnimationAdditive(\r\n        sourceAnimation: Animation,\r\n        referenceFrameOrOptions?: number | IMakeAnimationAdditiveOptions,\r\n        range?: string,\r\n        cloneOriginal = false,\r\n        clonedName?: string\r\n    ): Animation {\r\n        let options: IMakeAnimationAdditiveOptions;\r\n\r\n        if (typeof referenceFrameOrOptions === \"object\") {\r\n            options = referenceFrameOrOptions;\r\n        } else {\r\n            options = {\r\n                referenceFrame: referenceFrameOrOptions ?? 0,\r\n                range: range,\r\n                cloneOriginalAnimation: cloneOriginal,\r\n                clonedAnimationName: clonedName,\r\n            };\r\n        }\r\n\r\n        let animation = sourceAnimation;\r\n\r\n        if (options.cloneOriginalAnimation) {\r\n            animation = sourceAnimation.clone();\r\n            animation.name = options.clonedAnimationName || animation.name;\r\n        }\r\n\r\n        if (!animation._keys.length) {\r\n            return animation;\r\n        }\r\n\r\n        const referenceFrame = options.referenceFrame && options.referenceFrame >= 0 ? options.referenceFrame : 0;\r\n        let startIndex = 0;\r\n        const firstKey = animation._keys[0];\r\n        let endIndex = animation._keys.length - 1;\r\n        const lastKey = animation._keys[endIndex];\r\n        const valueStore = {\r\n            referenceValue: firstKey.value,\r\n            referencePosition: TmpVectors.Vector3[0],\r\n            referenceQuaternion: TmpVectors.Quaternion[0],\r\n            referenceScaling: TmpVectors.Vector3[1],\r\n            keyPosition: TmpVectors.Vector3[2],\r\n            keyQuaternion: TmpVectors.Quaternion[1],\r\n            keyScaling: TmpVectors.Vector3[3],\r\n        };\r\n        let from = firstKey.frame;\r\n        let to = lastKey.frame;\r\n        if (options.range) {\r\n            const rangeValue = animation.getRange(options.range);\r\n\r\n            if (rangeValue) {\r\n                from = rangeValue.from;\r\n                to = rangeValue.to;\r\n            }\r\n        } else {\r\n            from = options.fromFrame ?? from;\r\n            to = options.toFrame ?? to;\r\n        }\r\n\r\n        if (from !== firstKey.frame) {\r\n            startIndex = animation.createKeyForFrame(from);\r\n        }\r\n\r\n        if (to !== lastKey.frame) {\r\n            endIndex = animation.createKeyForFrame(to);\r\n        }\r\n\r\n        // There's only one key, so use it\r\n        if (animation._keys.length === 1) {\r\n            const value = animation._getKeyValue(animation._keys[0]);\r\n            valueStore.referenceValue = value.clone ? value.clone() : value;\r\n        }\r\n\r\n        // Reference frame is before the first frame, so just use the first frame\r\n        else if (referenceFrame <= firstKey.frame) {\r\n            const value = animation._getKeyValue(firstKey.value);\r\n            valueStore.referenceValue = value.clone ? value.clone() : value;\r\n        }\r\n\r\n        // Reference frame is after the last frame, so just use the last frame\r\n        else if (referenceFrame >= lastKey.frame) {\r\n            const value = animation._getKeyValue(lastKey.value);\r\n            valueStore.referenceValue = value.clone ? value.clone() : value;\r\n        }\r\n\r\n        // Interpolate the reference value from the animation\r\n        else {\r\n            evaluateAnimationState.key = 0;\r\n            const value = animation._interpolate(referenceFrame, evaluateAnimationState);\r\n            valueStore.referenceValue = value.clone ? value.clone() : value;\r\n        }\r\n\r\n        // Conjugate the quaternion\r\n        if (animation.dataType === Animation.ANIMATIONTYPE_QUATERNION) {\r\n            valueStore.referenceValue.normalize().conjugateInPlace();\r\n        }\r\n\r\n        // Decompose matrix and conjugate the quaternion\r\n        else if (animation.dataType === Animation.ANIMATIONTYPE_MATRIX) {\r\n            valueStore.referenceValue.decompose(valueStore.referenceScaling, valueStore.referenceQuaternion, valueStore.referencePosition);\r\n            valueStore.referenceQuaternion.normalize().conjugateInPlace();\r\n        }\r\n\r\n        let startFrame = Number.MAX_VALUE;\r\n        const clippedKeys: Nullable<IAnimationKey[]> = options.clipKeys ? [] : null;\r\n\r\n        // Subtract the reference value from all of the key values\r\n        for (let index = startIndex; index <= endIndex; index++) {\r\n            let key = animation._keys[index];\r\n\r\n            if (clippedKeys || options.cloneOriginalAnimation) {\r\n                key = {\r\n                    frame: key.frame,\r\n                    value: key.value.clone ? key.value.clone() : key.value,\r\n                    inTangent: key.inTangent,\r\n                    outTangent: key.outTangent,\r\n                    interpolation: key.interpolation,\r\n                    lockedTangent: key.lockedTangent,\r\n                };\r\n                if (clippedKeys) {\r\n                    if (startFrame === Number.MAX_VALUE) {\r\n                        startFrame = key.frame;\r\n                    }\r\n                    key.frame -= startFrame;\r\n                    clippedKeys.push(key);\r\n                }\r\n            }\r\n\r\n            // If this key was duplicated to create a frame 0 key, skip it because its value has already been updated\r\n            if (index && animation.dataType !== Animation.ANIMATIONTYPE_FLOAT && key.value === firstKey.value) {\r\n                continue;\r\n            }\r\n\r\n            switch (animation.dataType) {\r\n                case Animation.ANIMATIONTYPE_MATRIX:\r\n                    key.value.decompose(valueStore.keyScaling, valueStore.keyQuaternion, valueStore.keyPosition);\r\n                    valueStore.keyPosition.subtractInPlace(valueStore.referencePosition);\r\n                    valueStore.keyScaling.divideInPlace(valueStore.referenceScaling);\r\n                    valueStore.referenceQuaternion.multiplyToRef(valueStore.keyQuaternion, valueStore.keyQuaternion);\r\n                    Matrix.ComposeToRef(valueStore.keyScaling, valueStore.keyQuaternion, valueStore.keyPosition, key.value);\r\n                    break;\r\n\r\n                case Animation.ANIMATIONTYPE_QUATERNION:\r\n                    valueStore.referenceValue.multiplyToRef(key.value, key.value);\r\n                    break;\r\n\r\n                case Animation.ANIMATIONTYPE_VECTOR2:\r\n                case Animation.ANIMATIONTYPE_VECTOR3:\r\n                case Animation.ANIMATIONTYPE_COLOR3:\r\n                case Animation.ANIMATIONTYPE_COLOR4:\r\n                    key.value.subtractToRef(valueStore.referenceValue, key.value);\r\n                    break;\r\n\r\n                case Animation.ANIMATIONTYPE_SIZE:\r\n                    key.value.width -= valueStore.referenceValue.width;\r\n                    key.value.height -= valueStore.referenceValue.height;\r\n                    break;\r\n\r\n                default:\r\n                    key.value -= valueStore.referenceValue;\r\n            }\r\n        }\r\n\r\n        if (clippedKeys) {\r\n            animation.setKeys(clippedKeys, true);\r\n        }\r\n\r\n        return animation;\r\n    }\r\n\r\n    /**\r\n     * Transition property of an host to the target Value\r\n     * @param property The property to transition\r\n     * @param targetValue The target Value of the property\r\n     * @param host The object where the property to animate belongs\r\n     * @param scene Scene used to run the animation\r\n     * @param frameRate Framerate (in frame/s) to use\r\n     * @param transition The transition type we want to use\r\n     * @param duration The duration of the animation, in milliseconds\r\n     * @param onAnimationEnd Callback trigger at the end of the animation\r\n     * @returns Nullable animation\r\n     */\r\n    public static TransitionTo(\r\n        property: string,\r\n        targetValue: any,\r\n        host: any,\r\n        scene: Scene,\r\n        frameRate: number,\r\n        transition: Animation,\r\n        duration: number,\r\n        onAnimationEnd: Nullable<() => void> = null\r\n    ): Nullable<Animatable> {\r\n        if (duration <= 0) {\r\n            host[property] = targetValue;\r\n            if (onAnimationEnd) {\r\n                onAnimationEnd();\r\n            }\r\n            return null;\r\n        }\r\n\r\n        const endFrame: number = frameRate * (duration / 1000);\r\n\r\n        transition.setKeys([\r\n            {\r\n                frame: 0,\r\n                value: host[property].clone ? host[property].clone() : host[property],\r\n            },\r\n            {\r\n                frame: endFrame,\r\n                value: targetValue,\r\n            },\r\n        ]);\r\n\r\n        if (!host.animations) {\r\n            host.animations = [];\r\n        }\r\n\r\n        host.animations.push(transition);\r\n\r\n        const animation: Animatable = scene.beginAnimation(host, 0, endFrame, false);\r\n        animation.onAnimationEnd = onAnimationEnd;\r\n        return animation;\r\n    }\r\n\r\n    /**\r\n     * Return the array of runtime animations currently using this animation\r\n     */\r\n    public get runtimeAnimations(): RuntimeAnimation[] {\r\n        return this._runtimeAnimations;\r\n    }\r\n\r\n    /**\r\n     * Specifies if any of the runtime animations are currently running\r\n     */\r\n    public get hasRunningRuntimeAnimations(): boolean {\r\n        for (const runtimeAnimation of this._runtimeAnimations) {\r\n            if (!runtimeAnimation.isStopped()) {\r\n                return true;\r\n            }\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Initializes the animation\r\n     * @param name Name of the animation\r\n     * @param targetProperty Property to animate\r\n     * @param framePerSecond The frames per second of the animation\r\n     * @param dataType The data type of the animation\r\n     * @param loopMode The loop mode of the animation\r\n     * @param enableBlending Specifies if blending should be enabled\r\n     */\r\n    constructor(\r\n        /**Name of the animation */\r\n        public name: string,\r\n        /**Property to animate */\r\n        public targetProperty: string,\r\n        /**The frames per second of the animation */\r\n        public framePerSecond: number,\r\n        /**The data type of the animation */\r\n        public dataType: number,\r\n        /**The loop mode of the animation */\r\n        public loopMode?: number,\r\n        /**Specifies if blending should be enabled */\r\n        public enableBlending?: boolean\r\n    ) {\r\n        this.targetPropertyPath = targetProperty.split(\".\");\r\n        this.dataType = dataType;\r\n        this.loopMode = loopMode === undefined ? Animation.ANIMATIONLOOPMODE_CYCLE : loopMode;\r\n        this.uniqueId = Animation._UniqueIdGenerator++;\r\n    }\r\n\r\n    // Methods\r\n    /**\r\n     * Converts the animation to a string\r\n     * @param fullDetails support for multiple levels of logging within scene loading\r\n     * @returns String form of the animation\r\n     */\r\n    public toString(fullDetails?: boolean): string {\r\n        let ret = \"Name: \" + this.name + \", property: \" + this.targetProperty;\r\n        ret += \", datatype: \" + [\"Float\", \"Vector3\", \"Quaternion\", \"Matrix\", \"Color3\", \"Vector2\"][this.dataType];\r\n        ret += \", nKeys: \" + (this._keys ? this._keys.length : \"none\");\r\n        ret += \", nRanges: \" + (this._ranges ? Object.keys(this._ranges).length : \"none\");\r\n        if (fullDetails) {\r\n            ret += \", Ranges: {\";\r\n            let first = true;\r\n            for (const name in this._ranges) {\r\n                if (first) {\r\n                    ret += \", \";\r\n                    first = false;\r\n                }\r\n                ret += name;\r\n            }\r\n            ret += \"}\";\r\n        }\r\n        return ret;\r\n    }\r\n\r\n    /**\r\n     * Add an event to this animation\r\n     * @param event Event to add\r\n     */\r\n    public addEvent(event: AnimationEvent): void {\r\n        this._events.push(event);\r\n        this._events.sort((a, b) => a.frame - b.frame);\r\n    }\r\n\r\n    /**\r\n     * Remove all events found at the given frame\r\n     * @param frame The frame to remove events from\r\n     */\r\n    public removeEvents(frame: number): void {\r\n        for (let index = 0; index < this._events.length; index++) {\r\n            if (this._events[index].frame === frame) {\r\n                this._events.splice(index, 1);\r\n                index--;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Retrieves all the events from the animation\r\n     * @returns Events from the animation\r\n     */\r\n    public getEvents(): AnimationEvent[] {\r\n        return this._events;\r\n    }\r\n\r\n    /**\r\n     * Creates an animation range\r\n     * @param name Name of the animation range\r\n     * @param from Starting frame of the animation range\r\n     * @param to Ending frame of the animation\r\n     */\r\n    public createRange(name: string, from: number, to: number): void {\r\n        // check name not already in use; could happen for bones after serialized\r\n        if (!this._ranges[name]) {\r\n            this._ranges[name] = new AnimationRange(name, from, to);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Deletes an animation range by name\r\n     * @param name Name of the animation range to delete\r\n     * @param deleteFrames Specifies if the key frames for the range should also be deleted (true) or not (false)\r\n     */\r\n    public deleteRange(name: string, deleteFrames = true): void {\r\n        const range = this._ranges[name];\r\n        if (!range) {\r\n            return;\r\n        }\r\n        if (deleteFrames) {\r\n            const from = range.from;\r\n            const to = range.to;\r\n\r\n            // this loop MUST go high to low for multiple splices to work\r\n            for (let key = this._keys.length - 1; key >= 0; key--) {\r\n                if (this._keys[key].frame >= from && this._keys[key].frame <= to) {\r\n                    this._keys.splice(key, 1);\r\n                }\r\n            }\r\n        }\r\n        this._ranges[name] = null; // said much faster than 'delete this._range[name]'\r\n    }\r\n\r\n    /**\r\n     * Gets the animation range by name, or null if not defined\r\n     * @param name Name of the animation range\r\n     * @returns Nullable animation range\r\n     */\r\n    public getRange(name: string): Nullable<AnimationRange> {\r\n        return this._ranges[name];\r\n    }\r\n\r\n    /**\r\n     * Gets the key frames from the animation\r\n     * @returns The key frames of the animation\r\n     */\r\n    public getKeys(): Array<IAnimationKey> {\r\n        return this._keys;\r\n    }\r\n\r\n    /**\r\n     * Gets the highest frame of the animation\r\n     * @returns Highest frame of the animation\r\n     */\r\n    public getHighestFrame(): number {\r\n        let ret = 0;\r\n\r\n        for (let key = 0, nKeys = this._keys.length; key < nKeys; key++) {\r\n            if (ret < this._keys[key].frame) {\r\n                ret = this._keys[key].frame;\r\n            }\r\n        }\r\n        return ret;\r\n    }\r\n\r\n    /**\r\n     * Gets the easing function of the animation\r\n     * @returns Easing function of the animation\r\n     */\r\n    public getEasingFunction(): Nullable<IEasingFunction> {\r\n        return this._easingFunction;\r\n    }\r\n\r\n    /**\r\n     * Sets the easing function of the animation\r\n     * @param easingFunction A custom mathematical formula for animation\r\n     */\r\n    public setEasingFunction(easingFunction: Nullable<IEasingFunction>): void {\r\n        this._easingFunction = easingFunction;\r\n    }\r\n\r\n    /**\r\n     * Interpolates a scalar linearly\r\n     * @param startValue Start value of the animation curve\r\n     * @param endValue End value of the animation curve\r\n     * @param gradient Scalar amount to interpolate\r\n     * @returns Interpolated scalar value\r\n     */\r\n    public floatInterpolateFunction(startValue: number, endValue: number, gradient: number): number {\r\n        return Lerp(startValue, endValue, gradient);\r\n    }\r\n\r\n    /**\r\n     * Interpolates a scalar cubically\r\n     * @param startValue Start value of the animation curve\r\n     * @param outTangent End tangent of the animation\r\n     * @param endValue End value of the animation curve\r\n     * @param inTangent Start tangent of the animation curve\r\n     * @param gradient Scalar amount to interpolate\r\n     * @returns Interpolated scalar value\r\n     */\r\n    public floatInterpolateFunctionWithTangents(startValue: number, outTangent: number, endValue: number, inTangent: number, gradient: number): number {\r\n        return Hermite(startValue, outTangent, endValue, inTangent, gradient);\r\n    }\r\n\r\n    /**\r\n     * Interpolates a quaternion using a spherical linear interpolation\r\n     * @param startValue Start value of the animation curve\r\n     * @param endValue End value of the animation curve\r\n     * @param gradient Scalar amount to interpolate\r\n     * @returns Interpolated quaternion value\r\n     */\r\n    public quaternionInterpolateFunction(startValue: Quaternion, endValue: Quaternion, gradient: number): Quaternion {\r\n        return Quaternion.Slerp(startValue, endValue, gradient);\r\n    }\r\n\r\n    /**\r\n     * Interpolates a quaternion cubically\r\n     * @param startValue Start value of the animation curve\r\n     * @param outTangent End tangent of the animation curve\r\n     * @param endValue End value of the animation curve\r\n     * @param inTangent Start tangent of the animation curve\r\n     * @param gradient Scalar amount to interpolate\r\n     * @returns Interpolated quaternion value\r\n     */\r\n    public quaternionInterpolateFunctionWithTangents(startValue: Quaternion, outTangent: Quaternion, endValue: Quaternion, inTangent: Quaternion, gradient: number): Quaternion {\r\n        return Quaternion.Hermite(startValue, outTangent, endValue, inTangent, gradient).normalize();\r\n    }\r\n\r\n    /**\r\n     * Interpolates a Vector3 linearly\r\n     * @param startValue Start value of the animation curve\r\n     * @param endValue End value of the animation curve\r\n     * @param gradient Scalar amount to interpolate (value between 0 and 1)\r\n     * @returns Interpolated scalar value\r\n     */\r\n    public vector3InterpolateFunction(startValue: Vector3, endValue: Vector3, gradient: number): Vector3 {\r\n        return Vector3.Lerp(startValue, endValue, gradient);\r\n    }\r\n\r\n    /**\r\n     * Interpolates a Vector3 cubically\r\n     * @param startValue Start value of the animation curve\r\n     * @param outTangent End tangent of the animation\r\n     * @param endValue End value of the animation curve\r\n     * @param inTangent Start tangent of the animation curve\r\n     * @param gradient Scalar amount to interpolate (value between 0 and 1)\r\n     * @returns InterpolatedVector3 value\r\n     */\r\n    public vector3InterpolateFunctionWithTangents(startValue: Vector3, outTangent: Vector3, endValue: Vector3, inTangent: Vector3, gradient: number): Vector3 {\r\n        return Vector3.Hermite(startValue, outTangent, endValue, inTangent, gradient);\r\n    }\r\n\r\n    /**\r\n     * Interpolates a Vector2 linearly\r\n     * @param startValue Start value of the animation curve\r\n     * @param endValue End value of the animation curve\r\n     * @param gradient Scalar amount to interpolate (value between 0 and 1)\r\n     * @returns Interpolated Vector2 value\r\n     */\r\n    public vector2InterpolateFunction(startValue: Vector2, endValue: Vector2, gradient: number): Vector2 {\r\n        return Vector2.Lerp(startValue, endValue, gradient);\r\n    }\r\n\r\n    /**\r\n     * Interpolates a Vector2 cubically\r\n     * @param startValue Start value of the animation curve\r\n     * @param outTangent End tangent of the animation\r\n     * @param endValue End value of the animation curve\r\n     * @param inTangent Start tangent of the animation curve\r\n     * @param gradient Scalar amount to interpolate (value between 0 and 1)\r\n     * @returns Interpolated Vector2 value\r\n     */\r\n    public vector2InterpolateFunctionWithTangents(startValue: Vector2, outTangent: Vector2, endValue: Vector2, inTangent: Vector2, gradient: number): Vector2 {\r\n        return Vector2.Hermite(startValue, outTangent, endValue, inTangent, gradient);\r\n    }\r\n\r\n    /**\r\n     * Interpolates a size linearly\r\n     * @param startValue Start value of the animation curve\r\n     * @param endValue End value of the animation curve\r\n     * @param gradient Scalar amount to interpolate\r\n     * @returns Interpolated Size value\r\n     */\r\n    public sizeInterpolateFunction(startValue: Size, endValue: Size, gradient: number): Size {\r\n        return Size.Lerp(startValue, endValue, gradient);\r\n    }\r\n\r\n    /**\r\n     * Interpolates a Color3 linearly\r\n     * @param startValue Start value of the animation curve\r\n     * @param endValue End value of the animation curve\r\n     * @param gradient Scalar amount to interpolate\r\n     * @returns Interpolated Color3 value\r\n     */\r\n    public color3InterpolateFunction(startValue: Color3, endValue: Color3, gradient: number): Color3 {\r\n        return Color3.Lerp(startValue, endValue, gradient);\r\n    }\r\n\r\n    /**\r\n     * Interpolates a Color3 cubically\r\n     * @param startValue Start value of the animation curve\r\n     * @param outTangent End tangent of the animation\r\n     * @param endValue End value of the animation curve\r\n     * @param inTangent Start tangent of the animation curve\r\n     * @param gradient Scalar amount to interpolate\r\n     * @returns interpolated value\r\n     */\r\n    public color3InterpolateFunctionWithTangents(startValue: Color3, outTangent: Color3, endValue: Color3, inTangent: Color3, gradient: number): Color3 {\r\n        return Color3.Hermite(startValue, outTangent, endValue, inTangent, gradient);\r\n    }\r\n\r\n    /**\r\n     * Interpolates a Color4 linearly\r\n     * @param startValue Start value of the animation curve\r\n     * @param endValue End value of the animation curve\r\n     * @param gradient Scalar amount to interpolate\r\n     * @returns Interpolated Color3 value\r\n     */\r\n    public color4InterpolateFunction(startValue: Color4, endValue: Color4, gradient: number): Color4 {\r\n        return Color4.Lerp(startValue, endValue, gradient);\r\n    }\r\n\r\n    /**\r\n     * Interpolates a Color4 cubically\r\n     * @param startValue Start value of the animation curve\r\n     * @param outTangent End tangent of the animation\r\n     * @param endValue End value of the animation curve\r\n     * @param inTangent Start tangent of the animation curve\r\n     * @param gradient Scalar amount to interpolate\r\n     * @returns interpolated value\r\n     */\r\n    public color4InterpolateFunctionWithTangents(startValue: Color4, outTangent: Color4, endValue: Color4, inTangent: Color4, gradient: number): Color4 {\r\n        return Color4.Hermite(startValue, outTangent, endValue, inTangent, gradient);\r\n    }\r\n\r\n    /**\r\n     * @internal Internal use only\r\n     */\r\n    public _getKeyValue(value: any): any {\r\n        if (typeof value === \"function\") {\r\n            return value();\r\n        }\r\n\r\n        return value;\r\n    }\r\n\r\n    /**\r\n     * Evaluate the animation value at a given frame\r\n     * @param currentFrame defines the frame where we want to evaluate the animation\r\n     * @returns the animation value\r\n     */\r\n    public evaluate(currentFrame: number) {\r\n        evaluateAnimationState.key = 0;\r\n        return this._interpolate(currentFrame, evaluateAnimationState);\r\n    }\r\n\r\n    /**\r\n     * @internal Internal use only\r\n     */\r\n    public _interpolate(currentFrame: number, state: _IAnimationState, searchClosestKeyOnly = false): any {\r\n        if (state.loopMode === Animation.ANIMATIONLOOPMODE_CONSTANT && state.repeatCount > 0) {\r\n            return state.highLimitValue.clone ? state.highLimitValue.clone() : state.highLimitValue;\r\n        }\r\n\r\n        const keys = this._keys;\r\n        const keysLength = keys.length;\r\n\r\n        let key = state.key;\r\n\r\n        while (key >= 0 && currentFrame < keys[key].frame) {\r\n            --key;\r\n        }\r\n\r\n        while (key + 1 <= keysLength - 1 && currentFrame >= keys[key + 1].frame) {\r\n            ++key;\r\n        }\r\n\r\n        state.key = key;\r\n\r\n        if (key < 0) {\r\n            return searchClosestKeyOnly ? undefined : this._getKeyValue(keys[0].value);\r\n        } else if (key + 1 > keysLength - 1) {\r\n            return searchClosestKeyOnly ? undefined : this._getKeyValue(keys[keysLength - 1].value);\r\n        }\r\n\r\n        const startKey = keys[key];\r\n        const endKey = keys[key + 1];\r\n\r\n        if (searchClosestKeyOnly && (currentFrame === startKey.frame || currentFrame === endKey.frame)) {\r\n            return undefined;\r\n        }\r\n\r\n        const startValue = this._getKeyValue(startKey.value);\r\n        const endValue = this._getKeyValue(endKey.value);\r\n        if (startKey.interpolation === AnimationKeyInterpolation.STEP) {\r\n            if (endKey.frame > currentFrame) {\r\n                return startValue;\r\n            } else {\r\n                return endValue;\r\n            }\r\n        }\r\n\r\n        const useTangent = startKey.outTangent !== undefined && endKey.inTangent !== undefined;\r\n        const frameDelta = endKey.frame - startKey.frame;\r\n\r\n        // gradient : percent of currentFrame between the frame inf and the frame sup\r\n        let gradient = (currentFrame - startKey.frame) / frameDelta;\r\n\r\n        // check for easingFunction and correction of gradient\r\n        const easingFunction = startKey.easingFunction || this.getEasingFunction();\r\n        if (easingFunction !== null) {\r\n            gradient = easingFunction.ease(gradient);\r\n        }\r\n\r\n        switch (this.dataType) {\r\n            // Float\r\n            case Animation.ANIMATIONTYPE_FLOAT: {\r\n                const floatValue = useTangent\r\n                    ? this.floatInterpolateFunctionWithTangents(startValue, startKey.outTangent * frameDelta, endValue, endKey.inTangent * frameDelta, gradient)\r\n                    : this.floatInterpolateFunction(startValue, endValue, gradient);\r\n                switch (state.loopMode) {\r\n                    case Animation.ANIMATIONLOOPMODE_CYCLE:\r\n                    case Animation.ANIMATIONLOOPMODE_CONSTANT:\r\n                    case Animation.ANIMATIONLOOPMODE_YOYO:\r\n                        return floatValue;\r\n                    case Animation.ANIMATIONLOOPMODE_RELATIVE:\r\n                    case Animation.ANIMATIONLOOPMODE_RELATIVE_FROM_CURRENT:\r\n                        return (state.offsetValue ?? 0) * state.repeatCount + floatValue;\r\n                }\r\n                break;\r\n            }\r\n            // Quaternion\r\n            case Animation.ANIMATIONTYPE_QUATERNION: {\r\n                const quatValue = useTangent\r\n                    ? this.quaternionInterpolateFunctionWithTangents(startValue, startKey.outTangent.scale(frameDelta), endValue, endKey.inTangent.scale(frameDelta), gradient)\r\n                    : this.quaternionInterpolateFunction(startValue, endValue, gradient);\r\n                switch (state.loopMode) {\r\n                    case Animation.ANIMATIONLOOPMODE_CYCLE:\r\n                    case Animation.ANIMATIONLOOPMODE_CONSTANT:\r\n                    case Animation.ANIMATIONLOOPMODE_YOYO:\r\n                        return quatValue;\r\n                    case Animation.ANIMATIONLOOPMODE_RELATIVE:\r\n                    case Animation.ANIMATIONLOOPMODE_RELATIVE_FROM_CURRENT:\r\n                        return quatValue.addInPlace((state.offsetValue || _staticOffsetValueQuaternion).scale(state.repeatCount));\r\n                }\r\n\r\n                return quatValue;\r\n            }\r\n            // Vector3\r\n            case Animation.ANIMATIONTYPE_VECTOR3: {\r\n                const vec3Value = useTangent\r\n                    ? this.vector3InterpolateFunctionWithTangents(startValue, startKey.outTangent.scale(frameDelta), endValue, endKey.inTangent.scale(frameDelta), gradient)\r\n                    : this.vector3InterpolateFunction(startValue, endValue, gradient);\r\n                switch (state.loopMode) {\r\n                    case Animation.ANIMATIONLOOPMODE_CYCLE:\r\n                    case Animation.ANIMATIONLOOPMODE_CONSTANT:\r\n                    case Animation.ANIMATIONLOOPMODE_YOYO:\r\n                        return vec3Value;\r\n                    case Animation.ANIMATIONLOOPMODE_RELATIVE:\r\n                    case Animation.ANIMATIONLOOPMODE_RELATIVE_FROM_CURRENT:\r\n                        return vec3Value.add((state.offsetValue || _staticOffsetValueVector3).scale(state.repeatCount));\r\n                }\r\n                break;\r\n            }\r\n            // Vector2\r\n            case Animation.ANIMATIONTYPE_VECTOR2: {\r\n                const vec2Value = useTangent\r\n                    ? this.vector2InterpolateFunctionWithTangents(startValue, startKey.outTangent.scale(frameDelta), endValue, endKey.inTangent.scale(frameDelta), gradient)\r\n                    : this.vector2InterpolateFunction(startValue, endValue, gradient);\r\n                switch (state.loopMode) {\r\n                    case Animation.ANIMATIONLOOPMODE_CYCLE:\r\n                    case Animation.ANIMATIONLOOPMODE_CONSTANT:\r\n                    case Animation.ANIMATIONLOOPMODE_YOYO:\r\n                        return vec2Value;\r\n                    case Animation.ANIMATIONLOOPMODE_RELATIVE:\r\n                    case Animation.ANIMATIONLOOPMODE_RELATIVE_FROM_CURRENT:\r\n                        return vec2Value.add((state.offsetValue || _staticOffsetValueVector2).scale(state.repeatCount));\r\n                }\r\n                break;\r\n            }\r\n            // Size\r\n            case Animation.ANIMATIONTYPE_SIZE: {\r\n                switch (state.loopMode) {\r\n                    case Animation.ANIMATIONLOOPMODE_CYCLE:\r\n                    case Animation.ANIMATIONLOOPMODE_CONSTANT:\r\n                    case Animation.ANIMATIONLOOPMODE_YOYO:\r\n                        return this.sizeInterpolateFunction(startValue, endValue, gradient);\r\n                    case Animation.ANIMATIONLOOPMODE_RELATIVE:\r\n                    case Animation.ANIMATIONLOOPMODE_RELATIVE_FROM_CURRENT:\r\n                        return this.sizeInterpolateFunction(startValue, endValue, gradient).add((state.offsetValue || _staticOffsetValueSize).scale(state.repeatCount));\r\n                }\r\n                break;\r\n            }\r\n            // Color3\r\n            case Animation.ANIMATIONTYPE_COLOR3: {\r\n                const color3Value = useTangent\r\n                    ? this.color3InterpolateFunctionWithTangents(startValue, startKey.outTangent.scale(frameDelta), endValue, endKey.inTangent.scale(frameDelta), gradient)\r\n                    : this.color3InterpolateFunction(startValue, endValue, gradient);\r\n                switch (state.loopMode) {\r\n                    case Animation.ANIMATIONLOOPMODE_CYCLE:\r\n                    case Animation.ANIMATIONLOOPMODE_CONSTANT:\r\n                    case Animation.ANIMATIONLOOPMODE_YOYO:\r\n                        return color3Value;\r\n                    case Animation.ANIMATIONLOOPMODE_RELATIVE:\r\n                    case Animation.ANIMATIONLOOPMODE_RELATIVE_FROM_CURRENT:\r\n                        return color3Value.add((state.offsetValue || _staticOffsetValueColor3).scale(state.repeatCount));\r\n                }\r\n                break;\r\n            }\r\n            // Color4\r\n            case Animation.ANIMATIONTYPE_COLOR4: {\r\n                const color4Value = useTangent\r\n                    ? this.color4InterpolateFunctionWithTangents(startValue, startKey.outTangent.scale(frameDelta), endValue, endKey.inTangent.scale(frameDelta), gradient)\r\n                    : this.color4InterpolateFunction(startValue, endValue, gradient);\r\n                switch (state.loopMode) {\r\n                    case Animation.ANIMATIONLOOPMODE_CYCLE:\r\n                    case Animation.ANIMATIONLOOPMODE_CONSTANT:\r\n                    case Animation.ANIMATIONLOOPMODE_YOYO:\r\n                        return color4Value;\r\n                    case Animation.ANIMATIONLOOPMODE_RELATIVE:\r\n                    case Animation.ANIMATIONLOOPMODE_RELATIVE_FROM_CURRENT:\r\n                        return color4Value.add((state.offsetValue || _staticOffsetValueColor4).scale(state.repeatCount));\r\n                }\r\n                break;\r\n            }\r\n            // Matrix\r\n            case Animation.ANIMATIONTYPE_MATRIX: {\r\n                switch (state.loopMode) {\r\n                    case Animation.ANIMATIONLOOPMODE_CYCLE:\r\n                    case Animation.ANIMATIONLOOPMODE_CONSTANT:\r\n                    case Animation.ANIMATIONLOOPMODE_YOYO: {\r\n                        if (Animation.AllowMatricesInterpolation) {\r\n                            return this.matrixInterpolateFunction(startValue, endValue, gradient, state.workValue);\r\n                        }\r\n                        return startValue;\r\n                    }\r\n                    case Animation.ANIMATIONLOOPMODE_RELATIVE:\r\n                    case Animation.ANIMATIONLOOPMODE_RELATIVE_FROM_CURRENT: {\r\n                        return startValue;\r\n                    }\r\n                }\r\n                break;\r\n            }\r\n        }\r\n\r\n        return 0;\r\n    }\r\n\r\n    /**\r\n     * Defines the function to use to interpolate matrices\r\n     * @param startValue defines the start matrix\r\n     * @param endValue defines the end matrix\r\n     * @param gradient defines the gradient between both matrices\r\n     * @param result defines an optional target matrix where to store the interpolation\r\n     * @returns the interpolated matrix\r\n     */\r\n    public matrixInterpolateFunction(startValue: Matrix, endValue: Matrix, gradient: number, result?: Matrix): Matrix {\r\n        if (Animation.AllowMatrixDecomposeForInterpolation) {\r\n            if (result) {\r\n                Matrix.DecomposeLerpToRef(startValue, endValue, gradient, result);\r\n                return result;\r\n            }\r\n            return Matrix.DecomposeLerp(startValue, endValue, gradient);\r\n        }\r\n\r\n        if (result) {\r\n            Matrix.LerpToRef(startValue, endValue, gradient, result);\r\n            return result;\r\n        }\r\n        return Matrix.Lerp(startValue, endValue, gradient);\r\n    }\r\n\r\n    /**\r\n     * Makes a copy of the animation\r\n     * @returns Cloned animation\r\n     */\r\n    public clone(): Animation {\r\n        const clone = new Animation(this.name, this.targetPropertyPath.join(\".\"), this.framePerSecond, this.dataType, this.loopMode);\r\n\r\n        clone.enableBlending = this.enableBlending;\r\n        clone.blendingSpeed = this.blendingSpeed;\r\n\r\n        if (this._keys) {\r\n            clone.setKeys(this._keys);\r\n        }\r\n\r\n        if (this._ranges) {\r\n            clone._ranges = {};\r\n            for (const name in this._ranges) {\r\n                const range = this._ranges[name];\r\n                if (!range) {\r\n                    continue;\r\n                }\r\n                clone._ranges[name] = range.clone();\r\n            }\r\n        }\r\n\r\n        return clone;\r\n    }\r\n\r\n    /**\r\n     * Sets the key frames of the animation\r\n     * @param values The animation key frames to set\r\n     * @param dontClone Whether to clone the keys or not (default is false, so the array of keys is cloned)\r\n     */\r\n    public setKeys(values: Array<IAnimationKey>, dontClone = false): void {\r\n        this._keys = !dontClone ? values.slice(0) : values;\r\n    }\r\n\r\n    /**\r\n     * Creates a key for the frame passed as a parameter and adds it to the animation IF a key doesn't already exist for that frame\r\n     * @param frame Frame number\r\n     * @returns The key index if the key was added or the index of the pre existing key if the frame passed as parameter already has a corresponding key\r\n     */\r\n    public createKeyForFrame(frame: number) {\r\n        // Find the key corresponding to frame\r\n        evaluateAnimationState.key = 0;\r\n        const value = this._interpolate(frame, evaluateAnimationState, true);\r\n\r\n        if (!value) {\r\n            // A key corresponding to this frame already exists\r\n            return this._keys[evaluateAnimationState.key].frame === frame ? evaluateAnimationState.key : evaluateAnimationState.key + 1;\r\n        }\r\n\r\n        // The frame is between two keys, so create a new key\r\n        const newKey: IAnimationKey = {\r\n            frame,\r\n            value: value.clone ? value.clone() : value,\r\n        };\r\n\r\n        this._keys.splice(evaluateAnimationState.key + 1, 0, newKey);\r\n\r\n        return evaluateAnimationState.key + 1;\r\n    }\r\n\r\n    /**\r\n     * Serializes the animation to an object\r\n     * @returns Serialized object\r\n     */\r\n    public serialize(): any {\r\n        const serializationObject: any = {};\r\n\r\n        serializationObject.name = this.name;\r\n        serializationObject.property = this.targetProperty;\r\n        serializationObject.framePerSecond = this.framePerSecond;\r\n        serializationObject.dataType = this.dataType;\r\n        serializationObject.loopBehavior = this.loopMode;\r\n        serializationObject.enableBlending = this.enableBlending;\r\n        serializationObject.blendingSpeed = this.blendingSpeed;\r\n\r\n        const dataType = this.dataType;\r\n        serializationObject.keys = [];\r\n        const keys = this.getKeys();\r\n        for (let index = 0; index < keys.length; index++) {\r\n            const animationKey = keys[index];\r\n\r\n            const key: any = {};\r\n            key.frame = animationKey.frame;\r\n\r\n            switch (dataType) {\r\n                case Animation.ANIMATIONTYPE_FLOAT:\r\n                    key.values = [animationKey.value];\r\n                    if (animationKey.inTangent !== undefined) {\r\n                        key.values.push(animationKey.inTangent);\r\n                    }\r\n                    if (animationKey.outTangent !== undefined) {\r\n                        if (animationKey.inTangent === undefined) {\r\n                            key.values.push(undefined);\r\n                        }\r\n                        key.values.push(animationKey.outTangent);\r\n                    }\r\n                    if (animationKey.interpolation !== undefined) {\r\n                        if (animationKey.inTangent === undefined) {\r\n                            key.values.push(undefined);\r\n                        }\r\n                        if (animationKey.outTangent === undefined) {\r\n                            key.values.push(undefined);\r\n                        }\r\n                        key.values.push(animationKey.interpolation);\r\n                    }\r\n                    break;\r\n                case Animation.ANIMATIONTYPE_QUATERNION:\r\n                case Animation.ANIMATIONTYPE_MATRIX:\r\n                case Animation.ANIMATIONTYPE_VECTOR3:\r\n                case Animation.ANIMATIONTYPE_COLOR3:\r\n                case Animation.ANIMATIONTYPE_COLOR4:\r\n                    key.values = animationKey.value.asArray();\r\n                    if (animationKey.inTangent != undefined) {\r\n                        key.values.push(animationKey.inTangent.asArray());\r\n                    }\r\n                    if (animationKey.outTangent != undefined) {\r\n                        if (animationKey.inTangent === undefined) {\r\n                            key.values.push(undefined);\r\n                        }\r\n                        key.values.push(animationKey.outTangent.asArray());\r\n                    }\r\n                    if (animationKey.interpolation !== undefined) {\r\n                        if (animationKey.inTangent === undefined) {\r\n                            key.values.push(undefined);\r\n                        }\r\n                        if (animationKey.outTangent === undefined) {\r\n                            key.values.push(undefined);\r\n                        }\r\n                        key.values.push(animationKey.interpolation);\r\n                    }\r\n                    break;\r\n            }\r\n\r\n            serializationObject.keys.push(key);\r\n        }\r\n\r\n        serializationObject.ranges = [];\r\n        for (const name in this._ranges) {\r\n            const source = this._ranges[name];\r\n\r\n            if (!source) {\r\n                continue;\r\n            }\r\n            const range: any = {};\r\n            range.name = name;\r\n            range.from = source.from;\r\n            range.to = source.to;\r\n            serializationObject.ranges.push(range);\r\n        }\r\n\r\n        return serializationObject;\r\n    }\r\n\r\n    // Statics\r\n    /**\r\n     * Float animation type\r\n     */\r\n    public static readonly ANIMATIONTYPE_FLOAT = 0;\r\n    /**\r\n     * Vector3 animation type\r\n     */\r\n    public static readonly ANIMATIONTYPE_VECTOR3 = 1;\r\n    /**\r\n     * Quaternion animation type\r\n     */\r\n    public static readonly ANIMATIONTYPE_QUATERNION = 2;\r\n    /**\r\n     * Matrix animation type\r\n     */\r\n    public static readonly ANIMATIONTYPE_MATRIX = 3;\r\n    /**\r\n     * Color3 animation type\r\n     */\r\n    public static readonly ANIMATIONTYPE_COLOR3 = 4;\r\n    /**\r\n     * Color3 animation type\r\n     */\r\n    public static readonly ANIMATIONTYPE_COLOR4 = 7;\r\n    /**\r\n     * Vector2 animation type\r\n     */\r\n    public static readonly ANIMATIONTYPE_VECTOR2 = 5;\r\n    /**\r\n     * Size animation type\r\n     */\r\n    public static readonly ANIMATIONTYPE_SIZE = 6;\r\n    /**\r\n     * Relative Loop Mode\r\n     */\r\n    public static readonly ANIMATIONLOOPMODE_RELATIVE = 0;\r\n    /**\r\n     * Cycle Loop Mode\r\n     */\r\n    public static readonly ANIMATIONLOOPMODE_CYCLE = 1;\r\n    /**\r\n     * Constant Loop Mode\r\n     */\r\n    public static readonly ANIMATIONLOOPMODE_CONSTANT = 2;\r\n    /**\r\n     * Yoyo Loop Mode\r\n     */\r\n    public static readonly ANIMATIONLOOPMODE_YOYO = 4;\r\n    /**\r\n     * Relative Loop Mode (add to current value of animated object, unlike ANIMATIONLOOPMODE_RELATIVE)\r\n     */\r\n    public static readonly ANIMATIONLOOPMODE_RELATIVE_FROM_CURRENT = 5;\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public static _UniversalLerp(left: any, right: any, amount: number): any {\r\n        const constructor = left.constructor;\r\n        if (constructor.Lerp) {\r\n            // Lerp supported\r\n            return constructor.Lerp(left, right, amount);\r\n        } else if (constructor.Slerp) {\r\n            // Slerp supported\r\n            return constructor.Slerp(left, right, amount);\r\n        } else if (left.toFixed) {\r\n            // Number\r\n            return left * (1.0 - amount) + amount * right;\r\n        } else {\r\n            // Blending not supported\r\n            return right;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Parses an animation object and creates an animation\r\n     * @param parsedAnimation Parsed animation object\r\n     * @returns Animation object\r\n     */\r\n    public static Parse(parsedAnimation: any): Animation {\r\n        const animation = new Animation(parsedAnimation.name, parsedAnimation.property, parsedAnimation.framePerSecond, parsedAnimation.dataType, parsedAnimation.loopBehavior);\r\n\r\n        const dataType = parsedAnimation.dataType;\r\n        const keys: Array<IAnimationKey> = [];\r\n        let data;\r\n        let index: number;\r\n\r\n        if (parsedAnimation.enableBlending) {\r\n            animation.enableBlending = parsedAnimation.enableBlending;\r\n        }\r\n\r\n        if (parsedAnimation.blendingSpeed) {\r\n            animation.blendingSpeed = parsedAnimation.blendingSpeed;\r\n        }\r\n\r\n        for (index = 0; index < parsedAnimation.keys.length; index++) {\r\n            const key = parsedAnimation.keys[index];\r\n            let inTangent: any = undefined;\r\n            let outTangent: any = undefined;\r\n            let interpolation: any = undefined;\r\n\r\n            switch (dataType) {\r\n                case Animation.ANIMATIONTYPE_FLOAT:\r\n                    data = key.values[0];\r\n                    if (key.values.length >= 2) {\r\n                        inTangent = key.values[1];\r\n                    }\r\n                    if (key.values.length >= 3) {\r\n                        outTangent = key.values[2];\r\n                    }\r\n                    if (key.values.length >= 4) {\r\n                        interpolation = key.values[3];\r\n                    }\r\n                    break;\r\n                case Animation.ANIMATIONTYPE_QUATERNION:\r\n                    data = Quaternion.FromArray(key.values);\r\n                    if (key.values.length >= 8) {\r\n                        const _inTangent = Quaternion.FromArray(key.values.slice(4, 8));\r\n                        if (!_inTangent.equals(Quaternion.Zero())) {\r\n                            inTangent = _inTangent;\r\n                        }\r\n                    }\r\n                    if (key.values.length >= 12) {\r\n                        const _outTangent = Quaternion.FromArray(key.values.slice(8, 12));\r\n                        if (!_outTangent.equals(Quaternion.Zero())) {\r\n                            outTangent = _outTangent;\r\n                        }\r\n                    }\r\n                    if (key.values.length >= 13) {\r\n                        interpolation = key.values[12];\r\n                    }\r\n                    break;\r\n                case Animation.ANIMATIONTYPE_MATRIX:\r\n                    data = Matrix.FromArray(key.values);\r\n                    if (key.values.length >= 17) {\r\n                        interpolation = key.values[16];\r\n                    }\r\n                    break;\r\n                case Animation.ANIMATIONTYPE_COLOR3:\r\n                    data = Color3.FromArray(key.values);\r\n                    if (key.values[3]) {\r\n                        inTangent = Color3.FromArray(key.values[3]);\r\n                    }\r\n                    if (key.values[4]) {\r\n                        outTangent = Color3.FromArray(key.values[4]);\r\n                    }\r\n                    if (key.values[5]) {\r\n                        interpolation = key.values[5];\r\n                    }\r\n                    break;\r\n                case Animation.ANIMATIONTYPE_COLOR4:\r\n                    data = Color4.FromArray(key.values);\r\n                    if (key.values[4]) {\r\n                        inTangent = Color4.FromArray(key.values[4]);\r\n                    }\r\n                    if (key.values[5]) {\r\n                        outTangent = Color4.FromArray(key.values[5]);\r\n                    }\r\n                    if (key.values[6]) {\r\n                        interpolation = Color4.FromArray(key.values[6]);\r\n                    }\r\n                    break;\r\n                case Animation.ANIMATIONTYPE_VECTOR3:\r\n                default:\r\n                    data = Vector3.FromArray(key.values);\r\n                    if (key.values[3]) {\r\n                        inTangent = Vector3.FromArray(key.values[3]);\r\n                    }\r\n                    if (key.values[4]) {\r\n                        outTangent = Vector3.FromArray(key.values[4]);\r\n                    }\r\n                    if (key.values[5]) {\r\n                        interpolation = key.values[5];\r\n                    }\r\n                    break;\r\n            }\r\n\r\n            const keyData: any = {};\r\n            keyData.frame = key.frame;\r\n            keyData.value = data;\r\n\r\n            if (inTangent != undefined) {\r\n                keyData.inTangent = inTangent;\r\n            }\r\n            if (outTangent != undefined) {\r\n                keyData.outTangent = outTangent;\r\n            }\r\n            if (interpolation != undefined) {\r\n                keyData.interpolation = interpolation;\r\n            }\r\n            keys.push(keyData);\r\n        }\r\n\r\n        animation.setKeys(keys);\r\n\r\n        if (parsedAnimation.ranges) {\r\n            for (index = 0; index < parsedAnimation.ranges.length; index++) {\r\n                data = parsedAnimation.ranges[index];\r\n                animation.createRange(data.name, data.from, data.to);\r\n            }\r\n        }\r\n\r\n        return animation;\r\n    }\r\n\r\n    /**\r\n     * Appends the serialized animations from the source animations\r\n     * @param source Source containing the animations\r\n     * @param destination Target to store the animations\r\n     */\r\n    public static AppendSerializedAnimations(source: IAnimatable, destination: any): void {\r\n        SerializationHelper.AppendSerializedAnimations(source, destination);\r\n    }\r\n\r\n    /**\r\n     * Creates a new animation or an array of animations from a snippet saved in a remote file\r\n     * @param name defines the name of the animation to create (can be null or empty to use the one from the json data)\r\n     * @param url defines the url to load from\r\n     * @returns a promise that will resolve to the new animation or an array of animations\r\n     */\r\n    public static ParseFromFileAsync(name: Nullable<string>, url: string): Promise<Animation | Array<Animation>> {\r\n        return new Promise((resolve, reject) => {\r\n            const request = new WebRequest();\r\n            request.addEventListener(\"readystatechange\", () => {\r\n                if (request.readyState == 4) {\r\n                    if (request.status == 200) {\r\n                        let serializationObject = JSON.parse(request.responseText);\r\n                        if (serializationObject.animations) {\r\n                            serializationObject = serializationObject.animations;\r\n                        }\r\n\r\n                        if (serializationObject.length) {\r\n                            const output: Animation[] = [];\r\n                            for (const serializedAnimation of serializationObject) {\r\n                                output.push(this.Parse(serializedAnimation));\r\n                            }\r\n\r\n                            resolve(output);\r\n                        } else {\r\n                            const output = this.Parse(serializationObject);\r\n\r\n                            if (name) {\r\n                                output.name = name;\r\n                            }\r\n\r\n                            resolve(output);\r\n                        }\r\n                    } else {\r\n                        reject(\"Unable to load the animation\");\r\n                    }\r\n                }\r\n            });\r\n\r\n            request.open(\"GET\", url);\r\n            request.send();\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Creates an animation or an array of animations from a snippet saved by the Inspector\r\n     * @param snippetId defines the snippet to load\r\n     * @returns a promise that will resolve to the new animation or a new array of animations\r\n     */\r\n    public static ParseFromSnippetAsync(snippetId: string): Promise<Animation | Array<Animation>> {\r\n        return new Promise((resolve, reject) => {\r\n            const request = new WebRequest();\r\n            request.addEventListener(\"readystatechange\", () => {\r\n                if (request.readyState == 4) {\r\n                    if (request.status == 200) {\r\n                        const snippet = JSON.parse(JSON.parse(request.responseText).jsonPayload);\r\n\r\n                        if (snippet.animations) {\r\n                            const serializationObject = JSON.parse(snippet.animations);\r\n                            const outputs: Animation[] = [];\r\n                            for (const serializedAnimation of serializationObject.animations) {\r\n                                const output = this.Parse(serializedAnimation);\r\n                                output.snippetId = snippetId;\r\n                                outputs.push(output);\r\n                            }\r\n\r\n                            resolve(outputs);\r\n                        } else {\r\n                            const serializationObject = JSON.parse(snippet.animation);\r\n                            const output = this.Parse(serializationObject);\r\n\r\n                            output.snippetId = snippetId;\r\n\r\n                            resolve(output);\r\n                        }\r\n                    } else {\r\n                        reject(\"Unable to load the snippet \" + snippetId);\r\n                    }\r\n                }\r\n            });\r\n\r\n            request.open(\"GET\", this.SnippetUrl + \"/\" + snippetId.replace(/#/g, \"/\"));\r\n            request.send();\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Creates an animation or an array of animations from a snippet saved by the Inspector\r\n     * @deprecated Please use ParseFromSnippetAsync instead\r\n     * @param snippetId defines the snippet to load\r\n     * @returns a promise that will resolve to the new animation or a new array of animations\r\n     */\r\n    public static CreateFromSnippetAsync = Animation.ParseFromSnippetAsync;\r\n}\r\n\r\nRegisterClass(\"BABYLON.Animation\", Animation);\r\nNode._AnimationRangeFactory = (name: string, from: number, to: number) => new AnimationRange(name, from, to);\r\n", "import type { Skeleton } from \"./skeleton\";\r\nimport { Vector3, Quaternion, Matrix, TmpVectors } from \"../Maths/math.vector\";\r\nimport { BuildArray } from \"../Misc/arrayTools\";\r\nimport type { Nullable } from \"../types\";\r\nimport type { TransformNode } from \"../Meshes/transformNode\";\r\nimport { Node } from \"../node\";\r\nimport { Space } from \"../Maths/math.axis\";\r\n\r\nimport type { Animation } from \"../Animations/animation\";\r\nimport type { AnimationPropertiesOverride } from \"../Animations/animationPropertiesOverride\";\r\n\r\n/**\r\n * Class used to store bone information\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/bonesSkeletons\r\n */\r\nexport class Bone extends Node {\r\n    private static _TmpVecs: Vector3[] = BuildArray(2, Vector3.Zero);\r\n    private static _TmpQuat = Quaternion.Identity();\r\n    private static _TmpMats: Matrix[] = BuildArray(5, Matrix.Identity);\r\n\r\n    /**\r\n     * Gets the list of child bones\r\n     */\r\n    public children: Bone[] = [];\r\n\r\n    /** Gets the animations associated with this bone */\r\n    public override animations: Animation[] = [];\r\n\r\n    /**\r\n     * Gets or sets bone length\r\n     */\r\n    public length: number;\r\n\r\n    /**\r\n     * @internal Internal only\r\n     * Set this value to map this bone to a different index in the transform matrices\r\n     * Set this value to -1 to exclude the bone from the transform matrices\r\n     */\r\n    public _index: Nullable<number> = null;\r\n\r\n    private _skeleton: Skeleton;\r\n    private _localMatrix: Matrix; // transformation of the bone, in local space\r\n    private _absoluteMatrix: Matrix; // transformation of the bone, in world space (relative to the skeleton root)\r\n    private _bindMatrix: Matrix; // the bind matrix, in local space\r\n    private _absoluteBindMatrix: Matrix; // the bind matrix, in world space (relative to the skeleton root)\r\n    private _absoluteInverseBindMatrix: Matrix; // the inverse of the bind matrix, in world space (relative to the skeleton root)\r\n    private _finalMatrix: Matrix; // the final matrix used to transform vertices of the mesh according to the bone, in world space (relative to the skeleton root). It is the multiplication of _absoluteInverseBindMatrix with _absoluteMatrix.\r\n    private _restMatrix: Matrix; // a matrix for the exclusive use of the end user (not used internally by the framework), in local space\r\n    private _scalingDeterminant = 1;\r\n\r\n    private _localScaling: Vector3;\r\n    private _localRotation: Quaternion;\r\n    private _localPosition: Vector3;\r\n    private _needToDecompose = true;\r\n    private _needToCompose = false;\r\n\r\n    /** @internal */\r\n    public _linkedTransformNode: Nullable<TransformNode> = null;\r\n\r\n    /** @internal */\r\n    public _waitingTransformNodeId: Nullable<string> = null;\r\n\r\n    /** @internal */\r\n    get _matrix(): Matrix {\r\n        this._compose();\r\n        return this._localMatrix;\r\n    }\r\n\r\n    /** @internal */\r\n    set _matrix(value: Matrix) {\r\n        // skip if the matrices are the same\r\n        if (value.updateFlag === this._localMatrix.updateFlag && !this._needToCompose) {\r\n            return;\r\n        }\r\n\r\n        this._needToCompose = false; // in case there was a pending compose\r\n\r\n        this._localMatrix.copyFrom(value);\r\n        this._markAsDirtyAndDecompose();\r\n    }\r\n\r\n    /**\r\n     * Create a new bone\r\n     * @param name defines the bone name\r\n     * @param skeleton defines the parent skeleton\r\n     * @param parentBone defines the parent (can be null if the bone is the root)\r\n     * @param localMatrix defines the local matrix (default: identity)\r\n     * @param restMatrix defines the rest matrix (default: localMatrix)\r\n     * @param bindMatrix defines the bind matrix (default: localMatrix)\r\n     * @param index defines index of the bone in the hierarchy (default: null)\r\n     */\r\n    constructor(\r\n        /**\r\n         * defines the bone name\r\n         */\r\n        public override name: string,\r\n        skeleton: Skeleton,\r\n        parentBone: Nullable<Bone> = null,\r\n        localMatrix: Nullable<Matrix> = null,\r\n        restMatrix: Nullable<Matrix> = null,\r\n        bindMatrix: Nullable<Matrix> = null,\r\n        index: Nullable<number> = null\r\n    ) {\r\n        super(name, skeleton.getScene(), false);\r\n        this._skeleton = skeleton;\r\n        this._localMatrix = localMatrix?.clone() ?? Matrix.Identity();\r\n        this._restMatrix = restMatrix ?? this._localMatrix.clone();\r\n        this._bindMatrix = bindMatrix ?? this._localMatrix.clone();\r\n        this._index = index;\r\n\r\n        this._absoluteMatrix = new Matrix();\r\n        this._absoluteBindMatrix = new Matrix();\r\n        this._absoluteInverseBindMatrix = new Matrix();\r\n        this._finalMatrix = new Matrix();\r\n\r\n        skeleton.bones.push(this);\r\n\r\n        this.setParent(parentBone, false);\r\n\r\n        this._updateAbsoluteBindMatrices();\r\n    }\r\n\r\n    /**\r\n     * Gets the current object class name.\r\n     * @returns the class name\r\n     */\r\n    public override getClassName(): string {\r\n        return \"Bone\";\r\n    }\r\n\r\n    // Members\r\n\r\n    /**\r\n     * Gets the parent skeleton\r\n     * @returns a skeleton\r\n     */\r\n    public getSkeleton(): Skeleton {\r\n        return this._skeleton;\r\n    }\r\n\r\n    public override get parent(): Bone {\r\n        return this._parentNode as Bone;\r\n    }\r\n\r\n    /**\r\n     * Gets parent bone\r\n     * @returns a bone or null if the bone is the root of the bone hierarchy\r\n     */\r\n    public getParent(): Nullable<Bone> {\r\n        return this.parent;\r\n    }\r\n\r\n    /**\r\n     * Returns an array containing the children of the bone\r\n     * @returns an array containing the children of the bone (can be empty if the bone has no children)\r\n     */\r\n    public override getChildren(): Array<Bone> {\r\n        return this.children;\r\n    }\r\n\r\n    /**\r\n     * Gets the node index in matrix array generated for rendering\r\n     * @returns the node index\r\n     */\r\n    public getIndex(): number {\r\n        return this._index === null ? this.getSkeleton().bones.indexOf(this) : this._index;\r\n    }\r\n\r\n    public override set parent(newParent: Nullable<Bone>) {\r\n        this.setParent(newParent);\r\n    }\r\n\r\n    /**\r\n     * Sets the parent bone\r\n     * @param parent defines the parent (can be null if the bone is the root)\r\n     * @param updateAbsoluteBindMatrices defines if the absolute bind and absolute inverse bind matrices must be updated\r\n     */\r\n    public setParent(parent: Nullable<Bone>, updateAbsoluteBindMatrices: boolean = true): void {\r\n        if (this.parent === parent) {\r\n            return;\r\n        }\r\n\r\n        if (this.parent) {\r\n            const index = this.parent.children.indexOf(this);\r\n            if (index !== -1) {\r\n                this.parent.children.splice(index, 1);\r\n            }\r\n        }\r\n\r\n        this._parentNode = parent;\r\n\r\n        if (this.parent) {\r\n            this.parent.children.push(this);\r\n        }\r\n\r\n        if (updateAbsoluteBindMatrices) {\r\n            this._updateAbsoluteBindMatrices();\r\n        }\r\n\r\n        this.markAsDirty();\r\n    }\r\n\r\n    /**\r\n     * Gets the local matrix\r\n     * @returns the local matrix\r\n     */\r\n    public getLocalMatrix(): Matrix {\r\n        this._compose();\r\n        return this._localMatrix;\r\n    }\r\n\r\n    /**\r\n     * Gets the bind matrix\r\n     * @returns the bind matrix\r\n     */\r\n    public getBindMatrix(): Matrix {\r\n        return this._bindMatrix;\r\n    }\r\n\r\n    /**\r\n     * Gets the bind matrix.\r\n     * @returns the bind matrix\r\n     * @deprecated Please use getBindMatrix instead\r\n     */\r\n    public getBaseMatrix(): Matrix {\r\n        return this.getBindMatrix();\r\n    }\r\n\r\n    /**\r\n     * Gets the rest matrix\r\n     * @returns the rest matrix\r\n     */\r\n    public getRestMatrix(): Matrix {\r\n        return this._restMatrix;\r\n    }\r\n\r\n    /**\r\n     * Gets the rest matrix\r\n     * @returns the rest matrix\r\n     * @deprecated Please use getRestMatrix instead\r\n     */\r\n    public getRestPose(): Matrix {\r\n        return this.getRestMatrix();\r\n    }\r\n\r\n    /**\r\n     * Sets the rest matrix\r\n     * @param matrix the local-space rest matrix to set for this bone\r\n     */\r\n    public setRestMatrix(matrix: Matrix): void {\r\n        this._restMatrix.copyFrom(matrix);\r\n    }\r\n\r\n    /**\r\n     * Sets the rest matrix\r\n     * @param matrix the local-space rest to set for this bone\r\n     * @deprecated Please use setRestMatrix instead\r\n     */\r\n    public setRestPose(matrix: Matrix): void {\r\n        this.setRestMatrix(matrix);\r\n    }\r\n\r\n    /**\r\n     * Gets the bind matrix\r\n     * @returns the bind matrix\r\n     * @deprecated Please use getBindMatrix instead\r\n     */\r\n    public getBindPose(): Matrix {\r\n        return this.getBindMatrix();\r\n    }\r\n\r\n    /**\r\n     * Sets the bind matrix\r\n     * This will trigger a recomputation of the absolute bind and absolute inverse bind matrices for this bone and its children\r\n     * Note that the local matrix will also be set with the matrix passed in parameter!\r\n     * @param matrix the local-space bind matrix to set for this bone\r\n     */\r\n    public setBindMatrix(matrix: Matrix): void {\r\n        this.updateMatrix(matrix);\r\n    }\r\n\r\n    /**\r\n     * Sets the bind matrix\r\n     * @param matrix the local-space bind to set for this bone\r\n     * @deprecated Please use setBindMatrix instead\r\n     */\r\n    public setBindPose(matrix: Matrix): void {\r\n        this.setBindMatrix(matrix);\r\n    }\r\n\r\n    /**\r\n     * Gets the matrix used to store the final world transformation of the bone (ie. the matrix sent to shaders)\r\n     * @returns the final world matrix\r\n     */\r\n    public getFinalMatrix(): Matrix {\r\n        return this._finalMatrix;\r\n    }\r\n\r\n    /**\r\n     * Gets the matrix used to store the final world transformation of the bone (ie. the matrix sent to shaders)\r\n     * @deprecated Please use getFinalMatrix instead\r\n     * @returns the final world matrix\r\n     */\r\n    public override getWorldMatrix(): Matrix {\r\n        return this.getFinalMatrix();\r\n    }\r\n\r\n    /**\r\n     * Sets the local matrix to the rest matrix\r\n     */\r\n    public returnToRest(): void {\r\n        if (this._linkedTransformNode) {\r\n            const localScaling = TmpVectors.Vector3[0];\r\n            const localRotation = TmpVectors.Quaternion[0];\r\n            const localPosition = TmpVectors.Vector3[1];\r\n\r\n            this.getRestMatrix().decompose(localScaling, localRotation, localPosition);\r\n\r\n            this._linkedTransformNode.position.copyFrom(localPosition);\r\n            this._linkedTransformNode.rotationQuaternion = this._linkedTransformNode.rotationQuaternion ?? Quaternion.Identity();\r\n            this._linkedTransformNode.rotationQuaternion.copyFrom(localRotation);\r\n            this._linkedTransformNode.scaling.copyFrom(localScaling);\r\n        } else {\r\n            this._matrix = this._restMatrix;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets the inverse of the bind matrix, in world space (relative to the skeleton root)\r\n     * @returns the inverse bind matrix, in world space\r\n     */\r\n    public getAbsoluteInverseBindMatrix(): Matrix {\r\n        return this._absoluteInverseBindMatrix;\r\n    }\r\n\r\n    /**\r\n     * Gets the inverse of the bind matrix, in world space (relative to the skeleton root)\r\n     * @returns the inverse bind matrix, in world space\r\n     * @deprecated Please use getAbsoluteInverseBindMatrix instead\r\n     */\r\n    public getInvertedAbsoluteTransform(): Matrix {\r\n        return this.getAbsoluteInverseBindMatrix();\r\n    }\r\n\r\n    /**\r\n     * Gets the bone matrix, in world space (relative to the skeleton root)\r\n     * @returns the bone matrix, in world space\r\n     */\r\n    public getAbsoluteMatrix(): Matrix {\r\n        return this._absoluteMatrix;\r\n    }\r\n\r\n    /**\r\n     * Gets the bone matrix, in world space (relative to the skeleton root)\r\n     * @returns the bone matrix, in world space\r\n     * @deprecated Please use getAbsoluteMatrix instead\r\n     */\r\n    public getAbsoluteTransform(): Matrix {\r\n        return this._absoluteMatrix;\r\n    }\r\n\r\n    /**\r\n     * Links with the given transform node.\r\n     * The local matrix of this bone is overwritten by the transform of the node every frame.\r\n     * @param transformNode defines the transform node to link to\r\n     */\r\n    public linkTransformNode(transformNode: Nullable<TransformNode>): void {\r\n        if (this._linkedTransformNode) {\r\n            this._skeleton._numBonesWithLinkedTransformNode--;\r\n        }\r\n\r\n        this._linkedTransformNode = transformNode;\r\n\r\n        if (this._linkedTransformNode) {\r\n            this._skeleton._numBonesWithLinkedTransformNode++;\r\n        }\r\n    }\r\n\r\n    // Properties (matches TransformNode properties)\r\n\r\n    /**\r\n     * Gets the node used to drive the bone's transformation\r\n     * @returns a transform node or null\r\n     */\r\n    public getTransformNode() {\r\n        return this._linkedTransformNode;\r\n    }\r\n\r\n    /** Gets or sets current position (in local space) */\r\n    public get position(): Vector3 {\r\n        this._decompose();\r\n        return this._localPosition;\r\n    }\r\n\r\n    public set position(newPosition: Vector3) {\r\n        this._decompose();\r\n        this._localPosition.copyFrom(newPosition);\r\n\r\n        this._markAsDirtyAndCompose();\r\n    }\r\n\r\n    /** Gets or sets current rotation (in local space) */\r\n    public get rotation(): Vector3 {\r\n        return this.getRotation();\r\n    }\r\n\r\n    public set rotation(newRotation: Vector3) {\r\n        this.setRotation(newRotation);\r\n    }\r\n\r\n    /** Gets or sets current rotation quaternion (in local space) */\r\n    public get rotationQuaternion() {\r\n        this._decompose();\r\n        return this._localRotation;\r\n    }\r\n\r\n    public set rotationQuaternion(newRotation: Quaternion) {\r\n        this.setRotationQuaternion(newRotation);\r\n    }\r\n\r\n    /** Gets or sets current scaling (in local space) */\r\n    public get scaling(): Vector3 {\r\n        return this.getScale();\r\n    }\r\n\r\n    public set scaling(newScaling: Vector3) {\r\n        this.setScale(newScaling);\r\n    }\r\n\r\n    /**\r\n     * Gets the animation properties override\r\n     */\r\n    public override get animationPropertiesOverride(): Nullable<AnimationPropertiesOverride> {\r\n        return this._skeleton.animationPropertiesOverride;\r\n    }\r\n\r\n    // Methods\r\n    private _decompose() {\r\n        if (!this._needToDecompose) {\r\n            return;\r\n        }\r\n\r\n        this._needToDecompose = false;\r\n\r\n        if (!this._localScaling) {\r\n            this._localScaling = Vector3.Zero();\r\n            this._localRotation = Quaternion.Zero();\r\n            this._localPosition = Vector3.Zero();\r\n        }\r\n        this._localMatrix.decompose(this._localScaling, this._localRotation, this._localPosition);\r\n    }\r\n\r\n    private _compose() {\r\n        if (!this._needToCompose) {\r\n            return;\r\n        }\r\n\r\n        if (!this._localScaling) {\r\n            this._needToCompose = false;\r\n            return;\r\n        }\r\n\r\n        this._needToCompose = false;\r\n        Matrix.ComposeToRef(this._localScaling, this._localRotation, this._localPosition, this._localMatrix);\r\n    }\r\n\r\n    /**\r\n     * Update the bind (and optionally the local) matrix\r\n     * @param bindMatrix defines the new matrix to set to the bind/local matrix, in local space\r\n     * @param updateAbsoluteBindMatrices defines if the absolute bind and absolute inverse bind matrices must be recomputed (default: true)\r\n     * @param updateLocalMatrix defines if the local matrix should also be updated with the matrix passed in parameter (default: true)\r\n     */\r\n    public updateMatrix(bindMatrix: Matrix, updateAbsoluteBindMatrices = true, updateLocalMatrix = true): void {\r\n        this._bindMatrix.copyFrom(bindMatrix);\r\n\r\n        if (updateAbsoluteBindMatrices) {\r\n            this._updateAbsoluteBindMatrices();\r\n        }\r\n\r\n        if (updateLocalMatrix) {\r\n            this._matrix = bindMatrix;\r\n        } else {\r\n            this.markAsDirty();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _updateAbsoluteBindMatrices(bindMatrix?: Matrix, updateChildren = true): void {\r\n        if (!bindMatrix) {\r\n            bindMatrix = this._bindMatrix;\r\n        }\r\n\r\n        if (this.parent) {\r\n            bindMatrix.multiplyToRef(this.parent._absoluteBindMatrix, this._absoluteBindMatrix);\r\n        } else {\r\n            this._absoluteBindMatrix.copyFrom(bindMatrix);\r\n        }\r\n\r\n        this._absoluteBindMatrix.invertToRef(this._absoluteInverseBindMatrix);\r\n\r\n        if (updateChildren) {\r\n            for (let index = 0; index < this.children.length; index++) {\r\n                this.children[index]._updateAbsoluteBindMatrices();\r\n            }\r\n        }\r\n\r\n        this._scalingDeterminant = this._absoluteBindMatrix.determinant() < 0 ? -1 : 1;\r\n    }\r\n\r\n    /**\r\n     * Flag the bone as dirty (Forcing it to update everything)\r\n     * @returns this bone\r\n     */\r\n    public override markAsDirty(): Bone {\r\n        this._currentRenderId++;\r\n        this._childUpdateId++;\r\n        this._skeleton._markAsDirty();\r\n        return this;\r\n    }\r\n\r\n    /** @internal */\r\n    public _markAsDirtyAndCompose() {\r\n        this.markAsDirty();\r\n        this._needToCompose = true;\r\n    }\r\n\r\n    private _markAsDirtyAndDecompose() {\r\n        this.markAsDirty();\r\n        this._needToDecompose = true;\r\n    }\r\n\r\n    private _updatePosition(vec: Vector3, space = Space.LOCAL, tNode?: TransformNode, translationMode = true): void {\r\n        const lm = this.getLocalMatrix();\r\n\r\n        if (space == Space.LOCAL) {\r\n            if (translationMode) {\r\n                lm.addAtIndex(12, vec.x);\r\n                lm.addAtIndex(13, vec.y);\r\n                lm.addAtIndex(14, vec.z);\r\n            } else {\r\n                lm.setTranslationFromFloats(vec.x, vec.y, vec.z);\r\n            }\r\n        } else {\r\n            let wm: Nullable<Matrix> = null;\r\n\r\n            //tNode.getWorldMatrix() needs to be called before skeleton.computeAbsoluteMatrices()\r\n            if (tNode) {\r\n                wm = tNode.getWorldMatrix();\r\n            }\r\n\r\n            this._skeleton.computeAbsoluteMatrices();\r\n\r\n            const tmat = Bone._TmpMats[0];\r\n            const tvec = Bone._TmpVecs[0];\r\n\r\n            if (this.parent) {\r\n                if (tNode && wm) {\r\n                    tmat.copyFrom(this.parent.getAbsoluteMatrix());\r\n                    tmat.multiplyToRef(wm, tmat);\r\n                } else {\r\n                    tmat.copyFrom(this.parent.getAbsoluteMatrix());\r\n                }\r\n            } else {\r\n                Matrix.IdentityToRef(tmat);\r\n            }\r\n\r\n            if (translationMode) {\r\n                tmat.setTranslationFromFloats(0, 0, 0);\r\n            }\r\n            tmat.invert();\r\n            Vector3.TransformCoordinatesToRef(vec, tmat, tvec);\r\n\r\n            if (translationMode) {\r\n                lm.addAtIndex(12, tvec.x);\r\n                lm.addAtIndex(13, tvec.y);\r\n                lm.addAtIndex(14, tvec.z);\r\n            } else {\r\n                lm.setTranslationFromFloats(tvec.x, tvec.y, tvec.z);\r\n            }\r\n        }\r\n\r\n        this._markAsDirtyAndDecompose();\r\n    }\r\n\r\n    /**\r\n     * Translate the bone in local or world space\r\n     * @param vec The amount to translate the bone\r\n     * @param space The space that the translation is in (default: Space.LOCAL)\r\n     * @param tNode A TransformNode whose world matrix is to be applied to the calculated absolute matrix. In most cases, you'll want to pass the mesh associated with the skeleton from which this bone comes. Used only when space=Space.WORLD\r\n     */\r\n    public translate(vec: Vector3, space = Space.LOCAL, tNode?: TransformNode): void {\r\n        this._updatePosition(vec, space, tNode, true);\r\n    }\r\n\r\n    /**\r\n     * Set the position of the bone in local or world space\r\n     * @param position The position to set the bone\r\n     * @param space The space that the position is in (default: Space.LOCAL)\r\n     * @param tNode A TransformNode whose world matrix is to be applied to the calculated absolute matrix. In most cases, you'll want to pass the mesh associated with the skeleton from which this bone comes. Used only when space=Space.WORLD\r\n     */\r\n    public setPosition(position: Vector3, space = Space.LOCAL, tNode?: TransformNode): void {\r\n        this._updatePosition(position, space, tNode, false);\r\n    }\r\n\r\n    /**\r\n     * Set the absolute position of the bone (world space)\r\n     * @param position The position to set the bone\r\n     * @param tNode A TransformNode whose world matrix is to be applied to the calculated absolute matrix. In most cases, you'll want to pass the mesh associated with the skeleton from which this bone comes. Used only when space=Space.WORLD\r\n     */\r\n    public setAbsolutePosition(position: Vector3, tNode?: TransformNode) {\r\n        this.setPosition(position, Space.WORLD, tNode);\r\n    }\r\n\r\n    /**\r\n     * Scale the bone on the x, y and z axes (in local space)\r\n     * @param x The amount to scale the bone on the x axis\r\n     * @param y The amount to scale the bone on the y axis\r\n     * @param z The amount to scale the bone on the z axis\r\n     * @param scaleChildren sets this to true if children of the bone should be scaled as well (false by default)\r\n     */\r\n    public scale(x: number, y: number, z: number, scaleChildren = false): void {\r\n        const locMat = this.getLocalMatrix();\r\n\r\n        // Apply new scaling on top of current local matrix\r\n        const scaleMat = Bone._TmpMats[0];\r\n        Matrix.ScalingToRef(x, y, z, scaleMat);\r\n        scaleMat.multiplyToRef(locMat, locMat);\r\n\r\n        // Invert scaling matrix and apply the inverse to all children\r\n        scaleMat.invert();\r\n\r\n        for (const child of this.children) {\r\n            const cm = child.getLocalMatrix();\r\n            cm.multiplyToRef(scaleMat, cm);\r\n            cm.multiplyAtIndex(12, x);\r\n            cm.multiplyAtIndex(13, y);\r\n            cm.multiplyAtIndex(14, z);\r\n\r\n            child._markAsDirtyAndDecompose();\r\n        }\r\n\r\n        this._markAsDirtyAndDecompose();\r\n\r\n        if (scaleChildren) {\r\n            for (const child of this.children) {\r\n                child.scale(x, y, z, scaleChildren);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Set the bone scaling in local space\r\n     * @param scale defines the scaling vector\r\n     */\r\n    public setScale(scale: Vector3): void {\r\n        this._decompose();\r\n        this._localScaling.copyFrom(scale);\r\n        this._markAsDirtyAndCompose();\r\n    }\r\n\r\n    /**\r\n     * Gets the current scaling in local space\r\n     * @returns the current scaling vector\r\n     */\r\n    public getScale(): Vector3 {\r\n        this._decompose();\r\n        return this._localScaling;\r\n    }\r\n\r\n    /**\r\n     * Gets the current scaling in local space and stores it in a target vector\r\n     * @param result defines the target vector\r\n     */\r\n    public getScaleToRef(result: Vector3) {\r\n        this._decompose();\r\n        result.copyFrom(this._localScaling);\r\n    }\r\n\r\n    /**\r\n     * Set the yaw, pitch, and roll of the bone in local or world space\r\n     * @param yaw The rotation of the bone on the y axis\r\n     * @param pitch The rotation of the bone on the x axis\r\n     * @param roll The rotation of the bone on the z axis\r\n     * @param space The space that the axes of rotation are in\r\n     * @param tNode A TransformNode whose world matrix is to be applied to the calculated absolute matrix. In most cases, you'll want to pass the mesh associated with the skeleton from which this bone comes. Used only when space=Space.WORLD\r\n     */\r\n    public setYawPitchRoll(yaw: number, pitch: number, roll: number, space = Space.LOCAL, tNode?: TransformNode): void {\r\n        if (space === Space.LOCAL) {\r\n            const quat = Bone._TmpQuat;\r\n            Quaternion.RotationYawPitchRollToRef(yaw, pitch, roll, quat);\r\n            this.setRotationQuaternion(quat, space, tNode);\r\n            return;\r\n        }\r\n\r\n        const rotMatInv = Bone._TmpMats[0];\r\n        if (!this._getAbsoluteInverseMatrixUnscaledToRef(rotMatInv, tNode)) {\r\n            return;\r\n        }\r\n\r\n        const rotMat = Bone._TmpMats[1];\r\n        Matrix.RotationYawPitchRollToRef(yaw, pitch, roll, rotMat);\r\n\r\n        rotMatInv.multiplyToRef(rotMat, rotMat);\r\n        this._rotateWithMatrix(rotMat, space, tNode);\r\n    }\r\n\r\n    /**\r\n     * Add a rotation to the bone on an axis in local or world space\r\n     * @param axis The axis to rotate the bone on\r\n     * @param amount The amount to rotate the bone\r\n     * @param space The space that the axis is in\r\n     * @param tNode A TransformNode whose world matrix is to be applied to the calculated absolute matrix. In most cases, you'll want to pass the mesh associated with the skeleton from which this bone comes. Used only when space=Space.WORLD\r\n     */\r\n    public rotate(axis: Vector3, amount: number, space = Space.LOCAL, tNode?: TransformNode): void {\r\n        const rmat = Bone._TmpMats[0];\r\n        rmat.setTranslationFromFloats(0, 0, 0);\r\n        Matrix.RotationAxisToRef(axis, amount, rmat);\r\n        this._rotateWithMatrix(rmat, space, tNode);\r\n    }\r\n\r\n    /**\r\n     * Set the rotation of the bone to a particular axis angle in local or world space\r\n     * @param axis The axis to rotate the bone on\r\n     * @param angle The angle that the bone should be rotated to\r\n     * @param space The space that the axis is in\r\n     * @param tNode A TransformNode whose world matrix is to be applied to the calculated absolute matrix. In most cases, you'll want to pass the mesh associated with the skeleton from which this bone comes. Used only when space=Space.WORLD\r\n     */\r\n    public setAxisAngle(axis: Vector3, angle: number, space = Space.LOCAL, tNode?: TransformNode): void {\r\n        if (space === Space.LOCAL) {\r\n            const quat = Bone._TmpQuat;\r\n            Quaternion.RotationAxisToRef(axis, angle, quat);\r\n\r\n            this.setRotationQuaternion(quat, space, tNode);\r\n            return;\r\n        }\r\n\r\n        const rotMatInv = Bone._TmpMats[0];\r\n        if (!this._getAbsoluteInverseMatrixUnscaledToRef(rotMatInv, tNode)) {\r\n            return;\r\n        }\r\n\r\n        const rotMat = Bone._TmpMats[1];\r\n        Matrix.RotationAxisToRef(axis, angle, rotMat);\r\n\r\n        rotMatInv.multiplyToRef(rotMat, rotMat);\r\n        this._rotateWithMatrix(rotMat, space, tNode);\r\n    }\r\n\r\n    /**\r\n     * Set the euler rotation of the bone in local or world space\r\n     * @param rotation The euler rotation that the bone should be set to\r\n     * @param space The space that the rotation is in\r\n     * @param tNode A TransformNode whose world matrix is to be applied to the calculated absolute matrix. In most cases, you'll want to pass the mesh associated with the skeleton from which this bone comes. Used only when space=Space.WORLD\r\n     */\r\n    public setRotation(rotation: Vector3, space = Space.LOCAL, tNode?: TransformNode): void {\r\n        this.setYawPitchRoll(rotation.y, rotation.x, rotation.z, space, tNode);\r\n    }\r\n\r\n    /**\r\n     * Set the quaternion rotation of the bone in local or world space\r\n     * @param quat The quaternion rotation that the bone should be set to\r\n     * @param space The space that the rotation is in\r\n     * @param tNode A TransformNode whose world matrix is to be applied to the calculated absolute matrix. In most cases, you'll want to pass the mesh associated with the skeleton from which this bone comes. Used only when space=Space.WORLD\r\n     */\r\n    public setRotationQuaternion(quat: Quaternion, space = Space.LOCAL, tNode?: TransformNode): void {\r\n        if (space === Space.LOCAL) {\r\n            this._decompose();\r\n            this._localRotation.copyFrom(quat);\r\n\r\n            this._markAsDirtyAndCompose();\r\n\r\n            return;\r\n        }\r\n\r\n        const rotMatInv = Bone._TmpMats[0];\r\n        if (!this._getAbsoluteInverseMatrixUnscaledToRef(rotMatInv, tNode)) {\r\n            return;\r\n        }\r\n\r\n        const rotMat = Bone._TmpMats[1];\r\n        Matrix.FromQuaternionToRef(quat, rotMat);\r\n\r\n        rotMatInv.multiplyToRef(rotMat, rotMat);\r\n\r\n        this._rotateWithMatrix(rotMat, space, tNode);\r\n    }\r\n\r\n    /**\r\n     * Set the rotation matrix of the bone in local or world space\r\n     * @param rotMat The rotation matrix that the bone should be set to\r\n     * @param space The space that the rotation is in\r\n     * @param tNode A TransformNode whose world matrix is to be applied to the calculated absolute matrix. In most cases, you'll want to pass the mesh associated with the skeleton from which this bone comes. Used only when space=Space.WORLD\r\n     */\r\n    public setRotationMatrix(rotMat: Matrix, space = Space.LOCAL, tNode?: TransformNode): void {\r\n        if (space === Space.LOCAL) {\r\n            const quat = Bone._TmpQuat;\r\n            Quaternion.FromRotationMatrixToRef(rotMat, quat);\r\n            this.setRotationQuaternion(quat, space, tNode);\r\n            return;\r\n        }\r\n\r\n        const rotMatInv = Bone._TmpMats[0];\r\n        if (!this._getAbsoluteInverseMatrixUnscaledToRef(rotMatInv, tNode)) {\r\n            return;\r\n        }\r\n\r\n        const rotMat2 = Bone._TmpMats[1];\r\n        rotMat2.copyFrom(rotMat);\r\n\r\n        rotMatInv.multiplyToRef(rotMat, rotMat2);\r\n\r\n        this._rotateWithMatrix(rotMat2, space, tNode);\r\n    }\r\n\r\n    private _rotateWithMatrix(rmat: Matrix, space = Space.LOCAL, tNode?: TransformNode): void {\r\n        const lmat = this.getLocalMatrix();\r\n        const lx = lmat.m[12];\r\n        const ly = lmat.m[13];\r\n        const lz = lmat.m[14];\r\n        const parent = this.getParent();\r\n        const parentScale = Bone._TmpMats[3];\r\n        const parentScaleInv = Bone._TmpMats[4];\r\n\r\n        if (parent && space == Space.WORLD) {\r\n            if (tNode) {\r\n                parentScale.copyFrom(tNode.getWorldMatrix());\r\n                parent.getAbsoluteMatrix().multiplyToRef(parentScale, parentScale);\r\n            } else {\r\n                parentScale.copyFrom(parent.getAbsoluteMatrix());\r\n            }\r\n            parentScaleInv.copyFrom(parentScale);\r\n            parentScaleInv.invert();\r\n            lmat.multiplyToRef(parentScale, lmat);\r\n            lmat.multiplyToRef(rmat, lmat);\r\n            lmat.multiplyToRef(parentScaleInv, lmat);\r\n        } else {\r\n            if (space == Space.WORLD && tNode) {\r\n                parentScale.copyFrom(tNode.getWorldMatrix());\r\n                parentScaleInv.copyFrom(parentScale);\r\n                parentScaleInv.invert();\r\n                lmat.multiplyToRef(parentScale, lmat);\r\n                lmat.multiplyToRef(rmat, lmat);\r\n                lmat.multiplyToRef(parentScaleInv, lmat);\r\n            } else {\r\n                lmat.multiplyToRef(rmat, lmat);\r\n            }\r\n        }\r\n\r\n        lmat.setTranslationFromFloats(lx, ly, lz);\r\n\r\n        this.computeAbsoluteMatrices();\r\n        this._markAsDirtyAndDecompose();\r\n    }\r\n\r\n    private _getAbsoluteInverseMatrixUnscaledToRef(rotMatInv: Matrix, tNode?: TransformNode): boolean {\r\n        const scaleMatrix = Bone._TmpMats[2];\r\n        rotMatInv.copyFrom(this.getAbsoluteMatrix());\r\n\r\n        if (tNode) {\r\n            rotMatInv.multiplyToRef(tNode.getWorldMatrix(), rotMatInv);\r\n            Matrix.ScalingToRef(tNode.scaling.x, tNode.scaling.y, tNode.scaling.z, scaleMatrix);\r\n        } else {\r\n            Matrix.IdentityToRef(scaleMatrix);\r\n        }\r\n\r\n        rotMatInv.invert();\r\n        if (isNaN(rotMatInv.m[0])) {\r\n            // Matrix failed to invert.\r\n            // This can happen if scale is zero for example.\r\n            return false;\r\n        }\r\n\r\n        scaleMatrix.multiplyAtIndex(0, this._scalingDeterminant);\r\n        rotMatInv.multiplyToRef(scaleMatrix, rotMatInv);\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Get the position of the bone in local or world space\r\n     * @param space The space that the returned position is in\r\n     * @param tNode A TransformNode whose world matrix is to be applied to the calculated absolute matrix. In most cases, you'll want to pass the mesh associated with the skeleton from which this bone comes. Used only when space=Space.WORLD\r\n     * @returns The position of the bone\r\n     */\r\n    public getPosition(space = Space.LOCAL, tNode: Nullable<TransformNode> = null): Vector3 {\r\n        const pos = Vector3.Zero();\r\n\r\n        this.getPositionToRef(space, tNode, pos);\r\n\r\n        return pos;\r\n    }\r\n\r\n    /**\r\n     * Copy the position of the bone to a vector3 in local or world space\r\n     * @param space The space that the returned position is in\r\n     * @param tNode A TransformNode whose world matrix is to be applied to the calculated absolute matrix. In most cases, you'll want to pass the mesh associated with the skeleton from which this bone comes. Used only when space=Space.WORLD\r\n     * @param result The vector3 to copy the position to\r\n     */\r\n    public getPositionToRef(space = Space.LOCAL, tNode: Nullable<TransformNode>, result: Vector3): void {\r\n        if (space == Space.LOCAL) {\r\n            const lm = this.getLocalMatrix();\r\n\r\n            result.x = lm.m[12];\r\n            result.y = lm.m[13];\r\n            result.z = lm.m[14];\r\n        } else {\r\n            let wm: Nullable<Matrix> = null;\r\n\r\n            //tNode.getWorldMatrix() needs to be called before skeleton.computeAbsoluteMatrices()\r\n            if (tNode) {\r\n                wm = tNode.getWorldMatrix();\r\n            }\r\n\r\n            this._skeleton.computeAbsoluteMatrices();\r\n\r\n            let tmat = Bone._TmpMats[0];\r\n\r\n            if (tNode && wm) {\r\n                tmat.copyFrom(this.getAbsoluteMatrix());\r\n                tmat.multiplyToRef(wm, tmat);\r\n            } else {\r\n                tmat = this.getAbsoluteMatrix();\r\n            }\r\n\r\n            result.x = tmat.m[12];\r\n            result.y = tmat.m[13];\r\n            result.z = tmat.m[14];\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Get the absolute position of the bone (world space)\r\n     * @param tNode A TransformNode whose world matrix is to be applied to the calculated absolute matrix. In most cases, you'll want to pass the mesh associated with the skeleton from which this bone comes. Used only when space=Space.WORLD\r\n     * @returns The absolute position of the bone\r\n     */\r\n    public getAbsolutePosition(tNode: Nullable<TransformNode> = null): Vector3 {\r\n        const pos = Vector3.Zero();\r\n\r\n        this.getPositionToRef(Space.WORLD, tNode, pos);\r\n\r\n        return pos;\r\n    }\r\n\r\n    /**\r\n     * Copy the absolute position of the bone (world space) to the result param\r\n     * @param tNode A TransformNode whose world matrix is to be applied to the calculated absolute matrix. In most cases, you'll want to pass the mesh associated with the skeleton from which this bone comes. Used only when space=Space.WORLD\r\n     * @param result The vector3 to copy the absolute position to\r\n     */\r\n    public getAbsolutePositionToRef(tNode: TransformNode, result: Vector3) {\r\n        this.getPositionToRef(Space.WORLD, tNode, result);\r\n    }\r\n\r\n    /**\r\n     * Compute the absolute matrices of this bone and its children\r\n     */\r\n    public computeAbsoluteMatrices(): void {\r\n        this._compose();\r\n\r\n        if (this.parent) {\r\n            this._localMatrix.multiplyToRef(this.parent._absoluteMatrix, this._absoluteMatrix);\r\n        } else {\r\n            this._absoluteMatrix.copyFrom(this._localMatrix);\r\n\r\n            const poseMatrix = this._skeleton.getPoseMatrix();\r\n\r\n            if (poseMatrix) {\r\n                this._absoluteMatrix.multiplyToRef(poseMatrix, this._absoluteMatrix);\r\n            }\r\n        }\r\n\r\n        const children = this.children;\r\n        const len = children.length;\r\n\r\n        for (let i = 0; i < len; i++) {\r\n            children[i].computeAbsoluteMatrices();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Compute the absolute matrices of this bone and its children\r\n     * @deprecated Please use computeAbsoluteMatrices instead\r\n     */\r\n    public computeAbsoluteTransforms(): void {\r\n        this.computeAbsoluteMatrices();\r\n    }\r\n\r\n    /**\r\n     * Get the world direction from an axis that is in the local space of the bone\r\n     * @param localAxis The local direction that is used to compute the world direction\r\n     * @param tNode A TransformNode whose world matrix is to be applied to the calculated absolute matrix. In most cases, you'll want to pass the mesh associated with the skeleton from which this bone comes. Used only when space=Space.WORLD\r\n     * @returns The world direction\r\n     */\r\n    public getDirection(localAxis: Vector3, tNode: Nullable<TransformNode> = null): Vector3 {\r\n        const result = Vector3.Zero();\r\n\r\n        this.getDirectionToRef(localAxis, tNode, result);\r\n\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Copy the world direction to a vector3 from an axis that is in the local space of the bone\r\n     * @param localAxis The local direction that is used to compute the world direction\r\n     * @param tNode A TransformNode whose world matrix is to be applied to the calculated absolute matrix. In most cases, you'll want to pass the mesh associated with the skeleton from which this bone comes. Used only when space=Space.WORLD\r\n     * @param result The vector3 that the world direction will be copied to\r\n     */\r\n    public getDirectionToRef(localAxis: Vector3, tNode: Nullable<TransformNode> = null, result: Vector3): void {\r\n        let wm: Nullable<Matrix> = null;\r\n\r\n        //tNode.getWorldMatrix() needs to be called before skeleton.computeAbsoluteMatrices()\r\n        if (tNode) {\r\n            wm = tNode.getWorldMatrix();\r\n        }\r\n\r\n        this._skeleton.computeAbsoluteMatrices();\r\n\r\n        const mat = Bone._TmpMats[0];\r\n\r\n        mat.copyFrom(this.getAbsoluteMatrix());\r\n\r\n        if (tNode && wm) {\r\n            mat.multiplyToRef(wm, mat);\r\n        }\r\n\r\n        Vector3.TransformNormalToRef(localAxis, mat, result);\r\n\r\n        result.normalize();\r\n    }\r\n\r\n    /**\r\n     * Get the euler rotation of the bone in local or world space\r\n     * @param space The space that the rotation should be in\r\n     * @param tNode A TransformNode whose world matrix is to be applied to the calculated absolute matrix. In most cases, you'll want to pass the mesh associated with the skeleton from which this bone comes. Used only when space=Space.WORLD\r\n     * @returns The euler rotation\r\n     */\r\n    public getRotation(space = Space.LOCAL, tNode: Nullable<TransformNode> = null): Vector3 {\r\n        const result = Vector3.Zero();\r\n\r\n        this.getRotationToRef(space, tNode, result);\r\n\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Copy the euler rotation of the bone to a vector3.  The rotation can be in either local or world space\r\n     * @param space The space that the rotation should be in\r\n     * @param tNode A TransformNode whose world matrix is to be applied to the calculated absolute matrix. In most cases, you'll want to pass the mesh associated with the skeleton from which this bone comes. Used only when space=Space.WORLD\r\n     * @param result The vector3 that the rotation should be copied to\r\n     */\r\n    public getRotationToRef(space = Space.LOCAL, tNode: Nullable<TransformNode> = null, result: Vector3): void {\r\n        const quat = Bone._TmpQuat;\r\n\r\n        this.getRotationQuaternionToRef(space, tNode, quat);\r\n\r\n        quat.toEulerAnglesToRef(result);\r\n    }\r\n\r\n    /**\r\n     * Get the quaternion rotation of the bone in either local or world space\r\n     * @param space The space that the rotation should be in\r\n     * @param tNode A TransformNode whose world matrix is to be applied to the calculated absolute matrix. In most cases, you'll want to pass the mesh associated with the skeleton from which this bone comes. Used only when space=Space.WORLD\r\n     * @returns The quaternion rotation\r\n     */\r\n    public getRotationQuaternion(space = Space.LOCAL, tNode: Nullable<TransformNode> = null): Quaternion {\r\n        const result = Quaternion.Identity();\r\n\r\n        this.getRotationQuaternionToRef(space, tNode, result);\r\n\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Copy the quaternion rotation of the bone to a quaternion.  The rotation can be in either local or world space\r\n     * @param space The space that the rotation should be in\r\n     * @param tNode A TransformNode whose world matrix is to be applied to the calculated absolute matrix. In most cases, you'll want to pass the mesh associated with the skeleton from which this bone comes. Used only when space=Space.WORLD\r\n     * @param result The quaternion that the rotation should be copied to\r\n     */\r\n    public getRotationQuaternionToRef(space = Space.LOCAL, tNode: Nullable<TransformNode> = null, result: Quaternion): void {\r\n        if (space == Space.LOCAL) {\r\n            this._decompose();\r\n            result.copyFrom(this._localRotation);\r\n        } else {\r\n            const mat = Bone._TmpMats[0];\r\n            const amat = this.getAbsoluteMatrix();\r\n\r\n            if (tNode) {\r\n                amat.multiplyToRef(tNode.getWorldMatrix(), mat);\r\n            } else {\r\n                mat.copyFrom(amat);\r\n            }\r\n\r\n            mat.multiplyAtIndex(0, this._scalingDeterminant);\r\n            mat.multiplyAtIndex(1, this._scalingDeterminant);\r\n            mat.multiplyAtIndex(2, this._scalingDeterminant);\r\n\r\n            mat.decompose(undefined, result, undefined);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Get the rotation matrix of the bone in local or world space\r\n     * @param space The space that the rotation should be in\r\n     * @param tNode A TransformNode whose world matrix is to be applied to the calculated absolute matrix. In most cases, you'll want to pass the mesh associated with the skeleton from which this bone comes. Used only when space=Space.WORLD\r\n     * @returns The rotation matrix\r\n     */\r\n    public getRotationMatrix(space = Space.LOCAL, tNode: TransformNode): Matrix {\r\n        const result = Matrix.Identity();\r\n\r\n        this.getRotationMatrixToRef(space, tNode, result);\r\n\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Copy the rotation matrix of the bone to a matrix.  The rotation can be in either local or world space\r\n     * @param space The space that the rotation should be in\r\n     * @param tNode A TransformNode whose world matrix is to be applied to the calculated absolute matrix. In most cases, you'll want to pass the mesh associated with the skeleton from which this bone comes. Used only when space=Space.WORLD\r\n     * @param result The quaternion that the rotation should be copied to\r\n     */\r\n    public getRotationMatrixToRef(space = Space.LOCAL, tNode: TransformNode, result: Matrix): void {\r\n        if (space == Space.LOCAL) {\r\n            this.getLocalMatrix().getRotationMatrixToRef(result);\r\n        } else {\r\n            const mat = Bone._TmpMats[0];\r\n            const amat = this.getAbsoluteMatrix();\r\n\r\n            if (tNode) {\r\n                amat.multiplyToRef(tNode.getWorldMatrix(), mat);\r\n            } else {\r\n                mat.copyFrom(amat);\r\n            }\r\n\r\n            mat.multiplyAtIndex(0, this._scalingDeterminant);\r\n            mat.multiplyAtIndex(1, this._scalingDeterminant);\r\n            mat.multiplyAtIndex(2, this._scalingDeterminant);\r\n\r\n            mat.getRotationMatrixToRef(result);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Get the world position of a point that is in the local space of the bone\r\n     * @param position The local position\r\n     * @param tNode A TransformNode whose world matrix is to be applied to the calculated absolute matrix. In most cases, you'll want to pass the mesh associated with the skeleton from which this bone comes. Used only when space=Space.WORLD\r\n     * @returns The world position\r\n     */\r\n    public getAbsolutePositionFromLocal(position: Vector3, tNode: Nullable<TransformNode> = null): Vector3 {\r\n        const result = Vector3.Zero();\r\n\r\n        this.getAbsolutePositionFromLocalToRef(position, tNode, result);\r\n\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Get the world position of a point that is in the local space of the bone and copy it to the result param\r\n     * @param position The local position\r\n     * @param tNode A TransformNode whose world matrix is to be applied to the calculated absolute matrix. In most cases, you'll want to pass the mesh associated with the skeleton from which this bone comes. Used only when space=Space.WORLD\r\n     * @param result The vector3 that the world position should be copied to\r\n     */\r\n    public getAbsolutePositionFromLocalToRef(position: Vector3, tNode: Nullable<TransformNode> = null, result: Vector3): void {\r\n        let wm: Nullable<Matrix> = null;\r\n\r\n        //tNode.getWorldMatrix() needs to be called before skeleton.computeAbsoluteMatrices()\r\n        if (tNode) {\r\n            wm = tNode.getWorldMatrix();\r\n        }\r\n\r\n        this._skeleton.computeAbsoluteMatrices();\r\n\r\n        const tmat = Bone._TmpMats[0];\r\n\r\n        tmat.copyFrom(this.getAbsoluteMatrix());\r\n\r\n        if (tNode && wm) {\r\n            tmat.multiplyToRef(wm, tmat);\r\n        }\r\n\r\n        Vector3.TransformCoordinatesToRef(position, tmat, result);\r\n    }\r\n\r\n    /**\r\n     * Get the local position of a point that is in world space\r\n     * @param position The world position\r\n     * @param tNode A TransformNode whose world matrix is to be applied to the calculated absolute matrix. In most cases, you'll want to pass the mesh associated with the skeleton from which this bone comes. Used only when space=Space.WORLD\r\n     * @returns The local position\r\n     */\r\n    public getLocalPositionFromAbsolute(position: Vector3, tNode: Nullable<TransformNode> = null): Vector3 {\r\n        const result = Vector3.Zero();\r\n\r\n        this.getLocalPositionFromAbsoluteToRef(position, tNode, result);\r\n\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Get the local position of a point that is in world space and copy it to the result param\r\n     * @param position The world position\r\n     * @param tNode A TransformNode whose world matrix is to be applied to the calculated absolute matrix. In most cases, you'll want to pass the mesh associated with the skeleton from which this bone comes. Used only when space=Space.WORLD\r\n     * @param result The vector3 that the local position should be copied to\r\n     */\r\n    public getLocalPositionFromAbsoluteToRef(position: Vector3, tNode: Nullable<TransformNode> = null, result: Vector3): void {\r\n        let wm: Nullable<Matrix> = null;\r\n\r\n        //tNode.getWorldMatrix() needs to be called before skeleton.computeAbsoluteMatrices()\r\n        if (tNode) {\r\n            wm = tNode.getWorldMatrix();\r\n        }\r\n\r\n        this._skeleton.computeAbsoluteMatrices();\r\n\r\n        const tmat = Bone._TmpMats[0];\r\n\r\n        tmat.copyFrom(this.getAbsoluteMatrix());\r\n\r\n        if (tNode && wm) {\r\n            tmat.multiplyToRef(wm, tmat);\r\n        }\r\n\r\n        tmat.invert();\r\n\r\n        Vector3.TransformCoordinatesToRef(position, tmat, result);\r\n    }\r\n\r\n    /**\r\n     * Set the current local matrix as the restMatrix for this bone.\r\n     */\r\n    public setCurrentPoseAsRest(): void {\r\n        this.setRestMatrix(this.getLocalMatrix());\r\n    }\r\n\r\n    /**\r\n     * Releases associated resources\r\n     */\r\n    public override dispose(): void {\r\n        this._linkedTransformNode = null;\r\n\r\n        const index = this._skeleton.bones.indexOf(this);\r\n        if (index !== -1) {\r\n            this._skeleton.bones.splice(index, 1);\r\n        }\r\n\r\n        if (this._parentNode && (this._parentNode as Bone).children) {\r\n            const children = (this._parentNode as Bone).children;\r\n            const index = children.indexOf(this);\r\n            if (index !== -1) {\r\n                children.splice(index, 1);\r\n            }\r\n        }\r\n\r\n        super.dispose();\r\n    }\r\n}\r\n"],
  "mappings": "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",
  "names": ["index"]
}
