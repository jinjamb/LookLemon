{
  "version": 3,
  "sources": ["../../../dev/core/src/Misc/andOrNotEvaluator.ts", "../../../dev/core/src/Misc/tags.ts", "../../../dev/core/src/Misc/decorators.serialization.ts", "../../../dev/core/src/Maths/math.plane.ts"],
  "sourcesContent": ["/**\r\n * Class used to evaluate queries containing `and` and `or` operators\r\n */\r\nexport class AndOrNotEvaluator {\r\n    /**\r\n     * Evaluate a query\r\n     * @param query defines the query to evaluate\r\n     * @param evaluateCallback defines the callback used to filter result\r\n     * @returns true if the query matches\r\n     */\r\n    public static Eval(query: string, evaluateCallback: (val: any) => boolean): boolean {\r\n        if (!query.match(/\\([^()]*\\)/g)) {\r\n            query = AndOrNotEvaluator._HandleParenthesisContent(query, evaluateCallback);\r\n        } else {\r\n            query = query.replace(/\\([^()]*\\)/g, (r) => {\r\n                // remove parenthesis\r\n                r = r.slice(1, r.length - 1);\r\n                return AndOrNotEvaluator._HandleParenthesisContent(r, evaluateCallback);\r\n            });\r\n        }\r\n\r\n        if (query === \"true\") {\r\n            return true;\r\n        }\r\n\r\n        if (query === \"false\") {\r\n            return false;\r\n        }\r\n\r\n        return AndOrNotEvaluator.Eval(query, evaluateCallback);\r\n    }\r\n\r\n    private static _HandleParenthesisContent(parenthesisContent: string, evaluateCallback: (val: string) => boolean): string {\r\n        evaluateCallback =\r\n            evaluateCallback ||\r\n            ((r) => {\r\n                return r === \"true\" ? true : false;\r\n            });\r\n\r\n        let result;\r\n        const or = parenthesisContent.split(\"||\");\r\n\r\n        for (const i in or) {\r\n            if (Object.prototype.hasOwnProperty.call(or, i)) {\r\n                let ori = AndOrNotEvaluator._SimplifyNegation(or[i].trim());\r\n                const and = ori.split(\"&&\");\r\n\r\n                if (and.length > 1) {\r\n                    for (let j = 0; j < and.length; ++j) {\r\n                        const andj = AndOrNotEvaluator._SimplifyNegation(and[j].trim());\r\n                        if (andj !== \"true\" && andj !== \"false\") {\r\n                            if (andj[0] === \"!\") {\r\n                                result = !evaluateCallback(andj.substring(1));\r\n                            } else {\r\n                                result = evaluateCallback(andj);\r\n                            }\r\n                        } else {\r\n                            result = andj === \"true\" ? true : false;\r\n                        }\r\n                        if (!result) {\r\n                            // no need to continue since 'false && ... && ...' will always return false\r\n                            ori = \"false\";\r\n                            break;\r\n                        }\r\n                    }\r\n                }\r\n\r\n                if (result || ori === \"true\") {\r\n                    // no need to continue since 'true || ... || ...' will always return true\r\n                    result = true;\r\n                    break;\r\n                }\r\n\r\n                // result equals false (or undefined)\r\n\r\n                if (ori !== \"true\" && ori !== \"false\") {\r\n                    if (ori[0] === \"!\") {\r\n                        result = !evaluateCallback(ori.substring(1));\r\n                    } else {\r\n                        result = evaluateCallback(ori);\r\n                    }\r\n                } else {\r\n                    result = ori === \"true\" ? true : false;\r\n                }\r\n            }\r\n        }\r\n\r\n        // the whole parenthesis scope is replaced by 'true' or 'false'\r\n        return result ? \"true\" : \"false\";\r\n    }\r\n\r\n    private static _SimplifyNegation(booleanString: string): string {\r\n        booleanString = booleanString.replace(/^[\\s!]+/, (r) => {\r\n            // remove whitespaces\r\n            r = r.replace(/[\\s]/g, () => \"\");\r\n            return r.length % 2 ? \"!\" : \"\";\r\n        });\r\n\r\n        booleanString = booleanString.trim();\r\n\r\n        if (booleanString === \"!true\") {\r\n            booleanString = \"false\";\r\n        } else if (booleanString === \"!false\") {\r\n            booleanString = \"true\";\r\n        }\r\n\r\n        return booleanString;\r\n    }\r\n}\r\n", "import { AndOrNotEvaluator } from \"./andOrNotEvaluator\";\r\n\r\n/**\r\n * Class used to store custom tags\r\n */\r\nexport class Tags {\r\n    /**\r\n     * Adds support for tags on the given object\r\n     * @param obj defines the object to use\r\n     */\r\n    public static EnableFor(obj: any): void {\r\n        obj._tags = obj._tags || {};\r\n\r\n        obj.hasTags = () => {\r\n            return Tags.HasTags(obj);\r\n        };\r\n\r\n        obj.addTags = (tagsString: string) => {\r\n            return Tags.AddTagsTo(obj, tagsString);\r\n        };\r\n\r\n        obj.removeTags = (tagsString: string) => {\r\n            return Tags.RemoveTagsFrom(obj, tagsString);\r\n        };\r\n\r\n        obj.matchesTagsQuery = (tagsQuery: string) => {\r\n            return Tags.MatchesQuery(obj, tagsQuery);\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Removes tags support\r\n     * @param obj defines the object to use\r\n     */\r\n    public static DisableFor(obj: any): void {\r\n        delete obj._tags;\r\n        delete obj.hasTags;\r\n        delete obj.addTags;\r\n        delete obj.removeTags;\r\n        delete obj.matchesTagsQuery;\r\n    }\r\n\r\n    /**\r\n     * Gets a boolean indicating if the given object has tags\r\n     * @param obj defines the object to use\r\n     * @returns a boolean\r\n     */\r\n    public static HasTags(obj: any): boolean {\r\n        if (!obj._tags) {\r\n            return false;\r\n        }\r\n\r\n        const tags = obj._tags;\r\n        for (const i in tags) {\r\n            if (Object.prototype.hasOwnProperty.call(tags, i)) {\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Gets the tags available on a given object\r\n     * @param obj defines the object to use\r\n     * @param asString defines if the tags must be returned as a string instead of an array of strings\r\n     * @returns the tags\r\n     */\r\n    public static GetTags(obj: any, asString: boolean = true): any {\r\n        if (!obj._tags) {\r\n            return null;\r\n        }\r\n        if (asString) {\r\n            const tagsArray = [];\r\n            for (const tag in obj._tags) {\r\n                if (Object.prototype.hasOwnProperty.call(obj._tags, tag) && obj._tags[tag] === true) {\r\n                    tagsArray.push(tag);\r\n                }\r\n            }\r\n            return tagsArray.join(\" \");\r\n        } else {\r\n            return obj._tags;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Adds tags to an object\r\n     * @param obj defines the object to use\r\n     * @param tagsString defines the tag string. The tags 'true' and 'false' are reserved and cannot be used as tags.\r\n     * A tag cannot start with '||', '&&', and '!'. It cannot contain whitespaces\r\n     */\r\n    public static AddTagsTo(obj: any, tagsString: string): void {\r\n        if (!tagsString) {\r\n            return;\r\n        }\r\n\r\n        if (typeof tagsString !== \"string\") {\r\n            return;\r\n        }\r\n\r\n        const tags = tagsString.split(\" \");\r\n        tags.forEach(function (tag) {\r\n            Tags._AddTagTo(obj, tag);\r\n        });\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public static _AddTagTo(obj: any, tag: string): void {\r\n        tag = tag.trim();\r\n\r\n        if (tag === \"\" || tag === \"true\" || tag === \"false\") {\r\n            return;\r\n        }\r\n\r\n        if (tag.match(/[\\s]/) || tag.match(/^([!]|([|]|[&]){2})/)) {\r\n            return;\r\n        }\r\n\r\n        Tags.EnableFor(obj);\r\n        obj._tags[tag] = true;\r\n    }\r\n\r\n    /**\r\n     * Removes specific tags from a specific object\r\n     * @param obj defines the object to use\r\n     * @param tagsString defines the tags to remove\r\n     */\r\n    public static RemoveTagsFrom(obj: any, tagsString: string) {\r\n        if (!Tags.HasTags(obj)) {\r\n            return;\r\n        }\r\n        const tags = tagsString.split(\" \");\r\n        for (const t in tags) {\r\n            Tags._RemoveTagFrom(obj, tags[t]);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public static _RemoveTagFrom(obj: any, tag: string): void {\r\n        delete obj._tags[tag];\r\n    }\r\n\r\n    /**\r\n     * Defines if tags hosted on an object match a given query\r\n     * @param obj defines the object to use\r\n     * @param tagsQuery defines the tag query\r\n     * @returns a boolean\r\n     */\r\n    public static MatchesQuery(obj: any, tagsQuery: string): boolean {\r\n        if (tagsQuery === undefined) {\r\n            return true;\r\n        }\r\n\r\n        if (tagsQuery === \"\") {\r\n            return Tags.HasTags(obj);\r\n        }\r\n\r\n        return AndOrNotEvaluator.Eval(tagsQuery, (r) => Tags.HasTags(obj) && obj._tags[r]);\r\n    }\r\n}\r\n", "import type { FresnelParameters } from \"../Materials/fresnelParameters\";\r\nimport type { ImageProcessingConfiguration } from \"../Materials/imageProcessingConfiguration\";\r\nimport { _WarnImport } from \"./devTools\";\r\nimport type { ColorCurves } from \"../Materials/colorCurves\";\r\nimport type { Scene } from \"../scene\";\r\nimport type { Nullable } from \"../types\";\r\nimport type { BaseTexture } from \"../Materials/Textures/baseTexture\";\r\nimport type { IAnimatable } from \"../Animations/animatable.interface\";\r\nimport { Tags } from \"./tags\";\r\nimport { Color3, Color4 } from \"../Maths/math.color\";\r\nimport { Matrix, Quaternion, Vector2, Vector3 } from \"../Maths/math.vector\";\r\nimport type { Camera } from \"../Cameras/camera\";\r\nimport { GetMergedStore } from \"./decorators.functions\";\r\n\r\n/** @internal */\r\nexport interface CopySourceOptions {\r\n    /*\r\n     * if a texture is used in more than one channel (e.g diffuse and opacity),\r\n     * only clone it once and reuse it on the other channels. Default false\r\n     */\r\n    cloneTexturesOnlyOnce?: boolean;\r\n}\r\n\r\nconst _copySource = function <T>(creationFunction: () => T, source: T, instanciate: boolean, options: CopySourceOptions = {}): T {\r\n    const destination = creationFunction();\r\n\r\n    // Tags\r\n    if (Tags && Tags.HasTags(source)) {\r\n        Tags.AddTagsTo(destination, Tags.GetTags(source, true));\r\n    }\r\n\r\n    const classStore = GetMergedStore(destination);\r\n\r\n    // Map from source texture uniqueId to destination texture\r\n    const textureMap: Record<number, any> = {};\r\n\r\n    // Properties\r\n    for (const property in classStore) {\r\n        const propertyDescriptor = classStore[property];\r\n        const sourceProperty = (<any>source)[property];\r\n        const propertyType = propertyDescriptor.type;\r\n\r\n        if (sourceProperty !== undefined && sourceProperty !== null && (property !== \"uniqueId\" || SerializationHelper.AllowLoadingUniqueId)) {\r\n            switch (propertyType) {\r\n                case 0: // Value\r\n                case 6: // Mesh reference\r\n                case 9: // Image processing configuration reference\r\n                case 11: // Camera reference\r\n                    (<any>destination)[property] = sourceProperty;\r\n                    break;\r\n                case 1: // Texture\r\n                    if (options.cloneTexturesOnlyOnce && textureMap[sourceProperty.uniqueId]) {\r\n                        (<any>destination)[property] = textureMap[sourceProperty.uniqueId];\r\n                    } else {\r\n                        (<any>destination)[property] = instanciate || sourceProperty.isRenderTarget ? sourceProperty : sourceProperty.clone();\r\n                        textureMap[sourceProperty.uniqueId] = (<any>destination)[property];\r\n                    }\r\n                    break;\r\n                case 2: // Color3\r\n                case 3: // FresnelParameters\r\n                case 4: // Vector2\r\n                case 5: // Vector3\r\n                case 7: // Color Curves\r\n                case 8: // Color 4\r\n                case 10: // Quaternion\r\n                case 12: // Matrix\r\n                    (<any>destination)[property] = instanciate ? sourceProperty : sourceProperty.clone();\r\n                    break;\r\n            }\r\n        }\r\n    }\r\n\r\n    return destination;\r\n};\r\n\r\n/**\r\n * Class used to help serialization objects\r\n */\r\nexport class SerializationHelper {\r\n    /**\r\n     * Gets or sets a boolean to indicate if the UniqueId property should be serialized\r\n     */\r\n    public static AllowLoadingUniqueId = false;\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public static _ImageProcessingConfigurationParser = (sourceProperty: any): ImageProcessingConfiguration => {\r\n        throw _WarnImport(\"ImageProcessingConfiguration\");\r\n    };\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public static _FresnelParametersParser = (sourceProperty: any): FresnelParameters => {\r\n        throw _WarnImport(\"FresnelParameters\");\r\n    };\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public static _ColorCurvesParser = (sourceProperty: any): ColorCurves => {\r\n        throw _WarnImport(\"ColorCurves\");\r\n    };\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public static _TextureParser = (sourceProperty: any, scene: Scene, rootUrl: string): Nullable<BaseTexture> => {\r\n        throw _WarnImport(\"Texture\");\r\n    };\r\n\r\n    /**\r\n     * Appends the serialized animations from the source animations\r\n     * @param source Source containing the animations\r\n     * @param destination Target to store the animations\r\n     */\r\n    public static AppendSerializedAnimations(source: IAnimatable, destination: any): void {\r\n        if (source.animations) {\r\n            destination.animations = [];\r\n            for (let animationIndex = 0; animationIndex < source.animations.length; animationIndex++) {\r\n                const animation = source.animations[animationIndex];\r\n\r\n                destination.animations.push(animation.serialize());\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Static function used to serialized a specific entity\r\n     * @param entity defines the entity to serialize\r\n     * @param serializationObject defines the optional target object where serialization data will be stored\r\n     * @returns a JSON compatible object representing the serialization of the entity\r\n     */\r\n    public static Serialize<T>(entity: T, serializationObject?: any): any {\r\n        if (!serializationObject) {\r\n            serializationObject = {};\r\n        }\r\n\r\n        // Tags\r\n        if (Tags) {\r\n            serializationObject.tags = Tags.GetTags(entity);\r\n        }\r\n\r\n        const serializedProperties = GetMergedStore(entity);\r\n\r\n        // Properties\r\n        for (const property in serializedProperties) {\r\n            const propertyDescriptor = serializedProperties[property];\r\n            const targetPropertyName = propertyDescriptor.sourceName || property;\r\n            const propertyType = propertyDescriptor.type;\r\n            const sourceProperty = (<any>entity)[property];\r\n\r\n            if (sourceProperty !== undefined && sourceProperty !== null && (property !== \"uniqueId\" || SerializationHelper.AllowLoadingUniqueId)) {\r\n                switch (propertyType) {\r\n                    case 0: // Value\r\n                        serializationObject[targetPropertyName] = sourceProperty;\r\n                        break;\r\n                    case 1: // Texture\r\n                        serializationObject[targetPropertyName] = sourceProperty.serialize();\r\n                        break;\r\n                    case 2: // Color3\r\n                        serializationObject[targetPropertyName] = sourceProperty.asArray();\r\n                        break;\r\n                    case 3: // FresnelParameters\r\n                        serializationObject[targetPropertyName] = sourceProperty.serialize();\r\n                        break;\r\n                    case 4: // Vector2\r\n                        serializationObject[targetPropertyName] = sourceProperty.asArray();\r\n                        break;\r\n                    case 5: // Vector3\r\n                        serializationObject[targetPropertyName] = sourceProperty.asArray();\r\n                        break;\r\n                    case 6: // Mesh reference\r\n                        serializationObject[targetPropertyName] = sourceProperty.id;\r\n                        break;\r\n                    case 7: // Color Curves\r\n                        serializationObject[targetPropertyName] = sourceProperty.serialize();\r\n                        break;\r\n                    case 8: // Color 4\r\n                        serializationObject[targetPropertyName] = (<Color4>sourceProperty).asArray();\r\n                        break;\r\n                    case 9: // Image Processing\r\n                        serializationObject[targetPropertyName] = (<ImageProcessingConfiguration>sourceProperty).serialize();\r\n                        break;\r\n                    case 10: // Quaternion\r\n                        serializationObject[targetPropertyName] = (<Quaternion>sourceProperty).asArray();\r\n                        break;\r\n                    case 11: // Camera reference\r\n                        serializationObject[targetPropertyName] = (<Camera>sourceProperty).id;\r\n                        break;\r\n                    case 12: // Matrix\r\n                        serializationObject[targetPropertyName] = (<Matrix>sourceProperty).asArray();\r\n                        break;\r\n                }\r\n            }\r\n        }\r\n\r\n        return serializationObject;\r\n    }\r\n\r\n    /**\r\n     * Given a source json and a destination object in a scene, this function will parse the source and will try to apply its content to the destination object\r\n     * @param source the source json data\r\n     * @param destination the destination object\r\n     * @param scene the scene where the object is\r\n     * @param rootUrl root url to use to load assets\r\n     */\r\n    public static ParseProperties(source: any, destination: any, scene: Nullable<Scene>, rootUrl: Nullable<string>) {\r\n        if (!rootUrl) {\r\n            rootUrl = \"\";\r\n        }\r\n\r\n        const classStore = GetMergedStore(destination);\r\n\r\n        // Properties\r\n        for (const property in classStore) {\r\n            const propertyDescriptor = classStore[property];\r\n            const sourceProperty = source[propertyDescriptor.sourceName || property];\r\n            const propertyType = propertyDescriptor.type;\r\n\r\n            if (sourceProperty !== undefined && sourceProperty !== null && (property !== \"uniqueId\" || SerializationHelper.AllowLoadingUniqueId)) {\r\n                const dest = <any>destination;\r\n                switch (propertyType) {\r\n                    case 0: // Value\r\n                        dest[property] = sourceProperty;\r\n                        break;\r\n                    case 1: // Texture\r\n                        if (scene) {\r\n                            dest[property] = SerializationHelper._TextureParser(sourceProperty, scene, rootUrl);\r\n                        }\r\n                        break;\r\n                    case 2: // Color3\r\n                        dest[property] = Color3.FromArray(sourceProperty);\r\n                        break;\r\n                    case 3: // FresnelParameters\r\n                        dest[property] = SerializationHelper._FresnelParametersParser(sourceProperty);\r\n                        break;\r\n                    case 4: // Vector2\r\n                        dest[property] = Vector2.FromArray(sourceProperty);\r\n                        break;\r\n                    case 5: // Vector3\r\n                        dest[property] = Vector3.FromArray(sourceProperty);\r\n                        break;\r\n                    case 6: // Mesh reference\r\n                        if (scene) {\r\n                            dest[property] = scene.getLastMeshById(sourceProperty);\r\n                        }\r\n                        break;\r\n                    case 7: // Color Curves\r\n                        dest[property] = SerializationHelper._ColorCurvesParser(sourceProperty);\r\n                        break;\r\n                    case 8: // Color 4\r\n                        dest[property] = Color4.FromArray(sourceProperty);\r\n                        break;\r\n                    case 9: // Image Processing\r\n                        dest[property] = SerializationHelper._ImageProcessingConfigurationParser(sourceProperty);\r\n                        break;\r\n                    case 10: // Quaternion\r\n                        dest[property] = Quaternion.FromArray(sourceProperty);\r\n                        break;\r\n                    case 11: // Camera reference\r\n                        if (scene) {\r\n                            dest[property] = scene.getCameraById(sourceProperty);\r\n                        }\r\n                        break;\r\n                    case 12: // Matrix\r\n                        dest[property] = Matrix.FromArray(sourceProperty);\r\n                        break;\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Creates a new entity from a serialization data object\r\n     * @param creationFunction defines a function used to instanciated the new entity\r\n     * @param source defines the source serialization data\r\n     * @param scene defines the hosting scene\r\n     * @param rootUrl defines the root url for resources\r\n     * @returns a new entity\r\n     */\r\n    public static Parse<T>(creationFunction: () => T, source: any, scene: Nullable<Scene>, rootUrl: Nullable<string> = null): T {\r\n        const destination = creationFunction();\r\n\r\n        // Tags\r\n        if (Tags) {\r\n            Tags.AddTagsTo(destination, source.tags);\r\n        }\r\n\r\n        SerializationHelper.ParseProperties(source, destination, scene, rootUrl);\r\n\r\n        return destination;\r\n    }\r\n\r\n    /**\r\n     * Clones an object\r\n     * @param creationFunction defines the function used to instanciate the new object\r\n     * @param source defines the source object\r\n     * @param options defines the options to use\r\n     * @returns the cloned object\r\n     */\r\n    public static Clone<T>(creationFunction: () => T, source: T, options: CopySourceOptions = {}): T {\r\n        return _copySource(creationFunction, source, false, options);\r\n    }\r\n\r\n    /**\r\n     * Instanciates a new object based on a source one (some data will be shared between both object)\r\n     * @param creationFunction defines the function used to instanciate the new object\r\n     * @param source defines the source object\r\n     * @returns the new object\r\n     */\r\n    public static Instanciate<T>(creationFunction: () => T, source: T): T {\r\n        return _copySource(creationFunction, source, true);\r\n    }\r\n}\r\n", "import type { DeepImmutable } from \"../types\";\r\nimport { Vector3, Matrix } from \"./math.vector\";\r\nimport type { IPlaneLike } from \"./math.like\";\r\n\r\n/**\r\n * Represents a plane by the equation ax + by + cz + d = 0\r\n */\r\nexport class Plane implements IPlaneLike {\r\n    private static _TmpMatrix = Matrix.Identity();\r\n\r\n    /**\r\n     * Normal of the plane (a,b,c)\r\n     */\r\n    public normal: Vector3;\r\n    /**\r\n     * d component of the plane\r\n     */\r\n    public d: number;\r\n    /**\r\n     * Creates a Plane object according to the given floats a, b, c, d and the plane equation : ax + by + cz + d = 0\r\n     * @param a a component of the plane\r\n     * @param b b component of the plane\r\n     * @param c c component of the plane\r\n     * @param d d component of the plane\r\n     */\r\n    constructor(a: number, b: number, c: number, d: number) {\r\n        this.normal = new Vector3(a, b, c);\r\n        this.d = d;\r\n    }\r\n\r\n    /**\r\n     * @returns the plane coordinates as a new array of 4 elements [a, b, c, d].\r\n     */\r\n    public asArray(): number[] {\r\n        return [this.normal.x, this.normal.y, this.normal.z, this.d];\r\n    }\r\n\r\n    // Methods\r\n    /**\r\n     * @returns a new plane copied from the current Plane.\r\n     */\r\n    public clone(): Plane {\r\n        return new Plane(this.normal.x, this.normal.y, this.normal.z, this.d);\r\n    }\r\n    /**\r\n     * @returns the string \"Plane\".\r\n     */\r\n    public getClassName(): string {\r\n        return \"Plane\";\r\n    }\r\n    /**\r\n     * @returns the Plane hash code.\r\n     */\r\n    public getHashCode(): number {\r\n        let hash = this.normal.getHashCode();\r\n        hash = (hash * 397) ^ (this.d | 0);\r\n        return hash;\r\n    }\r\n    /**\r\n     * Normalize the current Plane in place.\r\n     * @returns the updated Plane.\r\n     */\r\n    public normalize(): Plane {\r\n        const norm = Math.sqrt(this.normal.x * this.normal.x + this.normal.y * this.normal.y + this.normal.z * this.normal.z);\r\n        let magnitude = 0.0;\r\n\r\n        if (norm !== 0) {\r\n            magnitude = 1.0 / norm;\r\n        }\r\n        this.normal.x *= magnitude;\r\n        this.normal.y *= magnitude;\r\n        this.normal.z *= magnitude;\r\n        this.d *= magnitude;\r\n        return this;\r\n    }\r\n    /**\r\n     * Applies a transformation the plane and returns the result\r\n     * @param transformation the transformation matrix to be applied to the plane\r\n     * @returns a new Plane as the result of the transformation of the current Plane by the given matrix.\r\n     */\r\n    public transform(transformation: DeepImmutable<Matrix>): Plane {\r\n        const invertedMatrix = Plane._TmpMatrix;\r\n        transformation.invertToRef(invertedMatrix);\r\n        const m = invertedMatrix.m;\r\n        const x = this.normal.x;\r\n        const y = this.normal.y;\r\n        const z = this.normal.z;\r\n        const d = this.d;\r\n\r\n        const normalX = x * m[0] + y * m[1] + z * m[2] + d * m[3];\r\n        const normalY = x * m[4] + y * m[5] + z * m[6] + d * m[7];\r\n        const normalZ = x * m[8] + y * m[9] + z * m[10] + d * m[11];\r\n        const finalD = x * m[12] + y * m[13] + z * m[14] + d * m[15];\r\n\r\n        return new Plane(normalX, normalY, normalZ, finalD);\r\n    }\r\n\r\n    /**\r\n     * Compute the dot product between the point and the plane normal\r\n     * @param point point to calculate the dot product with\r\n     * @returns the dot product (float) of the point coordinates and the plane normal.\r\n     */\r\n    public dotCoordinate(point: DeepImmutable<Vector3>): number {\r\n        return this.normal.x * point.x + this.normal.y * point.y + this.normal.z * point.z + this.d;\r\n    }\r\n\r\n    /**\r\n     * Updates the current Plane from the plane defined by the three given points.\r\n     * @param point1 one of the points used to construct the plane\r\n     * @param point2 one of the points used to construct the plane\r\n     * @param point3 one of the points used to construct the plane\r\n     * @returns the updated Plane.\r\n     */\r\n    public copyFromPoints(point1: DeepImmutable<Vector3>, point2: DeepImmutable<Vector3>, point3: DeepImmutable<Vector3>): Plane {\r\n        const x1 = point2.x - point1.x;\r\n        const y1 = point2.y - point1.y;\r\n        const z1 = point2.z - point1.z;\r\n        const x2 = point3.x - point1.x;\r\n        const y2 = point3.y - point1.y;\r\n        const z2 = point3.z - point1.z;\r\n        const yz = y1 * z2 - z1 * y2;\r\n        const xz = z1 * x2 - x1 * z2;\r\n        const xy = x1 * y2 - y1 * x2;\r\n        const pyth = Math.sqrt(yz * yz + xz * xz + xy * xy);\r\n        let invPyth;\r\n\r\n        if (pyth !== 0) {\r\n            invPyth = 1.0 / pyth;\r\n        } else {\r\n            invPyth = 0.0;\r\n        }\r\n\r\n        this.normal.x = yz * invPyth;\r\n        this.normal.y = xz * invPyth;\r\n        this.normal.z = xy * invPyth;\r\n        this.d = -(this.normal.x * point1.x + this.normal.y * point1.y + this.normal.z * point1.z);\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Checks if the plane is facing a given direction (meaning if the plane's normal is pointing in the opposite direction of the given vector).\r\n     * Note that for this function to work as expected you should make sure that:\r\n     *   - direction and the plane normal are normalized\r\n     *   - epsilon is a number just bigger than -1, something like -0.99 for eg\r\n     * @param direction the direction to check if the plane is facing\r\n     * @param epsilon value the dot product is compared against (returns true if dot <= epsilon)\r\n     * @returns True if the plane is facing the given direction\r\n     */\r\n    public isFrontFacingTo(direction: DeepImmutable<Vector3>, epsilon: number): boolean {\r\n        const dot = Vector3.Dot(this.normal, direction);\r\n        return dot <= epsilon;\r\n    }\r\n\r\n    /**\r\n     * Calculates the distance to a point\r\n     * @param point point to calculate distance to\r\n     * @returns the signed distance (float) from the given point to the Plane.\r\n     */\r\n    public signedDistanceTo(point: DeepImmutable<Vector3>): number {\r\n        return Vector3.Dot(point, this.normal) + this.d;\r\n    }\r\n\r\n    // Statics\r\n    /**\r\n     * Creates a plane from an  array\r\n     * @param array the array to create a plane from\r\n     * @returns a new Plane from the given array.\r\n     */\r\n    static FromArray(array: DeepImmutable<ArrayLike<number>>): Plane {\r\n        return new Plane(array[0], array[1], array[2], array[3]);\r\n    }\r\n    /**\r\n     * Creates a plane from three points\r\n     * @param point1 point used to create the plane\r\n     * @param point2 point used to create the plane\r\n     * @param point3 point used to create the plane\r\n     * @returns a new Plane defined by the three given points.\r\n     */\r\n    static FromPoints(point1: DeepImmutable<Vector3>, point2: DeepImmutable<Vector3>, point3: DeepImmutable<Vector3>): Plane {\r\n        const result = new Plane(0.0, 0.0, 0.0, 0.0);\r\n        result.copyFromPoints(point1, point2, point3);\r\n        return result;\r\n    }\r\n    /**\r\n     * Creates a plane from an origin point and a normal\r\n     * @param origin origin of the plane to be constructed\r\n     * @param normal normal of the plane to be constructed\r\n     * @returns a new Plane the normal vector to this plane at the given origin point.\r\n     */\r\n    static FromPositionAndNormal(origin: DeepImmutable<Vector3>, normal: Vector3): Plane {\r\n        const plane = new Plane(0.0, 0.0, 0.0, 0.0);\r\n        return this.FromPositionAndNormalToRef(origin, normal, plane);\r\n    }\r\n\r\n    /**\r\n     * Updates the given Plane \"result\" from an origin point and a normal.\r\n     * @param origin origin of the plane to be constructed\r\n     * @param normal the normalized normals of the plane to be constructed\r\n     * @param result defines the Plane where to store the result\r\n     * @returns result input\r\n     */\r\n    static FromPositionAndNormalToRef<T extends Plane>(origin: DeepImmutable<Vector3>, normal: DeepImmutable<Vector3>, result: T): T {\r\n        result.normal.copyFrom(normal);\r\n        result.normal.normalize();\r\n        result.d = -origin.dot(result.normal);\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Calculates the distance from a plane and a point\r\n     * @param origin origin of the plane to be constructed\r\n     * @param normal normal of the plane to be constructed\r\n     * @param point point to calculate distance to\r\n     * @returns the signed distance between the plane defined by the normal vector at the \"origin\"\" point and the given other point.\r\n     */\r\n    static SignedDistanceToPlaneFromPositionAndNormal(origin: DeepImmutable<Vector3>, normal: DeepImmutable<Vector3>, point: DeepImmutable<Vector3>): number {\r\n        const d = -(normal.x * origin.x + normal.y * origin.y + normal.z * origin.z);\r\n        return Vector3.Dot(point, normal) + d;\r\n    }\r\n}\r\n"],
  "mappings": "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",
  "names": []
}
