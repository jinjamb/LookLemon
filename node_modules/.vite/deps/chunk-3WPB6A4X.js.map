{
  "version": 3,
  "sources": ["../../../dev/core/src/Physics/castingResult.ts", "../../../dev/core/src/Physics/physicsRaycastResult.ts", "../../../dev/core/src/Physics/v2/physicsEngine.ts", "../../../dev/core/src/Physics/v2/physicsBody.ts", "../../../dev/core/src/Physics/v2/physicsConstraint.ts", "../../../dev/core/src/Physics/v2/physicsMaterial.ts", "../../../dev/core/src/Physics/v2/physicsAggregate.ts", "../../../dev/core/src/Physics/v2/ragdoll.ts", "../../../dev/core/src/Physics/v2/characterController.ts"],
  "sourcesContent": ["import { Vector3 } from \"../Maths/math.vector\";\r\nimport type { PhysicsShape } from \"./v2/physicsShape\";\r\nimport type { PhysicsBody } from \"./v2/physicsBody\";\r\n\r\n/**\r\n * Base class for results of casts.\r\n */\r\nexport class CastingResult {\r\n    private _hasHit: boolean = false;\r\n    protected _hitNormal: Vector3 = Vector3.Zero();\r\n    protected _hitPoint: Vector3 = Vector3.Zero();\r\n    private _triangleIndex: number = -1;\r\n\r\n    /**\r\n     * The Physics body that the query hit.\r\n     */\r\n    public body?: PhysicsBody;\r\n    /**\r\n     * The body Index in case the Physics body is using instances\r\n     */\r\n    public bodyIndex?: number;\r\n\r\n    /**\r\n     * The shape hit by the query.\r\n     */\r\n    public shape?: PhysicsShape;\r\n\r\n    /**\r\n     * Gets the hit point.\r\n     */\r\n    get hitPoint(): Vector3 {\r\n        return this._hitPoint;\r\n    }\r\n    /**\r\n     * Gets the hit normal.\r\n     */\r\n    get hitNormal(): Vector3 {\r\n        return this._hitNormal;\r\n    }\r\n    /**\r\n     * Gets if there was a hit\r\n     */\r\n    get hasHit(): boolean {\r\n        return this._hasHit;\r\n    }\r\n\r\n    /*\r\n     * The index of the original triangle which was hit. Will be -1 if contact point is not on a mesh shape\r\n     */\r\n    get triangleIndex(): number {\r\n        return this._triangleIndex;\r\n    }\r\n\r\n    /**\r\n     * Sets the hit data\r\n     * @param hitNormal defines the normal in world space\r\n     * @param hitPoint defines the point in world space\r\n     * @param triangleIndex defines the index of the triangle in case of mesh shape\r\n     */\r\n    public setHitData(hitNormal: IXYZ, hitPoint: IXYZ, triangleIndex?: number) {\r\n        this._hasHit = true;\r\n        this._hitNormal.set(hitNormal.x, hitNormal.y, hitNormal.z);\r\n        this._hitPoint.set(hitPoint.x, hitPoint.y, hitPoint.z);\r\n        this._triangleIndex = triangleIndex ?? -1;\r\n    }\r\n\r\n    /**\r\n     * Resets all the values to default\r\n     */\r\n    public reset() {\r\n        this._hasHit = false;\r\n\r\n        this._hitNormal.setAll(0);\r\n        this._hitPoint.setAll(0);\r\n        this._triangleIndex = -1;\r\n\r\n        this.body = undefined;\r\n        this.bodyIndex = undefined;\r\n\r\n        this.shape = undefined;\r\n    }\r\n}\r\n\r\n/**\r\n * Interface for the size containing width and height\r\n */\r\ninterface IXYZ {\r\n    /**\r\n     * X\r\n     */\r\n    x: number;\r\n\r\n    /**\r\n     * Y\r\n     */\r\n    y: number;\r\n\r\n    /**\r\n     * Z\r\n     */\r\n    z: number;\r\n}\r\n", "import { Vector3 } from \"../Maths/math.vector\";\r\nimport { CastingResult } from \"./castingResult\";\r\n\r\n/**\r\n * Interface for query parameters in the raycast function.\r\n * @see the \"Collision Filtering\" section in https://github.com/eoineoineoin/glTF/tree/MSFT_RigidBodies/extensions/2.0/Vendor/MSFT_collision_primitives\r\n */\r\nexport interface IRaycastQuery {\r\n    /** Membership mask */\r\n    membership?: number;\r\n    /** CollideWith mask */\r\n    collideWith?: number;\r\n    /** Should trigger collisions be considered in the query? */\r\n    shouldHitTriggers?: boolean;\r\n}\r\n\r\n/**\r\n * Holds the data for the raycast result\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/physics/usingPhysicsEngine\r\n */\r\nexport class PhysicsRaycastResult extends CastingResult {\r\n    private _hitDistance: number = 0;\r\n    private _rayFromWorld: Vector3 = Vector3.Zero();\r\n    private _rayToWorld: Vector3 = Vector3.Zero();\r\n\r\n    /**\r\n     * Gets the distance from the hit\r\n     */\r\n    get hitDistance(): number {\r\n        return this._hitDistance;\r\n    }\r\n\r\n    /**\r\n     * Gets the hit normal/direction in the world\r\n     */\r\n    get hitNormalWorld(): Vector3 {\r\n        return this._hitNormal;\r\n    }\r\n\r\n    /**\r\n     * Gets the hit point in the world\r\n     */\r\n    get hitPointWorld(): Vector3 {\r\n        return this._hitPoint;\r\n    }\r\n\r\n    /**\r\n     * Gets the ray \"start point\" of the ray in the world\r\n     */\r\n    get rayFromWorld(): Vector3 {\r\n        return this._rayFromWorld;\r\n    }\r\n\r\n    /**\r\n     * Gets the ray \"end point\" of the ray in the world\r\n     */\r\n    get rayToWorld(): Vector3 {\r\n        return this._rayToWorld;\r\n    }\r\n\r\n    /**\r\n     * Sets the distance from the start point to the hit point\r\n     * @param distance defines the distance to set\r\n     */\r\n    public setHitDistance(distance: number) {\r\n        this._hitDistance = distance;\r\n    }\r\n\r\n    /**\r\n     * Calculates the distance manually\r\n     */\r\n    public calculateHitDistance() {\r\n        this._hitDistance = Vector3.Distance(this._rayFromWorld, this._hitPoint);\r\n    }\r\n\r\n    /**\r\n     * Resets all the values to default\r\n     * @param from The from point on world space\r\n     * @param to The to point on world space\r\n     */\r\n    public override reset(from: Vector3 = Vector3.Zero(), to: Vector3 = Vector3.Zero()) {\r\n        super.reset();\r\n        this._rayFromWorld.copyFrom(from);\r\n        this._rayToWorld.copyFrom(to);\r\n\r\n        this._hitDistance = 0;\r\n    }\r\n}\r\n", "import type { Nullable } from \"../../types\";\r\nimport { Vector3 } from \"../../Maths/math.vector\";\r\nimport type { IPhysicsEngine } from \"../IPhysicsEngine\";\r\nimport type { IPhysicsEnginePluginV2 } from \"./IPhysicsEnginePlugin\";\r\nimport type { IRaycastQuery } from \"../physicsRaycastResult\";\r\nimport { PhysicsRaycastResult } from \"../physicsRaycastResult\";\r\nimport { _WarnImport } from \"../../Misc/devTools\";\r\nimport type { PhysicsBody } from \"./physicsBody\";\r\n\r\n/**\r\n * Class used to control physics engine\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/physics/usingPhysicsEngine\r\n */\r\nexport class PhysicsEngine implements IPhysicsEngine {\r\n    /** @internal */\r\n    private _physicsBodies: Array<PhysicsBody> = [];\r\n    private _subTimeStep: number = 0;\r\n\r\n    /**\r\n     * Gets the gravity vector used by the simulation\r\n     */\r\n    public gravity: Vector3;\r\n\r\n    /**\r\n     *\r\n     * @returns physics plugin version\r\n     */\r\n    public getPluginVersion(): number {\r\n        return this._physicsPlugin.getPluginVersion();\r\n    }\r\n    // eslint-disable-next-line jsdoc/require-returns-check\r\n    /**\r\n     * Factory used to create the default physics plugin.\r\n     * @returns The default physics plugin\r\n     */\r\n    public static DefaultPluginFactory(): IPhysicsEnginePluginV2 {\r\n        throw _WarnImport(\"\");\r\n    }\r\n\r\n    /**\r\n     * Creates a new Physics Engine\r\n     * @param gravity defines the gravity vector used by the simulation\r\n     * @param _physicsPlugin defines the plugin to use (CannonJS by default)\r\n     */\r\n    constructor(\r\n        gravity: Nullable<Vector3>,\r\n        private _physicsPlugin: IPhysicsEnginePluginV2 = PhysicsEngine.DefaultPluginFactory()\r\n    ) {\r\n        gravity = gravity || new Vector3(0, -9.807, 0);\r\n        this.setGravity(gravity);\r\n        this.setTimeStep();\r\n    }\r\n\r\n    /**\r\n     * Sets the gravity vector used by the simulation\r\n     * @param gravity defines the gravity vector to use\r\n     */\r\n    public setGravity(gravity: Vector3): void {\r\n        this.gravity = gravity;\r\n        this._physicsPlugin.setGravity(this.gravity);\r\n    }\r\n\r\n    /**\r\n     * Set the time step of the physics engine.\r\n     * Default is 1/60.\r\n     * To slow it down, enter 1/600 for example.\r\n     * To speed it up, 1/30\r\n     * Unit is seconds.\r\n     * @param newTimeStep defines the new timestep to apply to this world.\r\n     */\r\n    public setTimeStep(newTimeStep: number = 1 / 60) {\r\n        this._physicsPlugin.setTimeStep(newTimeStep);\r\n    }\r\n\r\n    /**\r\n     * Get the time step of the physics engine.\r\n     * @returns the current time step\r\n     */\r\n    public getTimeStep(): number {\r\n        return this._physicsPlugin.getTimeStep();\r\n    }\r\n\r\n    /**\r\n     * Set the sub time step of the physics engine.\r\n     * Default is 0 meaning there is no sub steps\r\n     * To increase physics resolution precision, set a small value (like 1 ms)\r\n     * @param subTimeStep defines the new sub timestep used for physics resolution.\r\n     */\r\n    public setSubTimeStep(subTimeStep: number = 0) {\r\n        this._subTimeStep = subTimeStep;\r\n    }\r\n\r\n    /**\r\n     * Get the sub time step of the physics engine.\r\n     * @returns the current sub time step\r\n     */\r\n    public getSubTimeStep() {\r\n        return this._subTimeStep;\r\n    }\r\n\r\n    /**\r\n     * Release all resources\r\n     */\r\n    public dispose(): void {\r\n        this._physicsPlugin.dispose();\r\n    }\r\n\r\n    /**\r\n     * Gets the name of the current physics plugin\r\n     * @returns the name of the plugin\r\n     */\r\n    public getPhysicsPluginName(): string {\r\n        return this._physicsPlugin.name;\r\n    }\r\n\r\n    /**\r\n     * Set the maximum allowed linear and angular velocities\r\n     * @param maxLinearVelocity maximum allowed linear velocity\r\n     * @param maxAngularVelocity maximum allowed angular velocity\r\n     */\r\n    setVelocityLimits(maxLinearVelocity: number, maxAngularVelocity: number): void {\r\n        this._physicsPlugin.setVelocityLimits(maxLinearVelocity, maxAngularVelocity);\r\n    }\r\n\r\n    /**\r\n     * @returns maximum allowed linear velocity\r\n     */\r\n    getMaxLinearVelocity(): number {\r\n        return this._physicsPlugin.getMaxLinearVelocity();\r\n    }\r\n\r\n    /**\r\n     * @returns maximum allowed angular velocity\r\n     */\r\n    getMaxAngularVelocity(): number {\r\n        return this._physicsPlugin.getMaxAngularVelocity();\r\n    }\r\n\r\n    /**\r\n     * Adding a new impostor for the impostor tracking.\r\n     * This will be done by the impostor itself.\r\n     * @param impostor the impostor to add\r\n     */\r\n\r\n    /**\r\n     * Called by the scene. No need to call it.\r\n     * @param delta defines the timespan between frames\r\n     */\r\n    public _step(delta: number) {\r\n        if (delta > 0.1) {\r\n            delta = 0.1;\r\n        } else if (delta <= 0) {\r\n            delta = 1.0 / 60.0;\r\n        }\r\n\r\n        this._physicsPlugin.executeStep(delta, this._physicsBodies);\r\n    }\r\n\r\n    /**\r\n     * Add a body as an active component of this engine\r\n     * @param physicsBody The body to add\r\n     */\r\n    public addBody(physicsBody: PhysicsBody): void {\r\n        this._physicsBodies.push(physicsBody);\r\n    }\r\n    /**\r\n     * Removes a particular body from this engine\r\n     * @param physicsBody The body to remove from the simulation\r\n     */\r\n    public removeBody(physicsBody: PhysicsBody): void {\r\n        const index = this._physicsBodies.indexOf(physicsBody);\r\n        if (index > -1) {\r\n            /*const removed =*/ this._physicsBodies.splice(index, 1);\r\n        }\r\n    }\r\n    /**\r\n     * @returns an array of bodies added to this engine\r\n     */\r\n    public getBodies(): Array<PhysicsBody> {\r\n        return this._physicsBodies;\r\n    }\r\n\r\n    /**\r\n     * Gets the current plugin used to run the simulation\r\n     * @returns current plugin\r\n     */\r\n    public getPhysicsPlugin(): IPhysicsEnginePluginV2 {\r\n        return this._physicsPlugin;\r\n    }\r\n\r\n    /**\r\n     * Does a raycast in the physics world\r\n     * @param from when should the ray start?\r\n     * @param to when should the ray end?\r\n     * @param result resulting PhysicsRaycastResult\r\n     * @param query raycast query object\r\n     */\r\n    public raycastToRef(from: Vector3, to: Vector3, result: PhysicsRaycastResult, query?: IRaycastQuery): void {\r\n        this._physicsPlugin.raycast(from, to, result, query);\r\n    }\r\n\r\n    /**\r\n     * Does a raycast in the physics world\r\n     * @param from when should the ray start?\r\n     * @param to when should the ray end?\r\n     * @param query raycast query object\r\n     * @returns PhysicsRaycastResult\r\n     */\r\n    public raycast(from: Vector3, to: Vector3, query?: IRaycastQuery): PhysicsRaycastResult {\r\n        const result = new PhysicsRaycastResult();\r\n        this._physicsPlugin.raycast(from, to, result, query);\r\n        return result;\r\n    }\r\n}\r\n", "import type { IBasePhysicsCollisionEvent, IPhysicsCollisionEvent, IPhysicsEnginePluginV2, PhysicsMassProperties } from \"./IPhysicsEnginePlugin\";\r\nimport { PhysicsMotionType, PhysicsPrestepType } from \"./IPhysicsEnginePlugin\";\r\nimport type { PhysicsShape } from \"./physicsShape\";\r\nimport { Vector3, Quaternion, TmpVectors } from \"../../Maths/math.vector\";\r\nimport type { Scene } from \"../../scene\";\r\nimport type { PhysicsEngine } from \"./physicsEngine\";\r\nimport type { Nullable } from \"core/types\";\r\nimport type { PhysicsConstraint } from \"./physicsConstraint\";\r\nimport type { Bone } from \"core/Bones/bone\";\r\nimport { Space } from \"core/Maths/math.axis\";\r\nimport type { Observable, Observer } from \"../../Misc/observable\";\r\nimport type { Node } from \"../../node\";\r\nimport type { Mesh } from \"core/Meshes/mesh\";\r\nimport type { AbstractMesh } from \"../../Meshes/abstractMesh\";\r\nimport type { TransformNode } from \"../../Meshes/transformNode\";\r\nimport type { BoundingBox } from \"core/Culling/boundingBox\";\r\n\r\n/**\r\n * PhysicsBody is useful for creating a physics body that can be used in a physics engine. It allows\r\n * the user to set the mass and velocity of the body, which can then be used to calculate the\r\n * motion of the body in the physics engine.\r\n */\r\nexport class PhysicsBody {\r\n    /**\r\n     * V2 Physics plugin private data for single Transform\r\n     */\r\n    public _pluginData: any = undefined;\r\n    /**\r\n     * V2 Physics plugin private data for instances\r\n     */\r\n    public _pluginDataInstances: Array<any> = [];\r\n    /**\r\n     * The V2 plugin used to create and manage this Physics Body\r\n     */\r\n    private _physicsPlugin: IPhysicsEnginePluginV2;\r\n    /**\r\n     * The engine used to create and manage this Physics Body\r\n     */\r\n    private _physicsEngine: PhysicsEngine;\r\n    /**\r\n     * If the collision callback is enabled\r\n     */\r\n    private _collisionCBEnabled: boolean = false;\r\n    /**\r\n     * If the collision ended callback is enabled\r\n     */\r\n    private _collisionEndedCBEnabled: boolean = false;\r\n    /**\r\n     * The transform node associated with this Physics Body\r\n     */\r\n    transformNode: TransformNode;\r\n\r\n    /**\r\n     * Disable pre-step that consists in updating Physics Body from Transform Node Translation/Orientation.\r\n     * True by default for maximum performance.\r\n     */\r\n    public get disablePreStep(): boolean {\r\n        return this._prestepType == PhysicsPrestepType.DISABLED;\r\n    }\r\n\r\n    public set disablePreStep(value: boolean) {\r\n        this._prestepType = value ? PhysicsPrestepType.DISABLED : PhysicsPrestepType.TELEPORT;\r\n    }\r\n\r\n    /**\r\n     * Disable sync from physics to transformNode. This value is set to true at body creation or at motionType setting when the body is not dynamic.\r\n     */\r\n    disableSync: boolean = false;\r\n\r\n    /**\r\n     * Physics engine will try to make this body sleeping and not active\r\n     */\r\n    public startAsleep: boolean;\r\n\r\n    private _nodeDisposeObserver: Nullable<Observer<Node>>;\r\n\r\n    private _isDisposed = false;\r\n\r\n    private _shape: Nullable<PhysicsShape> = null;\r\n\r\n    private _motionType: PhysicsMotionType;\r\n\r\n    private _prestepType: PhysicsPrestepType = PhysicsPrestepType.DISABLED;\r\n    /**\r\n     * Constructs a new physics body for the given node.\r\n     * @param transformNode - The Transform Node to construct the physics body for. For better performance, it is advised that this node does not have a parent.\r\n     * @param motionType - The motion type of the physics body. The options are:\r\n     *  - PhysicsMotionType.STATIC - Static bodies are not moving and unaffected by forces or collisions. They are good for level boundaries or terrain.\r\n     *  - PhysicsMotionType.DYNAMIC - Dynamic bodies are fully simulated. They can move and collide with other objects.\r\n     *  - PhysicsMotionType.ANIMATED - They behave like dynamic bodies, but they won't be affected by other bodies, but still push other bodies out of the way.\r\n     * @param startsAsleep - Whether the physics body should start in a sleeping state (not a guarantee). Defaults to false.\r\n     * @param scene - The scene containing the physics engine.\r\n     *\r\n     * This code is useful for creating a physics body for a given Transform Node in a scene.\r\n     * It checks the version of the physics engine and the physics plugin, and initializes the body accordingly.\r\n     * It also sets the node's rotation quaternion if it is not already set. Finally, it adds the body to the physics engine.\r\n     */\r\n    constructor(transformNode: TransformNode, motionType: PhysicsMotionType, startsAsleep: boolean, scene: Scene) {\r\n        if (!scene) {\r\n            return;\r\n        }\r\n        const physicsEngine = scene.getPhysicsEngine() as PhysicsEngine;\r\n        if (!physicsEngine) {\r\n            throw new Error(\"No Physics Engine available.\");\r\n        }\r\n        this._physicsEngine = physicsEngine;\r\n        if (physicsEngine.getPluginVersion() != 2) {\r\n            throw new Error(\"Plugin version is incorrect. Expected version 2.\");\r\n        }\r\n        const physicsPlugin = physicsEngine.getPhysicsPlugin();\r\n        if (!physicsPlugin) {\r\n            throw new Error(\"No Physics Plugin available.\");\r\n        }\r\n\r\n        this._physicsPlugin = physicsPlugin as IPhysicsEnginePluginV2;\r\n        if (!transformNode.rotationQuaternion) {\r\n            transformNode.rotationQuaternion = Quaternion.FromEulerAngles(transformNode.rotation.x, transformNode.rotation.y, transformNode.rotation.z);\r\n        }\r\n\r\n        this.startAsleep = startsAsleep;\r\n\r\n        this._motionType = motionType;\r\n\r\n        // only dynamic and animated body needs sync from physics to transformNode\r\n        this.disableSync = motionType == PhysicsMotionType.STATIC;\r\n\r\n        // instances?\r\n        const m = transformNode as Mesh;\r\n        if (m.hasThinInstances) {\r\n            this._physicsPlugin.initBodyInstances(this, motionType, m);\r\n        } else {\r\n            // single instance\r\n            if (transformNode.parent) {\r\n                // Force computation of world matrix so that the parent transforms are correctly reflected in absolutePosition/absoluteRotationQuaternion.\r\n                transformNode.computeWorldMatrix(true);\r\n            }\r\n            this._physicsPlugin.initBody(this, motionType, transformNode.absolutePosition, transformNode.absoluteRotationQuaternion);\r\n        }\r\n        this.transformNode = transformNode;\r\n        transformNode.physicsBody = this;\r\n        physicsEngine.addBody(this);\r\n\r\n        this._nodeDisposeObserver = transformNode.onDisposeObservable.add(() => {\r\n            this.dispose();\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Returns the string \"PhysicsBody\".\r\n     * @returns \"PhysicsBody\"\r\n     */\r\n    public getClassName() {\r\n        return \"PhysicsBody\";\r\n    }\r\n\r\n    /**\r\n     * Clone the PhysicsBody to a new body and assign it to the transformNode parameter\r\n     * @param transformNode transformNode that will be used for the cloned PhysicsBody\r\n     * @returns the newly cloned PhysicsBody\r\n     */\r\n    public clone(transformNode: TransformNode): PhysicsBody {\r\n        const clonedBody = new PhysicsBody(transformNode, this.getMotionType(), this.startAsleep, this.transformNode.getScene());\r\n        clonedBody.shape = this.shape;\r\n        clonedBody.setMassProperties(this.getMassProperties());\r\n        clonedBody.setLinearDamping(this.getLinearDamping());\r\n        clonedBody.setAngularDamping(this.getAngularDamping());\r\n        return clonedBody;\r\n    }\r\n\r\n    /**\r\n     * If a physics body is connected to an instanced node, update the number physic instances to match the number of node instances.\r\n     */\r\n    public updateBodyInstances() {\r\n        const m = this.transformNode as Mesh;\r\n        if (m.hasThinInstances) {\r\n            this._physicsPlugin.updateBodyInstances(this, m);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * This returns the number of internal instances of the physics body\r\n     */\r\n    public get numInstances(): number {\r\n        return this._pluginDataInstances.length;\r\n    }\r\n\r\n    /**\r\n     * Get the motion type of the physics body. Can be STATIC, DYNAMIC, or ANIMATED.\r\n     */\r\n    public get motionType(): PhysicsMotionType {\r\n        return this._motionType;\r\n    }\r\n\r\n    /**\r\n     * Sets the shape of the physics body.\r\n     * @param shape - The shape of the physics body.\r\n     *\r\n     * This method is useful for setting the shape of the physics body, which is necessary for the physics engine to accurately simulate the body's behavior.\r\n     * The shape is used to calculate the body's mass, inertia, and other properties.\r\n     */\r\n    public set shape(shape: Nullable<PhysicsShape>) {\r\n        this._shape = shape;\r\n        if (shape) {\r\n            this._physicsPlugin.setShape(this, shape);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Retrieves the physics shape associated with this object.\r\n     *\r\n     * @returns The physics shape associated with this object, or `undefined` if no\r\n     * shape is associated.\r\n     *\r\n     * This method is useful for retrieving the physics shape associated with this object,\r\n     * which can be used to apply physical forces to the object or to detect collisions.\r\n     */\r\n    public get shape(): Nullable<PhysicsShape> {\r\n        return this._shape;\r\n    }\r\n\r\n    /**\r\n     * Returns the bounding box of the physics body.\r\n     * @returns The bounding box of the physics body.\r\n     */\r\n    public getBoundingBox(): BoundingBox {\r\n        return this._physicsPlugin.getBodyBoundingBox(this);\r\n    }\r\n\r\n    /**\r\n     * Sets the event mask for the physics engine.\r\n     *\r\n     * @param eventMask - A bitmask that determines which events will be sent to the physics engine.\r\n     * @param instanceIndex - If this body is instanced, the index of the instance to set the event mask for.\r\n     *\r\n     * This method is useful for setting the event mask for the physics engine, which determines which events\r\n     * will be sent to the physics engine. This allows the user to control which events the physics engine will respond to.\r\n     */\r\n    public setEventMask(eventMask: number, instanceIndex?: number) {\r\n        this._physicsPlugin.setEventMask(this, eventMask, instanceIndex);\r\n    }\r\n\r\n    /**\r\n     * Gets the event mask of the physics engine.\r\n     * @param instanceIndex - If this body is instanced, the index of the instance to get the event mask for.\r\n     * @returns The event mask of the physics engine.\r\n     *\r\n     * This method is useful for getting the event mask of the physics engine,\r\n     * which is used to determine which events the engine will respond to.\r\n     * This is important for ensuring that the engine is responding to the correct events and not\r\n     * wasting resources on unnecessary events.\r\n     */\r\n    public getEventMask(instanceIndex?: number): number {\r\n        return this._physicsPlugin.getEventMask(this, instanceIndex);\r\n    }\r\n\r\n    /**\r\n     * Sets the motion type of the physics body. Can be STATIC, DYNAMIC, or ANIMATED.\r\n     * @param motionType - The motion type to set.\r\n     * @param instanceIndex - If this body is instanced, the index of the instance to set the motion type for.\r\n     */\r\n    public setMotionType(motionType: PhysicsMotionType, instanceIndex?: number) {\r\n        this.disableSync = motionType == PhysicsMotionType.STATIC;\r\n        this._physicsPlugin.setMotionType(this, motionType, instanceIndex);\r\n    }\r\n\r\n    /**\r\n     * Gets the motion type of the physics body. Can be STATIC, DYNAMIC, or ANIMATED.\r\n     * @param instanceIndex - If this body is instanced, the index of the instance to get the motion type for.\r\n     * @returns The motion type of the physics body.\r\n     */\r\n    public getMotionType(instanceIndex?: number): PhysicsMotionType {\r\n        return this._physicsPlugin.getMotionType(this, instanceIndex);\r\n    }\r\n\r\n    /**\r\n     * Set the prestep type of the body\r\n     * @param prestepType prestep type provided by PhysicsPrestepType\r\n     */\r\n    public setPrestepType(prestepType: PhysicsPrestepType): void {\r\n        this._prestepType = prestepType;\r\n    }\r\n\r\n    /**\r\n     * Get the current prestep type of the body\r\n     * @returns the type of prestep associated with the body and its instance index\r\n     */\r\n    public getPrestepType(): PhysicsPrestepType {\r\n        return this._prestepType;\r\n    }\r\n\r\n    /**\r\n     * Computes the mass properties of the physics object, based on the set of physics shapes this body uses.\r\n     * This method is useful for computing the initial mass properties of a physics object, such as its mass,\r\n     * inertia, and center of mass; these values are important for accurately simulating the physics of the\r\n     * object in the physics engine, and computing values based on the shape will provide you with reasonable\r\n     * initial values, which you can then customize.\r\n     * @param instanceIndex - The index of the instance to compute the mass properties for.\r\n     * @returns The mass properties of the object.\r\n     */\r\n    public computeMassProperties(instanceIndex?: number): PhysicsMassProperties {\r\n        return this._physicsPlugin.computeMassProperties(this, instanceIndex);\r\n    }\r\n\r\n    /**\r\n     * Sets the mass properties of the physics object.\r\n     *\r\n     * @param massProps - The mass properties to set.\r\n     * @param instanceIndex - The index of the instance to set the mass properties for. If not defined, the mass properties will be set for all instances.\r\n     *\r\n     * This method is useful for setting the mass properties of a physics object, such as its mass,\r\n     * inertia, and center of mass. This is important for accurately simulating the physics of the object in the physics engine.\r\n     */\r\n    public setMassProperties(massProps: PhysicsMassProperties, instanceIndex?: number): void {\r\n        this._physicsPlugin.setMassProperties(this, massProps, instanceIndex);\r\n    }\r\n\r\n    /**\r\n     * Retrieves the mass properties of the object.\r\n     * @param instanceIndex - If this body is instanced, the index of the instance to get the mass properties for.\r\n     * @returns The mass properties of the object.\r\n     *\r\n     * This method is useful for physics simulations, as it allows the user to\r\n     * retrieve the mass properties of the object, such as its mass, center of mass,\r\n     * and moment of inertia. This information is necessary for accurate physics\r\n     * simulations.\r\n     */\r\n    public getMassProperties(instanceIndex?: number): PhysicsMassProperties {\r\n        return this._physicsPlugin.getMassProperties(this, instanceIndex);\r\n    }\r\n\r\n    /**\r\n     * Sets the linear damping of the physics body.\r\n     *\r\n     * @param damping - The linear damping value.\r\n     * @param instanceIndex - If this body is instanced, the index of the instance to set the linear damping for.\r\n     *\r\n     * This method is useful for controlling the linear damping of the physics body,\r\n     * which is the rate at which the body's velocity decreases over time. This is useful for simulating\r\n     * the effects of air resistance or other forms of friction.\r\n     */\r\n    public setLinearDamping(damping: number, instanceIndex?: number) {\r\n        this._physicsPlugin.setLinearDamping(this, damping, instanceIndex);\r\n    }\r\n\r\n    /**\r\n     * Gets the linear damping of the physics body.\r\n     * @param instanceIndex - If this body is instanced, the index of the instance to get the linear damping for.\r\n     * @returns The linear damping of the physics body.\r\n     *\r\n     * This method is useful for retrieving the linear damping of the physics body, which is the amount of\r\n     * resistance the body has to linear motion. This is useful for simulating realistic physics behavior\r\n     * in a game.\r\n     */\r\n    public getLinearDamping(instanceIndex?: number): number {\r\n        return this._physicsPlugin.getLinearDamping(this, instanceIndex);\r\n    }\r\n\r\n    /**\r\n     * Sets the angular damping of the physics body.\r\n     * @param damping The angular damping of the body.\r\n     * @param instanceIndex - If this body is instanced, the index of the instance to set the angular damping for.\r\n     *\r\n     * This method is useful for controlling the angular velocity of a physics body.\r\n     * By setting the damping, the body's angular velocity will be reduced over time, simulating the effect of friction.\r\n     * This can be used to create realistic physical behavior in a physics engine.\r\n     */\r\n    public setAngularDamping(damping: number, instanceIndex?: number) {\r\n        this._physicsPlugin.setAngularDamping(this, damping, instanceIndex);\r\n    }\r\n\r\n    /**\r\n     * Gets the angular damping of the physics body.\r\n     * @param instanceIndex - If this body is instanced, the index of the instance to get the angular damping for.\r\n     *\r\n     * @returns The angular damping of the physics body.\r\n     *\r\n     * This method is useful for getting the angular damping of the physics body,\r\n     * which is the rate of reduction of the angular velocity over time.\r\n     * This is important for simulating realistic physics behavior in a game.\r\n     */\r\n    public getAngularDamping(instanceIndex?: number): number {\r\n        return this._physicsPlugin.getAngularDamping(this, instanceIndex);\r\n    }\r\n\r\n    /**\r\n     * Sets the linear velocity of the physics object.\r\n     * @param linVel - The linear velocity to set.\r\n     * @param instanceIndex - If this body is instanced, the index of the instance to set the linear velocity for.\r\n     *\r\n     * This method is useful for setting the linear velocity of a physics object,\r\n     * which is necessary for simulating realistic physics in a game engine.\r\n     * By setting the linear velocity, the physics object will move in the direction and speed specified by the vector.\r\n     * This allows for realistic physics simulations, such as simulating the motion of a ball rolling down a hill.\r\n     */\r\n    public setLinearVelocity(linVel: Vector3, instanceIndex?: number): void {\r\n        this._physicsPlugin.setLinearVelocity(this, linVel, instanceIndex);\r\n    }\r\n\r\n    /**\r\n     * Gets the linear velocity of the physics body and stores it in the given vector3.\r\n     * @param linVel - The vector3 to store the linear velocity in.\r\n     * @param instanceIndex - If this body is instanced, the index of the instance to get the linear velocity for.\r\n     *\r\n     * This method is useful for getting the linear velocity of a physics body in a physics engine.\r\n     * This can be used to determine the speed and direction of the body, which can be used to calculate the motion of the body.\r\n     */\r\n    public getLinearVelocityToRef(linVel: Vector3, instanceIndex?: number): void {\r\n        this._physicsPlugin.getLinearVelocityToRef(this, linVel, instanceIndex);\r\n    }\r\n\r\n    /**\r\n     * Gets the linear velocity of the physics body as a new vector3.\r\n     * @param instanceIndex - If this body is instanced, the index of the instance to get the linear velocity for.\r\n     * @returns The linear velocity of the physics body.\r\n     *\r\n     * This method is useful for getting the linear velocity of a physics body in a physics engine.\r\n     * This can be used to determine the speed and direction of the body, which can be used to calculate the motion of the body.\r\n     */\r\n    public getLinearVelocity(instanceIndex?: number): Vector3 {\r\n        const ref = new Vector3();\r\n        this.getLinearVelocityToRef(ref, instanceIndex);\r\n        return ref;\r\n    }\r\n\r\n    /**\r\n     * Sets the angular velocity of the physics object.\r\n     * @param angVel - The angular velocity to set.\r\n     * @param instanceIndex - If this body is instanced, the index of the instance to set the angular velocity for.\r\n     *\r\n     * This method is useful for setting the angular velocity of a physics object, which is necessary for\r\n     * simulating realistic physics behavior. The angular velocity is used to determine the rate of rotation of the object,\r\n     * which is important for simulating realistic motion.\r\n     */\r\n    public setAngularVelocity(angVel: Vector3, instanceIndex?: number): void {\r\n        this._physicsPlugin.setAngularVelocity(this, angVel, instanceIndex);\r\n    }\r\n\r\n    /**\r\n     * Gets the angular velocity of the physics body and stores it in the given vector3.\r\n     * @param angVel - The vector3 to store the angular velocity in.\r\n     * @param instanceIndex - If this body is instanced, the index of the instance to get the angular velocity for.\r\n     *\r\n     * This method is useful for getting the angular velocity of a physics body, which can be used to determine the body's\r\n     * rotational speed. This information can be used to create realistic physics simulations.\r\n     */\r\n    public getAngularVelocityToRef(angVel: Vector3, instanceIndex?: number): void {\r\n        this._physicsPlugin.getAngularVelocityToRef(this, angVel, instanceIndex);\r\n    }\r\n\r\n    /**\r\n     * Gets the angular velocity of the physics body as a new vector3.\r\n     * @param instanceIndex - If this body is instanced, the index of the instance to get the angular velocity for.\r\n     * @returns The angular velocity of the physics body.\r\n     *\r\n     * This method is useful for getting the angular velocity of a physics body, which can be used to determine the body's\r\n     * rotational speed. This information can be used to create realistic physics simulations.\r\n     */\r\n    public getAngularVelocity(instanceIndex?: number): Vector3 {\r\n        const ref = new Vector3();\r\n        this.getAngularVelocityToRef(ref, instanceIndex);\r\n        return ref;\r\n    }\r\n\r\n    /**\r\n     * Applies an impulse to the physics object.\r\n     *\r\n     * @param impulse The impulse vector.\r\n     * @param location The location of the impulse.\r\n     * @param instanceIndex For a instanced body, the instance to where the impulse should be applied. If not specified, the impulse is applied to all instances.\r\n     *\r\n     * This method is useful for applying an impulse to a physics object, which can be used to simulate physical forces such as gravity,\r\n     * collisions, and explosions. This can be used to create realistic physics simulations in a game or other application.\r\n     */\r\n    public applyImpulse(impulse: Vector3, location: Vector3, instanceIndex?: number): void {\r\n        this._physicsPlugin.applyImpulse(this, impulse, location, instanceIndex);\r\n    }\r\n\r\n    /**\r\n     * Add torque to a physics body\r\n     * @param angularImpulse The angular impulse vector.\r\n     * @param instanceIndex For a instanced body, the instance to where the impulse should be applied. If not specified, the impulse is applied to all instances.\r\n     */\r\n    public applyAngularImpulse(angularImpulse: Vector3, instanceIndex?: number): void {\r\n        this._physicsPlugin.applyAngularImpulse(this, angularImpulse, instanceIndex);\r\n    }\r\n\r\n    /**\r\n     * Applies a force to the physics object.\r\n     *\r\n     * @param force The force vector.\r\n     * @param location The location of the force.\r\n     * @param instanceIndex For a instanced body, the instance to where the force should be applied. If not specified, the force is applied to all instances.\r\n     *\r\n     * This method is useful for applying a force to a physics object, which can be used to simulate physical forces such as gravity,\r\n     * collisions, and explosions. This can be used to create realistic physics simulations in a game or other application.\r\n     */\r\n    public applyForce(force: Vector3, location: Vector3, instanceIndex?: number): void {\r\n        this._physicsPlugin.applyForce(this, force, location, instanceIndex);\r\n    }\r\n\r\n    /**\r\n     * Retrieves the geometry of the body from the physics plugin.\r\n     *\r\n     * @returns The geometry of the body.\r\n     *\r\n     * This method is useful for retrieving the geometry of the body from the physics plugin, which can be used for various physics calculations.\r\n     */\r\n    public getGeometry(): {} {\r\n        return this._physicsPlugin.getBodyGeometry(this);\r\n    }\r\n\r\n    /**\r\n     * Returns an observable that will be notified for when a collision starts or continues for this PhysicsBody\r\n     * @returns Observable\r\n     */\r\n    public getCollisionObservable(): Observable<IPhysicsCollisionEvent> {\r\n        return this._physicsPlugin.getCollisionObservable(this);\r\n    }\r\n\r\n    /**\r\n     * Returns an observable that will be notified when the body has finished colliding with another body\r\n     * @returns\r\n     */\r\n    public getCollisionEndedObservable(): Observable<IBasePhysicsCollisionEvent> {\r\n        return this._physicsPlugin.getCollisionEndedObservable(this);\r\n    }\r\n\r\n    /**\r\n     * Enable or disable collision callback for this PhysicsBody.\r\n     * @param enabled true if PhysicsBody's collision will rise a collision event and notifies the observable\r\n     */\r\n    public setCollisionCallbackEnabled(enabled: boolean): void {\r\n        this._collisionCBEnabled = enabled;\r\n        this._physicsPlugin.setCollisionCallbackEnabled(this, enabled);\r\n    }\r\n\r\n    /**\r\n     * Enable or disable collision ended callback for this PhysicsBody.\r\n     * @param enabled true if PhysicsBody's collision ended will rise a collision event and notifies the observable\r\n     */\r\n    public setCollisionEndedCallbackEnabled(enabled: boolean): void {\r\n        this._collisionEndedCBEnabled = enabled;\r\n        this._physicsPlugin.setCollisionEndedCallbackEnabled(this, enabled);\r\n    }\r\n\r\n    /**\r\n     * Get the center of the object in world space.\r\n     * @param instanceIndex - If this body is instanced, the index of the instance to get the center for.\r\n     * @returns geometric center of the associated mesh\r\n     */\r\n    public getObjectCenterWorld(instanceIndex?: number): Vector3 {\r\n        const ref = new Vector3();\r\n        return this.getObjectCenterWorldToRef(ref, instanceIndex);\r\n    }\r\n\r\n    /**\r\n     * Get the center of the object in world space.\r\n     * @param ref - The vector3 to store the result in.\r\n     * @param instanceIndex - If this body is instanced, the index of the instance to get the center for.\r\n     * @returns geometric center of the associated mesh\r\n     */\r\n    public getObjectCenterWorldToRef(ref: Vector3, instanceIndex?: number): Vector3 {\r\n        if (this._pluginDataInstances?.length > 0) {\r\n            const index = instanceIndex || 0;\r\n            const matrixData = (this.transformNode as Mesh)._thinInstanceDataStorage.matrixData;\r\n            if (matrixData) {\r\n                ref.set(matrixData[index * 16 + 12], matrixData[index * 16 + 13], matrixData[index * 16 + 14]);\r\n            }\r\n        } else {\r\n            ref.copyFrom(this.transformNode.position);\r\n        }\r\n        return ref;\r\n    }\r\n\r\n    /**\r\n     * Adds a constraint to the physics engine.\r\n     *\r\n     * @param childBody - The body to which the constraint will be applied.\r\n     * @param constraint - The constraint to be applied.\r\n     * @param instanceIndex - If this body is instanced, the index of the instance to which the constraint will be applied. If not specified, no constraint will be applied.\r\n     * @param childInstanceIndex - If the child body is instanced, the index of the instance to which the constraint will be applied. If not specified, no constraint will be applied.\r\n     *\r\n     */\r\n    public addConstraint(childBody: PhysicsBody, constraint: PhysicsConstraint, instanceIndex?: number, childInstanceIndex?: number): void {\r\n        this._physicsPlugin.addConstraint(this, childBody, constraint, instanceIndex, childInstanceIndex);\r\n    }\r\n\r\n    /**\r\n     * Sync with a bone\r\n     * @param bone The bone that the impostor will be synced to.\r\n     * @param boneMesh The mesh that the bone is influencing.\r\n     * @param jointPivot The pivot of the joint / bone in local space.\r\n     * @param distToJoint Optional distance from the impostor to the joint.\r\n     * @param adjustRotation Optional quaternion for adjusting the local rotation of the bone.\r\n     * @param boneAxis Optional vector3 axis the bone is aligned with\r\n     */\r\n    public syncWithBone(bone: Bone, boneMesh: AbstractMesh, jointPivot: Vector3, distToJoint?: number, adjustRotation?: Quaternion, boneAxis?: Vector3) {\r\n        const mesh = this.transformNode;\r\n\r\n        if (mesh.rotationQuaternion) {\r\n            if (adjustRotation) {\r\n                const tempQuat = TmpVectors.Quaternion[0];\r\n                bone.getRotationQuaternionToRef(Space.WORLD, boneMesh, tempQuat);\r\n                tempQuat.multiplyToRef(adjustRotation, mesh.rotationQuaternion);\r\n            } else {\r\n                bone.getRotationQuaternionToRef(Space.WORLD, boneMesh, mesh.rotationQuaternion);\r\n            }\r\n        }\r\n\r\n        const pos = TmpVectors.Vector3[0];\r\n        const boneDir = TmpVectors.Vector3[1];\r\n\r\n        if (!boneAxis) {\r\n            boneAxis = TmpVectors.Vector3[2];\r\n            boneAxis.x = 0;\r\n            boneAxis.y = 1;\r\n            boneAxis.z = 0;\r\n        }\r\n\r\n        bone.getDirectionToRef(boneAxis, boneMesh, boneDir);\r\n        bone.getAbsolutePositionToRef(boneMesh, pos);\r\n\r\n        if ((distToJoint === undefined || distToJoint === null) && jointPivot) {\r\n            distToJoint = jointPivot.length();\r\n        }\r\n\r\n        if (distToJoint !== undefined && distToJoint !== null) {\r\n            pos.x += boneDir.x * distToJoint;\r\n            pos.y += boneDir.y * distToJoint;\r\n            pos.z += boneDir.z * distToJoint;\r\n        }\r\n\r\n        mesh.setAbsolutePosition(pos);\r\n    }\r\n\r\n    /**\r\n     * Executes a callback on the body or all of the instances of a body\r\n     * @param callback the callback to execute\r\n     */\r\n    public iterateOverAllInstances(callback: (body: PhysicsBody, instanceIndex?: number) => void) {\r\n        if (this._pluginDataInstances?.length > 0) {\r\n            for (let i = 0; i < this._pluginDataInstances.length; i++) {\r\n                callback(this, i);\r\n            }\r\n        } else {\r\n            callback(this, undefined);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Sets the gravity factor of the physics body\r\n     * @param factor the gravity factor to set\r\n     * @param instanceIndex the instance of the body to set, if undefined all instances will be set\r\n     */\r\n    public setGravityFactor(factor: number, instanceIndex?: number) {\r\n        this._physicsPlugin.setGravityFactor(this, factor, instanceIndex);\r\n    }\r\n\r\n    /**\r\n     * Gets the gravity factor of the physics body\r\n     * @param instanceIndex the instance of the body to get, if undefined the value of first instance will be returned\r\n     * @returns the gravity factor\r\n     */\r\n    public getGravityFactor(instanceIndex?: number): number {\r\n        return this._physicsPlugin.getGravityFactor(this, instanceIndex);\r\n    }\r\n\r\n    /**\r\n     * Set the target transformation (position and rotation) of the body, such that the body will set its velocity to reach that target\r\n     * @param position The target position\r\n     * @param rotation The target rotation\r\n     * @param instanceIndex The index of the instance in an instanced body\r\n     */\r\n    public setTargetTransform(position: Vector3, rotation: Quaternion, instanceIndex?: number) {\r\n        this._physicsPlugin.setTargetTransform(this, position, rotation, instanceIndex);\r\n    }\r\n\r\n    /**\r\n     * Returns if the body has been disposed.\r\n     * @returns true if disposed, false otherwise.\r\n     */\r\n    public get isDisposed() {\r\n        return this._isDisposed;\r\n    }\r\n\r\n    /**\r\n     * Disposes the body from the physics engine.\r\n     *\r\n     * This method is useful for cleaning up the physics engine when a body is no longer needed. Disposing the body will free up resources and prevent memory leaks.\r\n     */\r\n    public dispose() {\r\n        if (this._isDisposed) {\r\n            return;\r\n        }\r\n        // Disable collisions CB so it doesn't fire when the body is disposed\r\n        if (this._collisionCBEnabled) {\r\n            this.setCollisionCallbackEnabled(false);\r\n        }\r\n        if (this._collisionEndedCBEnabled) {\r\n            this.setCollisionEndedCallbackEnabled(false);\r\n        }\r\n        if (this._nodeDisposeObserver) {\r\n            this.transformNode.onDisposeObservable.remove(this._nodeDisposeObserver);\r\n            this._nodeDisposeObserver = null;\r\n        }\r\n        this._physicsEngine.removeBody(this);\r\n        this._physicsPlugin.removeBody(this);\r\n        this._physicsPlugin.disposeBody(this);\r\n        this.transformNode.physicsBody = null;\r\n        this._pluginData = null;\r\n        this._pluginDataInstances.length = 0;\r\n        this._isDisposed = true;\r\n        this.shape = null;\r\n    }\r\n}\r\n", "import type { Scene } from \"../../scene\";\r\nimport type { Vector3 } from \"../../Maths/math.vector\";\r\nimport type { Nullable } from \"../../types\";\r\nimport type { IPhysicsEnginePluginV2, PhysicsConstraintParameters, PhysicsConstraintAxisLimitMode, PhysicsConstraintMotorType, ConstrainedBodyPair } from \"./IPhysicsEnginePlugin\";\r\nimport { PhysicsConstraintAxis, PhysicsConstraintType } from \"./IPhysicsEnginePlugin\";\r\n\r\n/**\r\n * This is a holder class for the physics constraint created by the physics plugin\r\n * It holds a set of functions to control the underlying constraint\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/physics/usingPhysicsEngine\r\n */\r\nexport class PhysicsConstraint {\r\n    /**\r\n     * V2 Physics plugin private data for a physics material\r\n     */\r\n    public _pluginData: any = undefined;\r\n    /**\r\n     * The V2 plugin used to create and manage this Physics Body\r\n     */\r\n    protected _physicsPlugin: IPhysicsEnginePluginV2;\r\n    protected _options: PhysicsConstraintParameters;\r\n    protected _type: PhysicsConstraintType;\r\n    /**\r\n     * @internal\r\n     * The internal options that were used to init the constraint\r\n     */\r\n    public _initOptions?: PhysicsConstraintParameters;\r\n\r\n    /**\r\n     * Constructs a new constraint for the physics constraint.\r\n     * @param type The type of constraint to create.\r\n     * @param options The options for the constraint.\r\n     * @param scene The scene the constraint belongs to.\r\n     *\r\n     * This code is useful for creating a new constraint for the physics engine. It checks if the scene has a physics engine, and if the plugin version is correct.\r\n     * If all checks pass, it initializes the constraint with the given type and options.\r\n     */\r\n    constructor(type: PhysicsConstraintType, options: PhysicsConstraintParameters, scene: Scene) {\r\n        if (!scene) {\r\n            throw new Error(\"Missing scene parameter for constraint constructor.\");\r\n        }\r\n        const physicsEngine = scene.getPhysicsEngine();\r\n        if (!physicsEngine) {\r\n            throw new Error(\"No Physics Engine available.\");\r\n        }\r\n        if (physicsEngine.getPluginVersion() != 2) {\r\n            throw new Error(\"Plugin version is incorrect. Expected version 2.\");\r\n        }\r\n        const physicsPlugin = physicsEngine.getPhysicsPlugin();\r\n        if (!physicsPlugin) {\r\n            throw new Error(\"No Physics Plugin available.\");\r\n        }\r\n\r\n        this._physicsPlugin = physicsPlugin as IPhysicsEnginePluginV2;\r\n        this._options = options;\r\n        this._type = type;\r\n    }\r\n\r\n    /**\r\n     * Gets the type of the constraint.\r\n     *\r\n     * @returns The type of the constraint.\r\n     *\r\n     */\r\n    public get type(): PhysicsConstraintType {\r\n        return this._type;\r\n    }\r\n\r\n    /**\r\n     * Retrieves the options of the physics constraint.\r\n     *\r\n     * @returns The physics constraint parameters.\r\n     *\r\n     */\r\n    public get options(): PhysicsConstraintParameters {\r\n        return this._options;\r\n    }\r\n\r\n    /**\r\n     * Enable/disable the constraint\r\n     * @param isEnabled value for the constraint\r\n     */\r\n    public set isEnabled(isEnabled: boolean) {\r\n        this._physicsPlugin.setEnabled(this, isEnabled);\r\n    }\r\n\r\n    /**\r\n     *\r\n     * @returns true if constraint is enabled\r\n     */\r\n    public get isEnabled(): boolean {\r\n        return this._physicsPlugin.getEnabled(this);\r\n    }\r\n\r\n    /**\r\n     * Enables or disables collisions for the physics engine.\r\n     *\r\n     * @param isEnabled - A boolean value indicating whether collisions should be enabled or disabled.\r\n     *\r\n     */\r\n    public set isCollisionsEnabled(isEnabled: boolean) {\r\n        this._physicsPlugin.setCollisionsEnabled(this, isEnabled);\r\n    }\r\n\r\n    /**\r\n     * Gets whether collisions are enabled for this physics object.\r\n     *\r\n     * @returns `true` if collisions are enabled, `false` otherwise.\r\n     *\r\n     */\r\n    public get isCollisionsEnabled(): boolean {\r\n        return this._physicsPlugin.getCollisionsEnabled(this);\r\n    }\r\n\r\n    /**\r\n     * Gets all bodies that are using this constraint\r\n     * @returns\r\n     */\r\n    public getBodiesUsingConstraint(): ConstrainedBodyPair[] {\r\n        return this._physicsPlugin.getBodiesUsingConstraint(this);\r\n    }\r\n\r\n    /**\r\n     * Disposes the constraint from the physics engine.\r\n     *\r\n     * This method is useful for cleaning up the physics engine when a body is no longer needed. Disposing the body will free up resources and prevent memory leaks.\r\n     */\r\n    public dispose(): void {\r\n        this._physicsPlugin.disposeConstraint(this);\r\n    }\r\n}\r\n\r\n/**\r\n * This describes a single limit used by Physics6DoFConstraint\r\n */\r\nexport class Physics6DoFLimit {\r\n    /**\r\n     * The axis ID to limit\r\n     */\r\n    axis: PhysicsConstraintAxis;\r\n    /**\r\n     * An optional minimum limit for the axis.\r\n     * Corresponds to a distance in meters for linear axes, an angle in radians for angular axes.\r\n     */\r\n    minLimit?: number;\r\n    /**\r\n     * An optional maximum limit for the axis.\r\n     * Corresponds to a distance in meters for linear axes, an angle in radians for angular axes.\r\n     */\r\n    maxLimit?: number;\r\n    /**\r\n     * The stiffness of the constraint.\r\n     */\r\n    stiffness?: number;\r\n    /**\r\n     * A constraint parameter that specifies damping.\r\n     */\r\n    damping?: number;\r\n}\r\n\r\n/**\r\n * A generic constraint, which can be used to build more complex constraints than those specified\r\n * in PhysicsConstraintType. The axis and pivot options in PhysicsConstraintParameters define the space\r\n * the constraint operates in. This constraint contains a set of limits, which restrict the\r\n * relative movement of the bodies in that coordinate system\r\n */\r\nexport class Physics6DoFConstraint extends PhysicsConstraint {\r\n    /**\r\n     * The collection of limits which this constraint will apply\r\n     */\r\n    public limits: Physics6DoFLimit[];\r\n\r\n    constructor(constraintParams: PhysicsConstraintParameters, limits: Physics6DoFLimit[], scene: Scene) {\r\n        super(PhysicsConstraintType.SIX_DOF, constraintParams, scene);\r\n        this.limits = limits;\r\n    }\r\n\r\n    /**\r\n     * Sets the friction of the given axis of the physics engine.\r\n     * @param axis - The axis of the physics engine to set the friction for.\r\n     * @param friction - The friction to set for the given axis.\r\n     *\r\n     */\r\n    public setAxisFriction(axis: PhysicsConstraintAxis, friction: number): void {\r\n        this._physicsPlugin.setAxisFriction(this, axis, friction);\r\n    }\r\n\r\n    /**\r\n     * Gets the friction of the given axis of the physics engine.\r\n     * @param axis - The axis of the physics engine.\r\n     * @returns The friction of the given axis, or null if the constraint hasn't been initialized yet.\r\n     *\r\n     */\r\n    public getAxisFriction(axis: PhysicsConstraintAxis): Nullable<number> {\r\n        return this._physicsPlugin.getAxisFriction(this, axis);\r\n    }\r\n\r\n    /**\r\n     * Sets the limit mode for the given axis of the constraint.\r\n     * @param axis The axis to set the limit mode for.\r\n     * @param limitMode The limit mode to set.\r\n     *\r\n     * This method is useful for setting the limit mode for a given axis of the constraint. This is important for\r\n     * controlling the behavior of the physics engine when the constraint is reached. By setting the limit mode,\r\n     * the engine can be configured to either stop the motion of the objects, or to allow them to continue\r\n     * moving beyond the constraint.\r\n     */\r\n    public setAxisMode(axis: PhysicsConstraintAxis, limitMode: PhysicsConstraintAxisLimitMode): void {\r\n        this._physicsPlugin.setAxisMode(this, axis, limitMode);\r\n    }\r\n\r\n    /**\r\n     * Gets the limit mode of the given axis of the constraint.\r\n     *\r\n     * @param axis - The axis of the constraint.\r\n     * @returns The limit mode of the given axis, or null if the constraint hasn't been initialized yet.\r\n     *\r\n     */\r\n    public getAxisMode(axis: PhysicsConstraintAxis): Nullable<PhysicsConstraintAxisLimitMode> {\r\n        return this._physicsPlugin.getAxisMode(this, axis);\r\n    }\r\n\r\n    /**\r\n     * Sets the minimum limit of a given axis of a constraint.\r\n     * @param axis - The axis of the constraint.\r\n     * @param minLimit - The minimum limit of the axis.\r\n     *\r\n     */\r\n    public setAxisMinLimit(axis: PhysicsConstraintAxis, minLimit: number): void {\r\n        this._physicsPlugin.setAxisMinLimit(this, axis, minLimit);\r\n    }\r\n\r\n    /**\r\n     * Gets the minimum limit of the given axis of the physics engine.\r\n     * @param axis - The axis of the physics engine.\r\n     * @returns The minimum limit of the given axis, or null if the constraint hasn't been initialized yet.\r\n     *\r\n     */\r\n    public getAxisMinLimit(axis: PhysicsConstraintAxis): Nullable<number> {\r\n        return this._physicsPlugin.getAxisMinLimit(this, axis);\r\n    }\r\n\r\n    /**\r\n     * Sets the maximum limit of the given axis for the physics engine.\r\n     * @param axis - The axis to set the limit for.\r\n     * @param limit - The maximum limit of the axis.\r\n     *\r\n     * This method is useful for setting the maximum limit of the given axis for the physics engine,\r\n     * which can be used to control the movement of the physics object. This helps to ensure that the\r\n     * physics object does not move beyond the given limit.\r\n     */\r\n    public setAxisMaxLimit(axis: PhysicsConstraintAxis, limit: number): void {\r\n        this._physicsPlugin.setAxisMaxLimit(this, axis, limit);\r\n    }\r\n\r\n    /**\r\n     * Gets the maximum limit of the given axis of the physics engine.\r\n     * @param axis - The axis of the physics engine.\r\n     * @returns The maximum limit of the given axis, or null if the constraint hasn't been initialized yet.\r\n     *\r\n     */\r\n    public getAxisMaxLimit(axis: PhysicsConstraintAxis): Nullable<number> {\r\n        return this._physicsPlugin.getAxisMaxLimit(this, axis);\r\n    }\r\n\r\n    /**\r\n     * Sets the motor type of the given axis of the constraint.\r\n     * @param axis - The axis of the constraint.\r\n     * @param motorType - The type of motor to use.\r\n     */\r\n    public setAxisMotorType(axis: PhysicsConstraintAxis, motorType: PhysicsConstraintMotorType): void {\r\n        this._physicsPlugin.setAxisMotorType(this, axis, motorType);\r\n    }\r\n\r\n    /**\r\n     * Gets the motor type of the specified axis of the constraint.\r\n     *\r\n     * @param axis - The axis of the constraint.\r\n     * @returns The motor type of the specified axis, or null if the constraint hasn't been initialized yet.\r\n     *\r\n     */\r\n    public getAxisMotorType(axis: PhysicsConstraintAxis): Nullable<PhysicsConstraintMotorType> {\r\n        return this._physicsPlugin.getAxisMotorType(this, axis);\r\n    }\r\n\r\n    /**\r\n     * Sets the target velocity of the motor associated with the given axis of the constraint.\r\n     * @param axis - The axis of the constraint.\r\n     * @param target - The target velocity of the motor.\r\n     *\r\n     * This method is useful for setting the target velocity of the motor associated with the given axis of the constraint.\r\n     */\r\n    public setAxisMotorTarget(axis: PhysicsConstraintAxis, target: number): void {\r\n        this._physicsPlugin.setAxisMotorTarget(this, axis, target);\r\n    }\r\n\r\n    /**\r\n     * Gets the target velocity of the motor associated to the given constraint axis.\r\n     * @param axis - The constraint axis associated to the motor.\r\n     * @returns The target velocity of the motor, or null if the constraint hasn't been initialized yet.\r\n     *\r\n     */\r\n    public getAxisMotorTarget(axis: PhysicsConstraintAxis): Nullable<number> {\r\n        return this._physicsPlugin.getAxisMotorTarget(this, axis);\r\n    }\r\n\r\n    /**\r\n     * Sets the maximum force of the motor of the given axis of the constraint.\r\n     * @param axis - The axis of the constraint.\r\n     * @param maxForce - The maximum force of the motor.\r\n     *\r\n     */\r\n    public setAxisMotorMaxForce(axis: PhysicsConstraintAxis, maxForce: number): void {\r\n        this._physicsPlugin.setAxisMotorMaxForce(this, axis, maxForce);\r\n    }\r\n\r\n    /**\r\n     * Gets the maximum force of the motor of the given axis of the constraint.\r\n     * @param axis - The axis of the constraint.\r\n     * @returns The maximum force of the motor, or null if the constraint hasn't been initialized yet.\r\n     *\r\n     */\r\n    public getAxisMotorMaxForce(axis: PhysicsConstraintAxis): Nullable<number> {\r\n        return this._physicsPlugin.getAxisMotorMaxForce(this, axis);\r\n    }\r\n}\r\n\r\n/**\r\n * Represents a Ball and Socket Constraint, used to simulate a joint\r\n * This class is useful for simulating a joint between two bodies in a physics engine.\r\n * It allows for the two bodies to move relative to each other in a way that mimics a ball and socket joint, such as a shoulder or hip joint.\r\n * @param pivotA - The first pivot, defined locally in the first body frame\r\n * @param pivotB - The second pivot, defined locally in the second body frame\r\n * @param axisA - The axis of the first body\r\n * @param axisB - The axis of the second body\r\n * @param scene - The scene the constraint is applied to\r\n * @returns The Ball and Socket Constraint\r\n */\r\nexport class BallAndSocketConstraint extends PhysicsConstraint {\r\n    constructor(pivotA: Vector3, pivotB: Vector3, axisA: Vector3, axisB: Vector3, scene: Scene) {\r\n        super(PhysicsConstraintType.BALL_AND_SOCKET, { pivotA: pivotA, pivotB: pivotB, axisA: axisA, axisB: axisB }, scene);\r\n    }\r\n}\r\n\r\n/**\r\n * Creates a distance constraint.\r\n *\r\n * This code is useful for creating a distance constraint in a physics engine.\r\n * A distance constraint is a type of constraint that keeps two objects at a certain distance from each other.\r\n * The scene is used to add the constraint to the physics engine.\r\n * @param maxDistance distance between bodies\r\n * @param scene The scene the constraint belongs to\r\n * @returns DistanceConstraint\r\n */\r\nexport class DistanceConstraint extends PhysicsConstraint {\r\n    constructor(maxDistance: number, scene: Scene) {\r\n        super(PhysicsConstraintType.DISTANCE, { maxDistance: maxDistance }, scene);\r\n    }\r\n}\r\n\r\n/**\r\n * Creates a HingeConstraint, which is a type of PhysicsConstraint.\r\n *\r\n * This code is useful for creating a HingeConstraint, which is a type of PhysicsConstraint.\r\n * This constraint is used to simulate a hinge joint between two rigid bodies, allowing them to rotate around a single axis.\r\n * @param pivotA - The first pivot point, in world space.\r\n * @param pivotB - The second pivot point, in world space.\r\n * @param scene - The scene the constraint is used in.\r\n * @returns The new HingeConstraint.\r\n */\r\nexport class HingeConstraint extends PhysicsConstraint {\r\n    constructor(pivotA: Vector3, pivotB: Vector3, axisA: Vector3, axisB: Vector3, scene: Scene) {\r\n        super(PhysicsConstraintType.HINGE, { pivotA: pivotA, pivotB: pivotB, axisA: axisA, axisB: axisB }, scene);\r\n    }\r\n}\r\n\r\n/**\r\n * Creates a SliderConstraint, which is a type of PhysicsConstraint.\r\n *\r\n * This code is useful for creating a SliderConstraint, which is a type of PhysicsConstraint.\r\n * It allows the user to specify the two pivots and two axes of the constraint in world space, as well as the scene the constraint belongs to.\r\n * This is useful for creating a constraint between two rigid bodies that allows them to move along a certain axis.\r\n * @param pivotA - The first pivot of the constraint, in world space.\r\n * @param pivotB - The second pivot of the constraint, in world space.\r\n * @param axisA - The first axis of the constraint, in world space.\r\n * @param axisB - The second axis of the constraint, in world space.\r\n * @param scene - The scene the constraint belongs to.\r\n * @returns The created SliderConstraint.\r\n */\r\nexport class SliderConstraint extends PhysicsConstraint {\r\n    constructor(pivotA: Vector3, pivotB: Vector3, axisA: Vector3, axisB: Vector3, scene: Scene) {\r\n        super(PhysicsConstraintType.SLIDER, { pivotA: pivotA, pivotB: pivotB, axisA: axisA, axisB: axisB }, scene);\r\n    }\r\n}\r\n\r\n/**\r\n * Creates a LockConstraint, which is a type of PhysicsConstraint.\r\n *\r\n * This code is useful for creating a LockConstraint, which is a type of PhysicsConstraint.\r\n * It takes in two pivots and two axes in local space, as well as the scene the constraint belongs to, and creates a LockConstraint.\r\n * @param pivotA - The first pivot of the constraint in local space.\r\n * @param pivotB - The second pivot of the constraint in local space.\r\n * @param axisA - The first axis of the constraint in local space.\r\n * @param axisB - The second axis of the constraint in local space.\r\n * @param scene - The scene the constraint belongs to.\r\n * @returns The created LockConstraint.\r\n */\r\nexport class LockConstraint extends PhysicsConstraint {\r\n    constructor(pivotA: Vector3, pivotB: Vector3, axisA: Vector3, axisB: Vector3, scene: Scene) {\r\n        super(PhysicsConstraintType.LOCK, { pivotA: pivotA, pivotB: pivotB, axisA: axisA, axisB: axisB }, scene);\r\n    }\r\n}\r\n\r\n/**\r\n * Creates a PrismaticConstraint, which is a type of PhysicsConstraint.\r\n *\r\n * This code is useful for creating a PrismaticConstraint, which is a type of PhysicsConstraint.\r\n * It takes in two pivots and two axes in local space, as well as the scene the constraint belongs to, and creates a PrismaticConstraint.\r\n * @param pivotA - The first pivot of the constraint in local space.\r\n * @param pivotB - The second pivot of the constraint in local space.\r\n * @param axisA - The first axis of the constraint in local space.\r\n * @param axisB - The second axis of the constraint in local space.\r\n * @param scene - The scene the constraint belongs to.\r\n * @returns The created LockConstraint.\r\n */\r\nexport class PrismaticConstraint extends PhysicsConstraint {\r\n    constructor(pivotA: Vector3, pivotB: Vector3, axisA: Vector3, axisB: Vector3, scene: Scene) {\r\n        super(PhysicsConstraintType.PRISMATIC, { pivotA: pivotA, pivotB: pivotB, axisA: axisA, axisB: axisB }, scene);\r\n    }\r\n}\r\n\r\n/**\r\n * Creates a SpringConstraint, which is a type of Physics6DoFConstraint. This constraint applies a force at the ends which is proportional\r\n * to the distance between ends, and a stiffness and damping factor. The force is calculated as (stiffness * positionError) - (damping * velocity)\r\n *\r\n * @param pivotA - The first pivot of the constraint in local space.\r\n * @param pivotB - The second pivot of the constraint in local space.\r\n * @param axisA - The first axis of the constraint in local space.\r\n * @param axisB - The second axis of the constraint in local space.\r\n * @param minDistance - The minimum distance between the two pivots.\r\n * @param maxDistance - The maximum distance between the two pivots.\r\n * @param stiffness - The stiffness of the spring.\r\n * @param damping - The damping of the spring.\r\n * @param scene - The scene the constraint belongs to.\r\n * @returns The created SpringConstraint.\r\n */\r\nexport class SpringConstraint extends Physics6DoFConstraint {\r\n    constructor(pivotA: Vector3, pivotB: Vector3, axisA: Vector3, axisB: Vector3, minDistance: number, maxDistance: number, stiffness: number, damping: number, scene: Scene) {\r\n        super({ pivotA, pivotB, axisA, axisB }, [{ axis: PhysicsConstraintAxis.LINEAR_DISTANCE, minLimit: minDistance, maxLimit: maxDistance, stiffness, damping }], scene);\r\n    }\r\n}\r\n", "/**\r\n * Determines how values from the PhysicsMaterial are combined when\r\n * two objects are in contact. When each PhysicsMaterial specifies\r\n * a different combine mode for some property, the combine mode which\r\n * is used will be selected based on their order in this enum - i.e.\r\n * a value later in this list will be preferentially used.\r\n */\r\nexport const enum PhysicsMaterialCombineMode {\r\n    /**\r\n     * The final value will be the geometric mean of the two values:\r\n     * sqrt( valueA *  valueB )\r\n     */\r\n    GEOMETRIC_MEAN,\r\n    /**\r\n     * The final value will be the smaller of the two:\r\n     * min( valueA , valueB )\r\n     */\r\n    MINIMUM,\r\n    /* The final value will be the larger of the two:\r\n     * max( valueA , valueB )\r\n     */\r\n    MAXIMUM,\r\n    /* The final value will be the arithmetic mean of the two values:\r\n     * (valueA + valueB) / 2\r\n     */\r\n    ARITHMETIC_MEAN,\r\n    /**\r\n     * The final value will be the product of the two values:\r\n     * valueA * valueB\r\n     */\r\n    MULTIPLY,\r\n}\r\n\r\n/**\r\n * Physics material class\r\n * Helps setting friction and restitution that are used to compute responding forces in collision response\r\n */\r\nexport interface PhysicsMaterial {\r\n    /**\r\n     * Sets the friction used by this material\r\n     *\r\n     * The friction determines how much an object will slow down when it is in contact with another object.\r\n     * This is important for simulating realistic physics, such as when an object slides across a surface.\r\n     *\r\n     * If not provided, a default value of 0.5 will be used.\r\n     */\r\n    friction?: number;\r\n\r\n    /**\r\n     * Sets the static friction used by this material.\r\n     *\r\n     * Static friction is the friction that must be overcome before a pair of objects can start sliding\r\n     * relative to each other; for physically-realistic behaviour, it should be at least as high as the\r\n     * normal friction value. If not provided, the friction value will be used\r\n     */\r\n    staticFriction?: number;\r\n\r\n    /**\r\n     * Sets the restitution of the physics material.\r\n     *\r\n     * The restitution is a factor which describes, the amount of energy that is retained after a collision,\r\n     * which should be a number between 0 and 1..\r\n     *\r\n     * A restitution of 0 means that no energy is retained and the objects will not bounce off each other,\r\n     * while a restitution of 1 means that all energy is retained and the objects will bounce.\r\n     *\r\n     * Note, though, due that due to the simulation implementation, an object with a restitution of 1 may\r\n     * still lose energy over time.\r\n     *\r\n     * If not provided, a default value of 0 will be used.\r\n     */\r\n    restitution?: number;\r\n\r\n    /**\r\n     * Describes how two different friction values should be combined. See PhysicsMaterialCombineMode for\r\n     * more details.\r\n     *\r\n     * If not provided, will use PhysicsMaterialCombineMode.MINIMUM\r\n     */\r\n    frictionCombine?: PhysicsMaterialCombineMode;\r\n\r\n    /**\r\n     * Describes how two different restitution values should be combined. See PhysicsMaterialCombineMode for\r\n     * more details.\r\n     *\r\n     * If not provided, will use PhysicsMaterialCombineMode.MAXIMUM\r\n     */\r\n    restitutionCombine?: PhysicsMaterialCombineMode;\r\n}\r\n", "import { PhysicsBody } from \"./physicsBody\";\r\nimport type { PhysicsMaterial } from \"./physicsMaterial\";\r\nimport { PhysicsShape } from \"./physicsShape\";\r\nimport { Logger } from \"../../Misc/logger\";\r\nimport type { Scene } from \"../../scene\";\r\nimport type { TransformNode } from \"../../Meshes/transformNode\";\r\nimport { Quaternion, TmpVectors, Vector3 } from \"../../Maths/math.vector\";\r\nimport { WithinEpsilon } from \"../../Maths/math.scalar.functions\";\r\nimport { PhysicsMotionType, PhysicsShapeType } from \"./IPhysicsEnginePlugin\";\r\nimport type { Mesh } from \"../../Meshes/mesh\";\r\nimport type { Observer } from \"../../Misc/observable\";\r\nimport type { Nullable } from \"../../types\";\r\nimport type { Node } from \"../../node\";\r\nimport type { AbstractMesh } from \"../../Meshes/abstractMesh\";\r\nimport { BoundingBox } from \"../../Culling/boundingBox\";\r\n\r\n/**\r\n * The interface for the physics aggregate parameters\r\n */\r\nexport interface PhysicsAggregateParameters {\r\n    /**\r\n     * The mass of the physics aggregate\r\n     */\r\n    mass: number;\r\n\r\n    /**\r\n     * The friction of the physics aggregate\r\n     */\r\n    friction?: number;\r\n\r\n    /**\r\n     * The coefficient of restitution of the physics aggregate\r\n     */\r\n    restitution?: number;\r\n\r\n    /**\r\n     * Radius for sphere, cylinder and capsule\r\n     */\r\n    radius?: number;\r\n\r\n    /**\r\n     * Starting point for cylinder/capsule\r\n     */\r\n    pointA?: Vector3;\r\n\r\n    /**\r\n     * Ending point for cylinder/capsule\r\n     */\r\n    pointB?: Vector3;\r\n\r\n    /**\r\n     * Extents for box\r\n     */\r\n    extents?: Vector3;\r\n\r\n    /**\r\n     * Orientation for box\r\n     */\r\n    rotation?: Quaternion;\r\n\r\n    /**\r\n     * mesh local center\r\n     */\r\n    center?: Vector3;\r\n\r\n    /**\r\n     * mesh object. Used for mesh and convex hull aggregates.\r\n     */\r\n    mesh?: Mesh;\r\n\r\n    /**\r\n     * Physics engine will try to make this body sleeping and not active\r\n     */\r\n    startAsleep?: boolean;\r\n\r\n    /**\r\n     * If true, mark the created shape as a trigger shape\r\n     */\r\n    isTriggerShape?: boolean;\r\n}\r\n/**\r\n * Helper class to create and interact with a PhysicsAggregate.\r\n * This is a transition object that works like Physics Plugin V1 Impostors.\r\n * This helper instanciate all mandatory physics objects to get a body/shape and material.\r\n * It's less efficient that handling body and shapes independently but for prototyping or\r\n * a small numbers of physics objects, it's good enough.\r\n */\r\nexport class PhysicsAggregate {\r\n    /**\r\n     * The body that is associated with this aggregate\r\n     */\r\n    public body: PhysicsBody;\r\n\r\n    /**\r\n     * The shape that is associated with this aggregate\r\n     */\r\n    public shape: PhysicsShape;\r\n\r\n    /**\r\n     * The material that is associated with this aggregate\r\n     */\r\n    public material: PhysicsMaterial;\r\n\r\n    private _disposeShapeWhenDisposed = true;\r\n\r\n    private _nodeDisposeObserver: Nullable<Observer<Node>>;\r\n\r\n    constructor(\r\n        /**\r\n         * The physics-enabled object used as the physics aggregate\r\n         */\r\n        public transformNode: TransformNode,\r\n        /**\r\n         * The type of the physics aggregate\r\n         */\r\n        public type: PhysicsShapeType | PhysicsShape,\r\n        private _options: PhysicsAggregateParameters = { mass: 0 },\r\n        private _scene?: Scene\r\n    ) {\r\n        //sanity check!\r\n        if (!this.transformNode) {\r\n            Logger.Error(\"No object was provided. A physics object is obligatory\");\r\n            return;\r\n        }\r\n        const m = transformNode as Mesh;\r\n        if (this.transformNode.parent && this._options.mass !== 0 && m.hasThinInstances) {\r\n            Logger.Warn(\r\n                \"A physics body has been created for an object which has a parent and thin instances. Babylon physics currently works in local space so unexpected issues may occur.\"\r\n            );\r\n        }\r\n\r\n        // Legacy support for old syntax.\r\n        if (!this._scene && transformNode.getScene) {\r\n            this._scene = transformNode.getScene();\r\n        }\r\n\r\n        if (!this._scene) {\r\n            return;\r\n        }\r\n\r\n        //default options params\r\n        this._options.mass = _options.mass === void 0 ? 0 : _options.mass;\r\n        this._options.friction = _options.friction === void 0 ? 0.2 : _options.friction;\r\n        this._options.restitution = _options.restitution === void 0 ? 0.2 : _options.restitution;\r\n\r\n        const motionType = this._options.mass === 0 ? PhysicsMotionType.STATIC : PhysicsMotionType.DYNAMIC;\r\n        const startAsleep = this._options.startAsleep ?? false;\r\n        this.body = new PhysicsBody(transformNode, motionType, startAsleep, this._scene);\r\n        this._addSizeOptions();\r\n        if ((type as any).getClassName && (type as any).getClassName() === \"PhysicsShape\") {\r\n            this.shape = type as PhysicsShape;\r\n            this._disposeShapeWhenDisposed = false;\r\n        } else {\r\n            this.shape = new PhysicsShape({ type: type as PhysicsShapeType, parameters: this._options as any }, this._scene);\r\n        }\r\n\r\n        if (this._options.isTriggerShape) {\r\n            this.shape.isTrigger = true;\r\n        }\r\n\r\n        this.material = { friction: this._options.friction, restitution: this._options.restitution };\r\n        this.body.shape = this.shape;\r\n        this.shape.material = this.material;\r\n\r\n        this.body.setMassProperties({ mass: this._options.mass });\r\n\r\n        this._nodeDisposeObserver = this.transformNode.onDisposeObservable.add(() => {\r\n            this.dispose();\r\n        });\r\n    }\r\n\r\n    private _getObjectBoundingBox() {\r\n        if ((this.transformNode as AbstractMesh).getRawBoundingInfo) {\r\n            return (this.transformNode as AbstractMesh).getRawBoundingInfo().boundingBox;\r\n        } else {\r\n            return new BoundingBox(new Vector3(-0.5, -0.5, -0.5), new Vector3(0.5, 0.5, 0.5));\r\n        }\r\n    }\r\n\r\n    private _hasVertices(node: TransformNode): boolean {\r\n        return (node as any)?.getTotalVertices() > 0;\r\n    }\r\n\r\n    private _addSizeOptions(): void {\r\n        this.transformNode.computeWorldMatrix(true);\r\n        const bb = this._getObjectBoundingBox();\r\n        const extents = TmpVectors.Vector3[0];\r\n        extents.copyFrom(bb.extendSize);\r\n        extents.scaleInPlace(2);\r\n        extents.multiplyInPlace(this.transformNode.absoluteScaling);\r\n        // In case we had any negative scaling, we need to take the absolute value of the extents.\r\n        extents.x = Math.abs(extents.x);\r\n        extents.y = Math.abs(extents.y);\r\n        extents.z = Math.abs(extents.z);\r\n\r\n        const min = TmpVectors.Vector3[1];\r\n        min.copyFrom(bb.minimum);\r\n        min.multiplyInPlace(this.transformNode.absoluteScaling);\r\n\r\n        if (!this._options.center) {\r\n            const center = new Vector3();\r\n            center.copyFrom(bb.center);\r\n            center.multiplyInPlace(this.transformNode.absoluteScaling);\r\n            this._options.center = center;\r\n        }\r\n\r\n        switch (this.type) {\r\n            case PhysicsShapeType.SPHERE:\r\n                if (!this._options.radius && WithinEpsilon(extents.x, extents.y, 0.0001) && WithinEpsilon(extents.x, extents.z, 0.0001)) {\r\n                    this._options.radius = extents.x / 2;\r\n                } else if (!this._options.radius) {\r\n                    Logger.Warn(\"Non uniform scaling is unsupported for sphere shapes. Setting the radius to the biggest bounding box extent.\");\r\n                    this._options.radius = Math.max(extents.x, extents.y, extents.z) / 2;\r\n                }\r\n                break;\r\n            case PhysicsShapeType.CAPSULE:\r\n                {\r\n                    const capRadius = extents.x / 2;\r\n                    this._options.radius = this._options.radius ?? capRadius;\r\n                    this._options.pointA = this._options.pointA ?? new Vector3(0, min.y + capRadius, 0);\r\n                    this._options.pointB = this._options.pointB ?? new Vector3(0, min.y + extents.y - capRadius, 0);\r\n                }\r\n                break;\r\n            case PhysicsShapeType.CYLINDER:\r\n                {\r\n                    const capRadius = extents.x / 2;\r\n                    this._options.radius = this._options.radius ?? capRadius;\r\n                    this._options.pointA = this._options.pointA ?? new Vector3(0, min.y, 0);\r\n                    this._options.pointB = this._options.pointB ?? new Vector3(0, min.y + extents.y, 0);\r\n                }\r\n                break;\r\n            case PhysicsShapeType.MESH:\r\n            case PhysicsShapeType.CONVEX_HULL:\r\n            case PhysicsShapeType.HEIGHTFIELD:\r\n                if (!this._options.mesh && this._hasVertices(this.transformNode)) {\r\n                    this._options.mesh = this.transformNode as Mesh;\r\n                } else if (!this._options.mesh || !this._hasVertices(this._options.mesh)) {\r\n                    throw new Error(\r\n                        \"No valid mesh was provided for mesh or convex hull shape parameter. Please provide a mesh with valid geometry (number of vertices greater than 0).\"\r\n                    );\r\n                }\r\n                break;\r\n            case PhysicsShapeType.BOX:\r\n                this._options.extents = this._options.extents ?? new Vector3(extents.x, extents.y, extents.z);\r\n                this._options.rotation = this._options.rotation ?? Quaternion.Identity();\r\n                break;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Releases the body, shape and material\r\n     */\r\n    public dispose(): void {\r\n        if (this._nodeDisposeObserver) {\r\n            this.body.transformNode.onDisposeObservable.remove(this._nodeDisposeObserver);\r\n            this._nodeDisposeObserver = null;\r\n        }\r\n        this.body.dispose();\r\n        if (this._disposeShapeWhenDisposed) {\r\n            this.shape.dispose();\r\n        }\r\n    }\r\n}\r\n", "import type { Skeleton } from \"../../Bones/skeleton\";\r\nimport { Vector3, Matrix, TmpVectors, Quaternion } from \"../../Maths/math.vector\";\r\nimport type { Scene } from \"../../scene\";\r\nimport { PhysicsAggregate } from \"./physicsAggregate\";\r\nimport { PhysicsConstraint } from \"./physicsConstraint\";\r\nimport type { Mesh } from \"../../Meshes/mesh\";\r\nimport { Axis, Space } from \"core/Maths/math.axis\";\r\nimport { PhysicsShapeType, PhysicsConstraintType, PhysicsMotionType } from \"./IPhysicsEnginePlugin\";\r\nimport type { Nullable } from \"../../types\";\r\nimport type { Bone } from \"../../Bones/bone\";\r\nimport { Logger } from \"../../Misc/logger\";\r\nimport { TransformNode } from \"../../Meshes/transformNode\";\r\n\r\n/**\r\n * Ragdoll bone properties\r\n * @experimental\r\n */\r\nexport class RagdollBoneProperties {\r\n    /**\r\n     * Width of the box shape\r\n     */\r\n    width?: number;\r\n    /**\r\n     * depth of the box shape\r\n     */\r\n    depth?: number;\r\n    /**\r\n     * height of the box shape\r\n     */\r\n    height?: number;\r\n    /**\r\n     * size that will be used of width, depth and height of the shape box\r\n     */\r\n    size?: number;\r\n    /**\r\n     * Type of Physics Constraint used between bones\r\n     */\r\n    joint?: number | undefined;\r\n    /**\r\n     * Main rotation axis used by the constraint, in local space\r\n     */\r\n    rotationAxis?: Vector3;\r\n    /**\r\n     * Minimum rotation angle value\r\n     */\r\n    min?: number;\r\n    /**\r\n     * Maximum rotation angle value\r\n     */\r\n    max?: number;\r\n    /**\r\n     * Offset along local axis\r\n     */\r\n    boxOffset?: number;\r\n    /**\r\n     * Axis that need an offset\r\n     */\r\n    boneOffsetAxis?: Vector3;\r\n}\r\n\r\n/**\r\n * Ragdoll for Physics V2\r\n * @experimental\r\n */\r\nexport class Ragdoll {\r\n    private _skeleton: Skeleton;\r\n    private _scene: Scene;\r\n    private _rootTransformNode: Mesh | TransformNode;\r\n    private _config: any;\r\n    private _boxConfigs: Array<RagdollBoneProperties> = new Array<RagdollBoneProperties>();\r\n    private _joints: Array<PhysicsConstraint> = new Array<PhysicsConstraint>();\r\n    private _bones: Array<Bone> = new Array<Bone>();\r\n    private _initialRotation: Array<Quaternion> = new Array<Quaternion>();\r\n    // without mesh transform, to figure out later\r\n    private _initialRotation2: Array<Quaternion> = new Array<Quaternion>();\r\n    private _boneNames: string[] = [];\r\n    private _transforms: Array<TransformNode> = new Array<TransformNode>();\r\n    private _aggregates: Array<PhysicsAggregate> = new Array<PhysicsAggregate>();\r\n    private _ragdollMode: boolean = false;\r\n    private _rootBoneName: string = \"\";\r\n    private _rootBoneIndex: number = -1;\r\n    private _mass: number = 10;\r\n    private _restitution: number = 0;\r\n\r\n    /**\r\n     * Pause synchronization between physics and bone position/orientation\r\n     */\r\n    public pauseSync: boolean = false;\r\n\r\n    private _putBoxesInBoneCenter: boolean;\r\n    private _defaultJoint: number = PhysicsConstraintType.HINGE;\r\n    private _defaultJointMin: number = -90;\r\n    private _defaultJointMax: number = 90;\r\n\r\n    /**\r\n     * Construct a new Ragdoll object. Once ready, it can be made dynamic by calling `Ragdoll` method\r\n     * @param skeleton The skeleton containing bones to be physicalized\r\n     * @param rootTransformNode The mesh or its transform used by the skeleton\r\n     * @param config an array of `RagdollBoneProperties` corresponding to bones and their properties used to instanciate physics bodies\r\n     */\r\n    constructor(skeleton: Skeleton, rootTransformNode: Mesh | TransformNode, config: RagdollBoneProperties[]) {\r\n        this._skeleton = skeleton;\r\n        this._scene = skeleton.getScene();\r\n        this._rootTransformNode = rootTransformNode;\r\n        this._config = config; // initial, user defined box configs. May have several box configs jammed into 1 index.\r\n        this._boxConfigs = []; // final box configs. Every element is a separate box config (this.config may have several configs jammed into 1 index).\r\n        this._putBoxesInBoneCenter = false;\r\n        this._defaultJoint = PhysicsConstraintType.HINGE;\r\n\r\n        this._init();\r\n    }\r\n\r\n    /**\r\n     * Returns the aggregate corresponding to the ragdoll bone index\r\n     * @param index ragdoll bone aggregate index\r\n     * @returns the aggregate for the bone index for the root aggregate if index is invalid\r\n     */\r\n    public getAggregate(index: number): PhysicsAggregate {\r\n        if (index < 0 || index >= this._aggregates.length) {\r\n            return this._aggregates[this._rootBoneIndex];\r\n        }\r\n        return this._aggregates[index];\r\n    }\r\n\r\n    private _createColliders(): void {\r\n        this._rootTransformNode.computeWorldMatrix();\r\n        this._skeleton.computeAbsoluteMatrices(true);\r\n        this._skeleton.prepare(true);\r\n\r\n        const config = this._config;\r\n        for (let i = 0; i < config.length; i++) {\r\n            const boneNames = config[i].bone !== undefined ? [config[i].bone] : config[i].bones;\r\n\r\n            for (let ii = 0; ii < boneNames.length; ii++) {\r\n                const currentBone = this._skeleton.bones[this._skeleton.getBoneIndexByName(boneNames[ii])];\r\n                if (currentBone == undefined) {\r\n                    return;\r\n                }\r\n\r\n                // First define the box dimensions, so we can then use them when calling CreateBox().\r\n                const currentRagdollBoneProperties: RagdollBoneProperties = {\r\n                    width: this._config[i].width,\r\n                    depth: this._config[i].depth,\r\n                    height: this._config[i].height,\r\n                    size: this._config[i].size,\r\n                };\r\n\r\n                currentRagdollBoneProperties.width = currentRagdollBoneProperties.width ?? currentRagdollBoneProperties.size;\r\n                currentRagdollBoneProperties.depth = currentRagdollBoneProperties.depth ?? currentRagdollBoneProperties.size;\r\n                currentRagdollBoneProperties.height = currentRagdollBoneProperties.height ?? currentRagdollBoneProperties.size;\r\n                const transform = new TransformNode(boneNames[ii] + \"_transform\", this._scene);\r\n\r\n                // Define the rest of the box properties.\r\n                currentRagdollBoneProperties.joint = config[i].joint !== undefined ? config[i].joint : this._defaultJoint;\r\n                currentRagdollBoneProperties.rotationAxis = config[i].rotationAxis !== undefined ? config[i].rotationAxis : Axis.X;\r\n                currentRagdollBoneProperties.min = config[i].min !== undefined ? config[i].min : this._defaultJointMin;\r\n                currentRagdollBoneProperties.max = config[i].max !== undefined ? config[i].max : this._defaultJointMax;\r\n\r\n                // Offset value.\r\n                let boxOffset = 0;\r\n                if ((config[i].putBoxInBoneCenter !== undefined && config[i].putBoxInBoneCenter) || this._putBoxesInBoneCenter) {\r\n                    if (currentBone.length === undefined) {\r\n                        Logger.Log(\"The length property is not defined for bone \" + currentBone.name);\r\n                    }\r\n                    boxOffset = currentBone.length / 2;\r\n                } else if (config[i].boxOffset !== undefined) {\r\n                    boxOffset = config[i].boxOffset;\r\n                }\r\n                currentRagdollBoneProperties.boxOffset = boxOffset;\r\n\r\n                // Offset axis.\r\n                const boneOffsetAxis = config[i].boneOffsetAxis !== undefined ? config[i].boneOffsetAxis : Axis.Y;\r\n                const boneDir = currentBone.getDirection(boneOffsetAxis, this._rootTransformNode);\r\n                currentRagdollBoneProperties.boneOffsetAxis = boneOffsetAxis;\r\n\r\n                transform.position = currentBone.getAbsolutePosition(this._rootTransformNode).add(boneDir.scale(boxOffset));\r\n\r\n                const mass = config[i].mass !== undefined ? config[i].mass : this._mass;\r\n                const restitution = config[i].restitution !== undefined ? config[i].restitution : this._restitution;\r\n                const aggregate = new PhysicsAggregate(\r\n                    transform,\r\n                    PhysicsShapeType.BOX,\r\n                    {\r\n                        mass: mass,\r\n                        restitution: restitution,\r\n                        friction: 0.6,\r\n                        extents: new Vector3(currentRagdollBoneProperties.width, currentRagdollBoneProperties.height, currentRagdollBoneProperties.depth),\r\n                    },\r\n                    this._scene\r\n                );\r\n                aggregate.body.setCollisionCallbackEnabled(true);\r\n                aggregate.body.disablePreStep = false;\r\n                aggregate.body.setMotionType(PhysicsMotionType.ANIMATED);\r\n                this._aggregates.push(aggregate);\r\n                this._bones.push(currentBone);\r\n                this._boneNames.push(currentBone.name);\r\n                this._transforms.push(transform);\r\n                this._boxConfigs.push(currentRagdollBoneProperties);\r\n                this._initialRotation.push(currentBone.getRotationQuaternion(Space.WORLD, this._rootTransformNode));\r\n                this._initialRotation2.push(currentBone.getRotationQuaternion(Space.WORLD));\r\n            }\r\n        }\r\n    }\r\n\r\n    private _initJoints(): void {\r\n        this._rootTransformNode.computeWorldMatrix();\r\n        for (let i = 0; i < this._bones.length; i++) {\r\n            // The root bone has no joints.\r\n            if (i == this._rootBoneIndex) continue;\r\n\r\n            const nearestParent = this._findNearestParent(i);\r\n\r\n            if (nearestParent == null) {\r\n                Logger.Warn(\"Couldn't find a nearest parent bone in the configs for bone called \" + this._boneNames[i]);\r\n                return;\r\n            }\r\n\r\n            const boneParentIndex = this._boneNames.indexOf(nearestParent.name);\r\n\r\n            let distanceFromParentBoxToBone = this._bones[i].getAbsolutePosition(this._rootTransformNode).subtract(this._transforms[boneParentIndex].position);\r\n\r\n            const wmat = this._transforms[boneParentIndex].computeWorldMatrix();\r\n            const invertedWorldMat = Matrix.Invert(wmat);\r\n            distanceFromParentBoxToBone = Vector3.TransformCoordinates(this._bones[i].getAbsolutePosition(this._rootTransformNode), invertedWorldMat);\r\n\r\n            const boneAbsPos = this._bones[i].getAbsolutePosition(this._rootTransformNode);\r\n            const boxAbsPos = this._transforms[i].position.clone();\r\n            const myConnectedPivot = boneAbsPos.subtract(boxAbsPos);\r\n\r\n            const joint = new PhysicsConstraint(\r\n                PhysicsConstraintType.BALL_AND_SOCKET,\r\n                {\r\n                    pivotA: distanceFromParentBoxToBone,\r\n                    pivotB: myConnectedPivot,\r\n                    axisA: this._boxConfigs[i].rotationAxis!,\r\n                    axisB: this._boxConfigs[i].rotationAxis!,\r\n                    collision: false,\r\n                },\r\n                this._scene\r\n            );\r\n\r\n            this._aggregates[boneParentIndex].body.addConstraint(this._aggregates[i].body, joint);\r\n            joint.isEnabled = false;\r\n            this._joints.push(joint);\r\n        }\r\n    }\r\n\r\n    // set physics body orientation/position from bones\r\n    private _syncBonesToPhysics(): void {\r\n        const rootMatrix = this._rootTransformNode.getWorldMatrix();\r\n        for (let i = 0; i < this._bones.length; i++) {\r\n            // position\r\n            const transform = this._aggregates[i].transformNode;\r\n            const rootPos = this._bones[i].getAbsolutePosition();\r\n            Vector3.TransformCoordinatesToRef(rootPos, rootMatrix, transform.position);\r\n\r\n            // added offset\r\n            this._bones[i].getDirectionToRef(this._boxConfigs[i].boneOffsetAxis!, this._rootTransformNode, TmpVectors.Vector3[0]);\r\n            TmpVectors.Vector3[0].scaleInPlace(this._boxConfigs[i].boxOffset ?? 0);\r\n            transform.position.addInPlace(TmpVectors.Vector3[0]);\r\n\r\n            this._setBoneOrientationToBody(i);\r\n        }\r\n    }\r\n\r\n    private _setBoneOrientationToBody(boneIndex: number): void {\r\n        const transform = this._aggregates[boneIndex].transformNode;\r\n        const bone = this._bones[boneIndex];\r\n        this._initialRotation[boneIndex].conjugateToRef(TmpVectors.Quaternion[0]);\r\n        bone.getRotationQuaternionToRef(Space.WORLD, this._rootTransformNode, TmpVectors.Quaternion[1]);\r\n        TmpVectors.Quaternion[1].multiplyToRef(TmpVectors.Quaternion[0], transform.rotationQuaternion!);\r\n        transform.rotationQuaternion!.normalize();\r\n    }\r\n\r\n    private _syncBonesAndBoxes(): void {\r\n        if (this.pauseSync) {\r\n            return;\r\n        }\r\n\r\n        if (this._ragdollMode) {\r\n            this._setBodyOrientationToBone(this._rootBoneIndex);\r\n\r\n            const rootPos = this._aggregates[this._rootBoneIndex].body.transformNode.position;\r\n            this._rootTransformNode.getWorldMatrix().invertToRef(TmpVectors.Matrix[0]);\r\n\r\n            Vector3.TransformCoordinatesToRef(rootPos, TmpVectors.Matrix[0], TmpVectors.Vector3[0]);\r\n            this._bones[this._rootBoneIndex].setAbsolutePosition(TmpVectors.Vector3[0]);\r\n\r\n            for (let i = 0; i < this._bones.length; i++) {\r\n                if (i == this._rootBoneIndex) continue;\r\n                this._setBodyOrientationToBone(i);\r\n            }\r\n        } else {\r\n            this._syncBonesToPhysics();\r\n        }\r\n    }\r\n\r\n    private _setBodyOrientationToBone(boneIndex: number): void {\r\n        const qmesh =\r\n            this._rootTransformNode.rotationQuaternion ??\r\n            Quaternion.FromEulerAngles(this._rootTransformNode.rotation.x, this._rootTransformNode.rotation.y, this._rootTransformNode.rotation.z);\r\n        const qbind = this._initialRotation2[boneIndex];\r\n        const qphys = this._aggregates[boneIndex].body?.transformNode?.rotationQuaternion!;\r\n\r\n        qmesh.multiplyToRef(qbind, TmpVectors.Quaternion[1]);\r\n        qphys.multiplyToRef(TmpVectors.Quaternion[1], TmpVectors.Quaternion[0]);\r\n\r\n        this._bones[boneIndex].setRotationQuaternion(TmpVectors.Quaternion[0], Space.WORLD, this._rootTransformNode);\r\n    }\r\n\r\n    // Return true if root bone is valid/exists in this.bonesNames. false otherwise.\r\n    private _defineRootBone(): boolean {\r\n        const skeletonRoots = this._skeleton.getChildren();\r\n        if (skeletonRoots.length != 1) {\r\n            Logger.Log(\"Ragdoll creation failed: there can only be one root in the skeleton.\");\r\n            return false;\r\n        }\r\n\r\n        this._rootBoneName = skeletonRoots[0].name;\r\n        this._rootBoneIndex = this._boneNames.indexOf(this._rootBoneName);\r\n        if (this._rootBoneIndex == -1) {\r\n            Logger.Log(\"Ragdoll creation failed: the array boneNames doesn't have the root bone. The root bone is \" + this._skeleton.getChildren());\r\n            return false;\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    private _findNearestParent(boneIndex: number): any {\r\n        let nearestParent: Nullable<Bone> | undefined = this._bones[boneIndex].getParent();\r\n        do {\r\n            if (nearestParent != null && this._boneNames.includes(nearestParent.name)) {\r\n                break;\r\n            }\r\n\r\n            nearestParent = nearestParent?.getParent();\r\n        } while (nearestParent != null);\r\n\r\n        return nearestParent;\r\n    }\r\n\r\n    private _init() {\r\n        this._createColliders();\r\n\r\n        // If this.defineRootBone() returns ... there is not root bone.\r\n        if (!this._defineRootBone()) {\r\n            return;\r\n        }\r\n\r\n        this._initJoints();\r\n        this._scene.registerBeforeRender(() => {\r\n            this._syncBonesAndBoxes();\r\n        });\r\n        this._syncBonesToPhysics();\r\n    }\r\n\r\n    /**\r\n     * Enable ragdoll mode. Create physics objects and make them dynamic.\r\n     */\r\n    public ragdoll(): void {\r\n        this._ragdollMode = true;\r\n        // detach bones with link transform to let physics have control\r\n        this._skeleton.bones.forEach((bone) => {\r\n            bone.linkTransformNode(null);\r\n        });\r\n        for (let i = 0; i < this._joints.length; i++) {\r\n            this._joints[i].isEnabled = true;\r\n        }\r\n        for (let i = 0; i < this._aggregates.length; i++) {\r\n            this._aggregates[i].body.setMotionType(PhysicsMotionType.DYNAMIC);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Dispose resources and remove physics objects\r\n     */\r\n    dispose(): void {\r\n        this._aggregates.forEach((aggregate: PhysicsAggregate) => {\r\n            aggregate.dispose();\r\n        });\r\n    }\r\n}\r\n", "import { Vector3, Quaternion, Matrix, TmpVectors } from \"../../Maths/math.vector\";\r\nimport type { Scene } from \"../../scene\";\r\nimport type { DeepImmutableObject } from \"../../types\";\r\nimport type { PhysicsBody } from \"./physicsBody\";\r\nimport { PhysicsShapeCapsule, type PhysicsShape } from \"./physicsShape\";\r\nimport { PhysicsMotionType } from \"./IPhysicsEnginePlugin\";\r\nimport type { HavokPlugin } from \"./Plugins/havokPlugin\";\r\nimport { BuildArray } from \"core/Misc/arrayTools\";\r\n\r\n/**\r\n * Shape properties for the character controller\r\n */\r\nexport interface CharacterShapeOptions {\r\n    /**\r\n     * optional shape used for collision detection\r\n     */\r\n    shape?: PhysicsShape;\r\n    /**\r\n     * capsule height for the capsule shape if no shape is provided\r\n     */\r\n    capsuleHeight?: number;\r\n    /**\r\n     * capsule radius for the capsule shape if no shape is provided\r\n     */\r\n    capsuleRadius?: number;\r\n}\r\n/**\r\n * State of the character on the surface\r\n */\r\nexport const enum CharacterSupportedState {\r\n    UNSUPPORTED,\r\n    SLIDING,\r\n    SUPPORTED,\r\n}\r\n\r\n/**\r\n * Surface information computed by checkSupport method\r\n */\r\nexport interface CharacterSurfaceInfo {\r\n    /**\r\n     * Indicates whether the surface is dynamic.\r\n     * A dynamic surface is one that can change its properties over time,\r\n     * such as moving platforms or surfaces that can be affected by external forces.\r\n     */\r\n    isSurfaceDynamic: boolean;\r\n    /**\r\n     * The supported state of the character on the surface.\r\n     */\r\n    supportedState: CharacterSupportedState;\r\n    /**\r\n     * The average normal vector of the surface.\r\n     * This vector is perpendicular to the surface and points outwards.\r\n     */\r\n    averageSurfaceNormal: Vector3;\r\n    /**\r\n     * The average velocity of the surface.\r\n     * This vector represents the speed and direction in which the surface is moving.\r\n     */\r\n    averageSurfaceVelocity: Vector3;\r\n    /**\r\n     * The average angular velocity of the surface.\r\n     */\r\n    averageAngularSurfaceVelocity: Vector3;\r\n}\r\n\r\n/** @internal */\r\ninterface Contact {\r\n    /** @internal */\r\n    position: Vector3;\r\n    /** @internal */\r\n    normal: Vector3;\r\n    /** @internal */\r\n    distance: number;\r\n    /** @internal */\r\n    fraction: number;\r\n    /** @internal */\r\n    bodyB: { body: PhysicsBody; index: number };\r\n    /** @internal */\r\n    allowedPenetration: number;\r\n}\r\n\r\n/** @internal */\r\ninterface SurfaceConstraintInfo {\r\n    /** @internal */\r\n    planeNormal: Vector3;\r\n    /** @internal */\r\n    planeDistance: number;\r\n    /** @internal */\r\n    velocity: Vector3;\r\n    /** @internal */\r\n    angularVelocity: Vector3;\r\n    /** @internal */\r\n    staticFriction: number;\r\n    /** @internal */\r\n    extraUpStaticFriction: number;\r\n    /** @internal */\r\n    extraDownStaticFriction: number;\r\n    /** @internal */\r\n    dynamicFriction: number;\r\n    /** @internal */\r\n    priority: number;\r\n}\r\n\r\n/** @internal */\r\nconst enum SurfaceConstraintInteractionStatus {\r\n    OK,\r\n    FAILURE_3D,\r\n    FAILURE_2D,\r\n}\r\n\r\n/** @internal */\r\ninterface SurfaceConstraintInteraction {\r\n    /** @internal */\r\n    touched: boolean;\r\n    /** @internal */\r\n    stopped: boolean;\r\n    /** @internal */\r\n    surfaceTime: number;\r\n    /** @internal */\r\n    penaltyDistance: number;\r\n    /** @internal */\r\n    status: SurfaceConstraintInteractionStatus;\r\n}\r\n\r\n/** @internal */\r\nclass SimplexSolverOutput {\r\n    /** @internal */\r\n    public position: Vector3;\r\n    /** @internal */\r\n    public velocity: Vector3;\r\n    /** @internal */\r\n    public deltaTime: number;\r\n    /** @internal */\r\n    public planeInteractions: SurfaceConstraintInteraction[];\r\n}\r\n\r\n/** @internal */\r\nclass SimplexSolverActivePlanes {\r\n    /** @internal */\r\n    public index: number;\r\n    /** @internal */\r\n    public constraint: SurfaceConstraintInfo;\r\n    /** @internal */\r\n    public interaction: SurfaceConstraintInteraction;\r\n\r\n    /** @internal */\r\n    public copyFrom(other: SimplexSolverActivePlanes) {\r\n        this.index = other.index;\r\n        this.constraint = other.constraint;\r\n        this.interaction = other.interaction;\r\n    }\r\n}\r\n\r\n/** @internal */\r\nclass SimplexSolverInfo {\r\n    /** @internal */\r\n    public supportPlanes: Array<SimplexSolverActivePlanes> = new Array<SimplexSolverActivePlanes>(4);\r\n    /** @internal */\r\n    public numSupportPlanes: number = 0;\r\n    /** @internal */\r\n    public currentTime: number = 0;\r\n    /** @internal */\r\n    public inputConstraints: SurfaceConstraintInfo[];\r\n    /** @internal */\r\n    public outputInteractions: SurfaceConstraintInteraction[];\r\n    /** @internal */\r\n    public getOutput(constraint: SurfaceConstraintInfo): SurfaceConstraintInteraction {\r\n        return this.outputInteractions[this.inputConstraints.indexOf(constraint)]; //<todo.eoin This is O(1) in C++! Equivalent in TS?\r\n    }\r\n}\r\n\r\n/** @internal */\r\nfunction contactFromCast(hp: HavokPlugin, cp: any /*ContactPoint*/, castPath: Vector3, hitFraction: number, keepDistance: number): Contact {\r\n    //@ts-ignore\r\n    const bodyMap = hp._bodies;\r\n\r\n    const normal = Vector3.FromArray(cp[4]);\r\n    const dist = -hitFraction * castPath.dot(normal);\r\n    return {\r\n        position: Vector3.FromArray(cp[3]),\r\n        normal: normal,\r\n        distance: dist,\r\n        fraction: hitFraction,\r\n        bodyB: bodyMap.get(cp[0][0])!,\r\n        allowedPenetration: Math.min(Math.max(keepDistance - dist, 0.0), keepDistance),\r\n    };\r\n}\r\n\r\n/**\r\n * Character controller using physics\r\n */\r\nexport class PhysicsCharacterController {\r\n    private _position: Vector3;\r\n    private _orientation: Quaternion = Quaternion.Identity();\r\n    private _velocity: Vector3;\r\n    private _lastVelocity: Vector3;\r\n    private _shape: PhysicsShape;\r\n    private _manifold: Contact[] = [];\r\n    private _lastDisplacement: Vector3;\r\n    private _contactAngleSensitivity = 10.0;\r\n    private _lastInvDeltaTime: number;\r\n    private _scene: Scene;\r\n    private _tmpMatrix = new Matrix();\r\n    private _tmpVecs: Vector3[] = BuildArray(31, Vector3.Zero);\r\n\r\n    /**\r\n     * minimum distance to make contact\r\n     * default 0.05\r\n     */\r\n    public keepDistance: number = 0.05;\r\n    /**\r\n     * maximum distance to keep contact\r\n     * default 0.1\r\n     */\r\n    public keepContactTolerance: number = 0.1;\r\n    /**\r\n     * maximum number of raycast per integration starp\r\n     * default 10\r\n     */\r\n    public maxCastIterations: number = 10;\r\n    /**\r\n     * speed when recovery from penetration\r\n     * default 1.0\r\n     */\r\n    public penetrationRecoverySpeed = 1.0;\r\n    /**\r\n     * friction with static surfaces\r\n     * default 0\r\n     */\r\n    public staticFriction = 0;\r\n    /**\r\n     * friction with dynamic surfaces\r\n     * default 1\r\n     */\r\n    public dynamicFriction = 1;\r\n    /**\r\n     * cosine value of slop angle that can be climbed\r\n     * computed as `Math.cos(Math.PI * (angleInDegree / 180.0));`\r\n     * default 0.5 (value for a 60deg angle)\r\n     */\r\n    public maxSlopeCosine = 0.5;\r\n    /**\r\n     * character maximum speed\r\n     * default 10\r\n     */\r\n    public maxCharacterSpeedForSolver = 10.0;\r\n    /**\r\n     * up vector\r\n     */\r\n    public up = new Vector3(0, 1, 0);\r\n    /**\r\n     * Strength when pushing other bodies\r\n     * default 1e38\r\n     */\r\n    public characterStrength = 1e38;\r\n    /**\r\n     * character mass\r\n     * default 0\r\n     */\r\n    public characterMass = 0;\r\n    private _startCollector;\r\n    private _castCollector;\r\n\r\n    /**\r\n     * instanciate a new characterController\r\n     * @param position Initial position\r\n     * @param characterShapeOptions character physics shape options\r\n     * @param scene Scene\r\n     */\r\n    public constructor(position: Vector3, characterShapeOptions: CharacterShapeOptions, scene: Scene) {\r\n        this._position = position.clone();\r\n        this._velocity = Vector3.Zero();\r\n        this._lastVelocity = Vector3.Zero();\r\n        const r = characterShapeOptions.capsuleRadius ?? 0.6;\r\n        const h = characterShapeOptions.capsuleHeight ?? 1.8;\r\n        this._tmpVecs[0].set(0, h * 0.5 - r, 0);\r\n        this._tmpVecs[1].set(0, -h * 0.5 + r, 0);\r\n        this._shape = characterShapeOptions.shape ?? new PhysicsShapeCapsule(this._tmpVecs[0], this._tmpVecs[1], r, scene);\r\n        this._lastInvDeltaTime = 1.0 / 60.0;\r\n        this._lastDisplacement = Vector3.Zero();\r\n        this._scene = scene;\r\n\r\n        const hk = this._scene.getPhysicsEngine()!.getPhysicsPlugin() as HavokPlugin;\r\n        const hknp = hk._hknp;\r\n\r\n        this._startCollector = hknp.HP_QueryCollector_Create(16)[1];\r\n        this._castCollector = hknp.HP_QueryCollector_Create(16)[1];\r\n    }\r\n\r\n    /**\r\n     * Character position\r\n     * @returns Character position\r\n     */\r\n    public getPosition(): Vector3 {\r\n        return this._position;\r\n    }\r\n\r\n    /**\r\n     * Character velocity\r\n     * @returns Character velocity vector\r\n     */\r\n    public getVelocity(): Vector3 {\r\n        return this._velocity;\r\n    }\r\n\r\n    /**\r\n     * Set velocity vector\r\n     * @param velocity vector\r\n     */\r\n    public setVelocity(velocity: Vector3) {\r\n        this._velocity.copyFrom(velocity);\r\n    }\r\n\r\n    protected _validateManifold() {\r\n        const newManifold = [];\r\n        for (let i = 0; i < this._manifold.length; i++) {\r\n            if (!this._manifold[i].bodyB.body.isDisposed) {\r\n                newManifold.push(this._manifold[i]);\r\n            }\r\n        }\r\n        this._manifold = newManifold;\r\n    }\r\n\r\n    private _getPointVelocityToRef(body: { body: PhysicsBody; index: number }, pointWorld: Vector3, result: Vector3) {\r\n        //<todo does this really not exist in body interface?\r\n        const comWorld = this._tmpVecs[10];\r\n        this._getComWorldToRef(body, comWorld);\r\n        const relPos = this._tmpVecs[11];\r\n        pointWorld.subtractToRef(comWorld, relPos);\r\n        const av = this._tmpVecs[12];\r\n        body.body.getAngularVelocityToRef(av, body.index);\r\n        const arm = this._tmpVecs[13];\r\n        Vector3.CrossToRef(av, relPos, arm);\r\n        arm.addToRef(body.body.getLinearVelocity(body.index), result);\r\n    }\r\n\r\n    protected _compareContacts(contactA: Contact, contactB: Contact): number {\r\n        const angSquared = (1.0 - contactA.normal.dot(contactB.normal)) * this._contactAngleSensitivity * this._contactAngleSensitivity;\r\n        const planeDistSquared = (contactA.distance - contactB.distance) * (contactA.distance * contactB.distance);\r\n\r\n        const p1Vel = this._tmpVecs[7];\r\n        this._getPointVelocityToRef(contactA.bodyB, contactA.position, p1Vel);\r\n        const p2Vel = this._tmpVecs[8];\r\n        this._getPointVelocityToRef(contactB.bodyB, contactB.position, p2Vel);\r\n        const velocityDiff = this._tmpVecs[9];\r\n        p1Vel.subtractToRef(p2Vel, velocityDiff);\r\n        const velocityDiffSquared = velocityDiff.lengthSquared();\r\n\r\n        const fitness = angSquared * 10.0 + velocityDiffSquared * 0.1 + planeDistSquared;\r\n        return fitness;\r\n    }\r\n\r\n    protected _findContact(referenceContact: Contact, contactList: Contact[], threshold: number) {\r\n        let bestIdx = -1;\r\n        let bestFitness = threshold;\r\n        for (let i = 0; i < contactList.length; i++) {\r\n            const fitness = this._compareContacts(referenceContact, contactList[i]);\r\n            if (fitness < bestFitness) {\r\n                bestFitness = fitness;\r\n                bestIdx = i;\r\n            }\r\n        }\r\n        return bestIdx;\r\n    }\r\n\r\n    public _updateManifold(startCollector: any /*HP_CollectorId*/, castCollector: any /*HP_CollectorId*/, castPath: Vector3): number {\r\n        const hk = this._scene.getPhysicsEngine()!.getPhysicsPlugin() as HavokPlugin;\r\n        const hknp = hk._hknp;\r\n\r\n        const numProximityHits = hknp.HP_QueryCollector_GetNumHits(startCollector)[1];\r\n        if (numProximityHits > 0) {\r\n            const newContacts = [];\r\n            let minDistance = 1e38;\r\n            const bodyMap = (<any>hk)._bodies;\r\n            for (let i = 0; i < numProximityHits; i++) {\r\n                const [distance, , contactWorld] = hknp.HP_QueryCollector_GetShapeProximityResult(startCollector, i)[1];\r\n                minDistance = Math.min(minDistance, distance);\r\n                newContacts.push({\r\n                    position: Vector3.FromArray(contactWorld[3]),\r\n                    normal: Vector3.FromArray(contactWorld[4]),\r\n                    distance: distance,\r\n                    fraction: 0,\r\n                    bodyB: bodyMap.get(contactWorld[0][0])!,\r\n                    allowedPenetration: Math.min(Math.max(this.keepDistance - distance, 0.0), this.keepDistance),\r\n                });\r\n            }\r\n\r\n            for (let i = this._manifold.length - 1; i >= 0; i--) {\r\n                const currentContact = this._manifold[i];\r\n                const bestMatch = this._findContact(currentContact, newContacts, 1.1);\r\n                if (bestMatch >= 0) {\r\n                    const newAllowedPenetration = Math.min(Math.max(this.keepDistance - newContacts[bestMatch].distance, 0.0), currentContact.allowedPenetration);\r\n                    this._manifold[i] = newContacts[bestMatch];\r\n                    this._manifold[i].allowedPenetration = newAllowedPenetration;\r\n                    newContacts.splice(bestMatch, 1);\r\n                } else {\r\n                    this._manifold.splice(i, 1);\r\n                }\r\n            }\r\n\r\n            const closestContactIndex = newContacts.findIndex((c) => c.distance == minDistance);\r\n            if (closestContactIndex >= 0) {\r\n                const bestMatch = this._findContact(newContacts[closestContactIndex], this._manifold, 0.1);\r\n                if (bestMatch >= 0) {\r\n                    const newAllowedPenetration = Math.min(\r\n                        Math.max(this.keepDistance - newContacts[closestContactIndex].distance, 0.0),\r\n                        this._manifold[bestMatch].allowedPenetration\r\n                    );\r\n                    this._manifold[bestMatch] = newContacts[closestContactIndex];\r\n                    this._manifold[bestMatch].allowedPenetration = newAllowedPenetration;\r\n                } else {\r\n                    this._manifold.push(newContacts[closestContactIndex]);\r\n                }\r\n            }\r\n        } else {\r\n            // No start hits; clear manifold completely\r\n            this._manifold.length = 0;\r\n        }\r\n\r\n        let numHitBodies = 0; //< == CASTCOLLECTOR_HIT_SINGLE_BODY\r\n        // Process shape cast results if any\r\n        const numCastHits = hknp.HP_QueryCollector_GetNumHits(castCollector)[1];\r\n        if (numCastHits > 0) {\r\n            let closestHitBody = null;\r\n            for (let i = 0; i < numCastHits; i++) {\r\n                const [fraction, , hitWorld] = hknp.HP_QueryCollector_GetShapeCastResult(castCollector, i)[1];\r\n                if (closestHitBody == null) {\r\n                    const contact = contactFromCast(hk, hitWorld, castPath, fraction, this.keepDistance);\r\n                    closestHitBody = hitWorld[0][0];\r\n                    const bestMatch = this._findContact(contact, this._manifold, 0.1);\r\n                    if (bestMatch == -1) {\r\n                        this._manifold.push(contact);\r\n                    }\r\n\r\n                    if (contact.bodyB.body.getMotionType(contact.bodyB.index) == PhysicsMotionType.STATIC) {\r\n                        // The closest body is static, so it cannot move away from CC and we don't need to look any further.\r\n                        break;\r\n                    }\r\n                } else if (closestHitBody._pluginData && hitWorld[0] != closestHitBody._pluginData.hpBodyId) {\r\n                    numHitBodies++;\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n\r\n        // Remove from the manifold contacts that are too similar as the simplex does not handle parallel planes\r\n        for (let e1 = this._manifold.length - 1; e1 >= 0; e1--) {\r\n            let e2 = e1 - 1;\r\n            for (; e2 >= 0; e2--) {\r\n                const fitness = this._compareContacts(this._manifold[e1], this._manifold[e2]);\r\n                if (fitness < 0.1) break;\r\n            }\r\n            if (e2 >= 0) {\r\n                this._manifold.slice(e1, 1);\r\n            }\r\n        }\r\n\r\n        return numHitBodies;\r\n    }\r\n\r\n    protected _createSurfaceConstraint(contact: Contact, timeTravelled: number): SurfaceConstraintInfo {\r\n        const constraint = {\r\n            //let distance = contact.distance - this.keepDistance;\r\n            planeNormal: contact.normal.clone(),\r\n            planeDistance: contact.distance,\r\n            staticFriction: this.staticFriction,\r\n            dynamicFriction: this.dynamicFriction,\r\n            extraUpStaticFriction: 0,\r\n            extraDownStaticFriction: 0,\r\n            velocity: Vector3.Zero(),\r\n            angularVelocity: Vector3.Zero(),\r\n            priority: 0,\r\n        };\r\n\r\n        const maxSlopeCosEps = 0.1;\r\n        const maxSlopeCosine = Math.max(this.maxSlopeCosine, maxSlopeCosEps);\r\n        const normalDotUp = contact.normal.dot(this.up);\r\n\r\n        const contactPosition = contact.position.clone();\r\n        if (normalDotUp > maxSlopeCosine) {\r\n            const com = this.getPosition();\r\n            const contactArm = this._tmpVecs[20];\r\n            contact.position.subtractToRef(com, contactArm);\r\n            const scale = contact.normal.dot(contactArm);\r\n            contactPosition.x = com.x + this.up.x * scale;\r\n            contactPosition.y = com.y + this.up.y * scale;\r\n            contactPosition.z = com.z + this.up.z * scale;\r\n        }\r\n\r\n        const motionType = contact.bodyB.body.getMotionType(contact.bodyB.index);\r\n        if (motionType != PhysicsMotionType.STATIC) {\r\n            //<todo Need hknpMotionUtil::predictPontVelocity\r\n        }\r\n\r\n        const shift = constraint.velocity.dot(constraint.planeNormal) * timeTravelled;\r\n        constraint.planeDistance -= shift;\r\n\r\n        if (motionType == PhysicsMotionType.STATIC) {\r\n            constraint.priority = 2;\r\n        } else if (motionType == PhysicsMotionType.ANIMATED) {\r\n            constraint.priority = 1;\r\n        }\r\n\r\n        return constraint;\r\n    }\r\n\r\n    protected _addMaxSlopePlane(maxSlopeCos: number, up: Vector3, index: number, constraints: SurfaceConstraintInfo[], allowedPenetration: number): boolean {\r\n        const verticalComponent = constraints[index].planeNormal.dot(up);\r\n        if (verticalComponent > 0.01 && verticalComponent < maxSlopeCos) {\r\n            const newConstraint = {\r\n                planeNormal: constraints[index].planeNormal.clone(),\r\n                planeDistance: constraints[index].planeDistance,\r\n                velocity: constraints[index].velocity.clone(),\r\n                angularVelocity: constraints[index].angularVelocity.clone(),\r\n                priority: constraints[index].priority,\r\n                dynamicFriction: constraints[index].dynamicFriction,\r\n                staticFriction: constraints[index].staticFriction,\r\n                extraDownStaticFriction: constraints[index].extraDownStaticFriction,\r\n                extraUpStaticFriction: constraints[index].extraUpStaticFriction,\r\n            };\r\n            const distance = newConstraint.planeDistance;\r\n            newConstraint.planeNormal.subtractInPlace(up.scale(verticalComponent));\r\n            newConstraint.planeNormal.normalize();\r\n            if (distance >= 0) {\r\n                newConstraint.planeDistance = distance * newConstraint.planeNormal.dot(constraints[index].planeNormal);\r\n            } else {\r\n                const penetrationToResolve = Math.min(0, distance + allowedPenetration);\r\n                newConstraint.planeDistance = penetrationToResolve / newConstraint.planeNormal.dot(constraints[index].planeNormal);\r\n                constraints[index].planeDistance = 0;\r\n                this._resolveConstraintPenetration(newConstraint, this.penetrationRecoverySpeed);\r\n            }\r\n            constraints.push(newConstraint);\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    protected _resolveConstraintPenetration(constraint: SurfaceConstraintInfo, penetrationRecoverySpeed: number) {\r\n        // If penetrating we add extra velocity to push the character back out\r\n        const eps = 1e-6;\r\n        if (constraint.planeDistance < -eps) {\r\n            constraint.planeNormal.scaleToRef(constraint.planeDistance * penetrationRecoverySpeed, this._tmpVecs[6]);\r\n            constraint.velocity.subtractInPlace(this._tmpVecs[6]);\r\n        }\r\n    }\r\n\r\n    protected _createConstraintsFromManifold(dt: number, timeTravelled: number): SurfaceConstraintInfo[] {\r\n        const constraints = [];\r\n        for (let i = 0; i < this._manifold.length; i++) {\r\n            const surfaceConstraint = this._createSurfaceConstraint(this._manifold[i], timeTravelled);\r\n            constraints.push(surfaceConstraint);\r\n            this._addMaxSlopePlane(this.maxSlopeCosine, this.up, i, constraints, this._manifold[i].allowedPenetration);\r\n            this._resolveConstraintPenetration(surfaceConstraint, this.penetrationRecoverySpeed);\r\n        }\r\n        return constraints;\r\n    }\r\n\r\n    protected _simplexSolverSortInfo(info: SimplexSolverInfo) {\r\n        // simple bubble sort by (priority,velocity)\r\n        for (let i = 0; i < info.numSupportPlanes - 1; i++) {\r\n            for (let j = i + 1; j < info.numSupportPlanes; j++) {\r\n                const p0 = info.supportPlanes[i];\r\n                const p1 = info.supportPlanes[j];\r\n                if (p0.constraint.priority < p1.constraint.priority) {\r\n                    continue;\r\n                }\r\n                if (p0.constraint.priority == p1.constraint.priority) {\r\n                    const vel0 = p0.constraint.velocity.lengthSquared();\r\n                    const vel1 = p1.constraint.velocity.lengthSquared();\r\n                    if (vel0 < vel1) {\r\n                        continue;\r\n                    }\r\n                }\r\n                info.supportPlanes[i] = p1;\r\n                info.supportPlanes[j] = p0;\r\n            }\r\n        }\r\n    }\r\n\r\n    protected _simplexSolverSolve1d(info: SimplexSolverInfo, sci: SurfaceConstraintInfo, velocityIn: Vector3, velocityOut: Vector3) {\r\n        const eps = 1e-5;\r\n        const groundVelocity = sci.velocity;\r\n        const relativeVelocity = this._tmpVecs[22];\r\n        velocityIn.subtractToRef(groundVelocity, relativeVelocity);\r\n\r\n        const planeVel = relativeVelocity.dot(sci.planeNormal);\r\n\r\n        const origVelocity2 = relativeVelocity.lengthSquared();\r\n        relativeVelocity.subtractInPlace(sci.planeNormal.scale(planeVel));\r\n        {\r\n            const vp2 = planeVel * planeVel;\r\n            // static friction is active if\r\n            //  velProjPlane * friction > |(velParallel)|\r\n            //      vplane   *     f    >         vpar\r\n            //      vp       *     f    >         vpar\r\n            //      vp2      *     f2   >         vpar2\r\n            const extraStaticFriction = relativeVelocity.dot(this.up) > 0 ? sci.extraUpStaticFriction : sci.extraDownStaticFriction;\r\n            if (extraStaticFriction > 0) {\r\n                const horizontal = this.up.cross(sci.planeNormal);\r\n                const hor2 = horizontal.lengthSquared();\r\n                let horVel = 0.0;\r\n                if (hor2 > eps) {\r\n                    horizontal.scaleInPlace(1 / Math.sqrt(hor2));\r\n\r\n                    horVel = relativeVelocity.dot(horizontal);\r\n\r\n                    // horizontal component\r\n                    {\r\n                        const horVel2 = horVel * horVel;\r\n                        const f2 = sci.staticFriction * sci.staticFriction;\r\n                        if (vp2 * f2 >= horVel2) {\r\n                            relativeVelocity.subtractInPlace(horizontal.scale(horVel));\r\n                            horVel = 0;\r\n                        }\r\n                    }\r\n                }\r\n\r\n                // vert component\r\n                {\r\n                    const vertVel2 = origVelocity2 - horVel * horVel - vp2;\r\n                    const f2 = (sci.staticFriction + extraStaticFriction) * (sci.staticFriction + extraStaticFriction);\r\n                    if (vp2 * f2 >= vertVel2) {\r\n                        if (horVel == 0.0) {\r\n                            velocityOut.copyFrom(groundVelocity);\r\n                            return;\r\n                        }\r\n                    }\r\n                }\r\n            } else {\r\n                // static friction is active if\r\n                //  velProjPlane * friction > |(vel-velProjPlane)|\r\n                //      vp       *     f    >         rvProj\r\n                //\r\n                //  -> vp * f >= rvProj\r\n                //  -> vp * f >= sqrt( vel^2 - vp^2 )\r\n                //  -> vp^2 ( f^2 + 1 ) >= vel^2\r\n                const f2 = sci.staticFriction * sci.staticFriction;\r\n                if (vp2 * (1 + f2) >= origVelocity2) {\r\n                    velocityOut.copyFrom(groundVelocity);\r\n                    return;\r\n                }\r\n            }\r\n        }\r\n\r\n        if (sci.dynamicFriction < 1) {\r\n            //  apply dynamic friction 0 = conserve input velocity 1 = clip against normal\r\n            const velOut2 = relativeVelocity.lengthSquared();\r\n            if (velOut2 >= eps) {\r\n                if (velOut2 > 1e-4 * origVelocity2) {\r\n                    let f = Math.sqrt(origVelocity2 / velOut2);\r\n                    f = sci.dynamicFriction + (1 - sci.dynamicFriction) * f;\r\n                    relativeVelocity.scaleInPlace(f);\r\n                    const p = sci.planeNormal.dot(relativeVelocity);\r\n                    relativeVelocity.subtractInPlace(sci.planeNormal.scale(p));\r\n                }\r\n            }\r\n        }\r\n        velocityOut.copyFrom(relativeVelocity);\r\n        velocityOut.addInPlace(groundVelocity);\r\n    }\r\n\r\n    protected _simplexSolverSolveTest1d(sci: SurfaceConstraintInfo, velocityIn: Vector3): boolean {\r\n        const eps = 1e-3;\r\n        const relativeVelocity = this._tmpVecs[23];\r\n        velocityIn.subtractToRef(sci.velocity, relativeVelocity);\r\n        return relativeVelocity.dot(sci.planeNormal) < -eps;\r\n    }\r\n\r\n    protected _simplexSolverSolve2d(\r\n        info: SimplexSolverInfo,\r\n        maxSurfaceVelocity: Vector3,\r\n        sci0: SurfaceConstraintInfo,\r\n        sci1: SurfaceConstraintInfo,\r\n        velocityIn: Vector3,\r\n        velocityOut: Vector3\r\n    ) {\r\n        const eps = 1e-5;\r\n        const axis = sci0.planeNormal.cross(sci1.planeNormal);\r\n        const axisLen2 = axis.lengthSquared();\r\n\r\n        let solveSequentially = false;\r\n        let axisVel = null;\r\n\r\n        // eslint-disable-next-line no-constant-condition\r\n        while (true) {\r\n            // Check for parallel planes\r\n            if (axisLen2 <= eps || solveSequentially) {\r\n                info.getOutput(sci0).status = SurfaceConstraintInteractionStatus.FAILURE_2D;\r\n                info.getOutput(sci1).status = SurfaceConstraintInteractionStatus.FAILURE_2D;\r\n\r\n                if (sci0.priority > sci1.priority) {\r\n                    this._simplexSolverSolve1d(info, sci1, velocityIn, velocityOut);\r\n                    this._simplexSolverSolve1d(info, sci0, velocityIn, velocityOut);\r\n                } else {\r\n                    this._simplexSolverSolve1d(info, sci0, velocityIn, velocityOut);\r\n                    this._simplexSolverSolve1d(info, sci1, velocityIn, velocityOut);\r\n                }\r\n                return;\r\n            }\r\n\r\n            const invAxisLen = 1.0 / Math.sqrt(axisLen2);\r\n            axis.scaleInPlace(invAxisLen);\r\n\r\n            //  Calculate the velocity of the free axis\r\n            {\r\n                const r0 = sci0.planeNormal.cross(sci1.planeNormal);\r\n                const r1 = sci1.planeNormal.cross(axis);\r\n                const r2 = axis.cross(sci0.planeNormal);\r\n\r\n                const sVel = sci0.velocity.add(sci1.velocity);\r\n\r\n                const t = this._tmpVecs[2];\r\n                t.set(0.5 * axis.dot(sVel), sci0.planeNormal.dot(sci0.velocity), sci1.planeNormal.dot(sci1.velocity));\r\n                const m = Matrix.FromValues(r0.x, r1.x, r2.x, 0, r0.y, r1.y, r2.y, 0, r0.z, r1.z, r2.z, 0, 0, 0, 0, 1);\r\n                axisVel = Vector3.TransformNormal(t, m);\r\n                axisVel.scaleInPlace(invAxisLen);\r\n\r\n                if (Math.abs(axisVel.x) > maxSurfaceVelocity.x || Math.abs(axisVel.y) > maxSurfaceVelocity.y || Math.abs(axisVel.z) > maxSurfaceVelocity.z) {\r\n                    solveSequentially = true;\r\n                } else {\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n\r\n        const groundVelocity = axisVel;\r\n        const relativeVelocity = this._tmpVecs[24];\r\n        velocityIn.subtractToRef(groundVelocity, relativeVelocity);\r\n\r\n        const vel2 = relativeVelocity.lengthSquared();\r\n        const axisVert = this.up.dot(axis);\r\n        let axisProjVelocity = relativeVelocity.dot(axis);\r\n\r\n        let staticFriction = sci0.staticFriction + sci1.staticFriction;\r\n        if (axisVert * axisProjVelocity > 0) {\r\n            staticFriction += (sci0.extraUpStaticFriction + sci1.extraUpStaticFriction) * axisVert;\r\n        } else {\r\n            staticFriction += (sci0.extraDownStaticFriction + sci1.extraDownStaticFriction) * axisVert;\r\n        }\r\n        staticFriction *= 0.5;\r\n\r\n        const dynamicFriction = (sci0.dynamicFriction + sci1.dynamicFriction) * 0.5;\r\n        // static friction is active if\r\n        //  |vel-axisProjVelocity|(rv) * friction(f) > axisProjVelocity(av)\r\n        //  -> sqrt( vel2 - av2 ) * f > av\r\n        //  -> (vel2 - av2) * f2  > av2\r\n        const f2 = staticFriction * staticFriction;\r\n        const av2 = axisProjVelocity * axisProjVelocity;\r\n        if ((vel2 - av2) * f2 >= av2) {\r\n            // static friction kicks in\r\n            velocityOut.copyFrom(groundVelocity);\r\n            return;\r\n        }\r\n\r\n        if (dynamicFriction < 1) {\r\n            //  apply dynamic friction\r\n            if (axisProjVelocity * axisProjVelocity > 1e-4 * vel2) {\r\n                const tmp = 1.0 / axisProjVelocity;\r\n                const f = Math.abs(tmp) * Math.sqrt(vel2) * (1.0 - dynamicFriction) + dynamicFriction;\r\n                axisProjVelocity *= f;\r\n            }\r\n        }\r\n        velocityOut.copyFrom(groundVelocity);\r\n        velocityOut.addInPlace(axis.scale(axisProjVelocity));\r\n    }\r\n\r\n    protected _simplexSolverSolve3d(\r\n        info: SimplexSolverInfo,\r\n        maxSurfaceVelocity: Vector3,\r\n        sci0: SurfaceConstraintInfo,\r\n        sci1: SurfaceConstraintInfo,\r\n        sci2: SurfaceConstraintInfo,\r\n        allowResort: boolean,\r\n        velocityIn: Vector3,\r\n        velocityOut: Vector3\r\n    ) {\r\n        const eps = 1e-5;\r\n        //  Calculate the velocity of the point axis\r\n        let pointVel = null;\r\n        {\r\n            const r0 = sci1.planeNormal.cross(sci2.planeNormal);\r\n            const r1 = sci2.planeNormal.cross(sci0.planeNormal);\r\n            const r2 = sci0.planeNormal.cross(sci1.planeNormal);\r\n\r\n            const det = r0.dot(sci0.planeNormal);\r\n            let solveSequentially = false;\r\n            // eslint-disable-next-line no-constant-condition\r\n            while (true) {\r\n                if (Math.abs(det) < eps || solveSequentially) {\r\n                    if (allowResort) {\r\n                        this._simplexSolverSortInfo(info);\r\n                        sci0 = info.supportPlanes[0].constraint;\r\n                        sci1 = info.supportPlanes[1].constraint;\r\n                        sci2 = info.supportPlanes[2].constraint;\r\n                    }\r\n                    info.getOutput(sci0).status = SurfaceConstraintInteractionStatus.FAILURE_3D;\r\n                    info.getOutput(sci1).status = SurfaceConstraintInteractionStatus.FAILURE_3D;\r\n                    info.getOutput(sci2).status = SurfaceConstraintInteractionStatus.FAILURE_3D;\r\n\r\n                    const oldNum = info.numSupportPlanes;\r\n                    this._simplexSolverSolve2d(info, maxSurfaceVelocity, sci0, sci1, velocityIn, velocityOut);\r\n                    if (oldNum == info.numSupportPlanes) {\r\n                        this._simplexSolverSolve2d(info, maxSurfaceVelocity, sci0, sci2, velocityIn, velocityOut);\r\n                    }\r\n                    if (oldNum == info.numSupportPlanes) {\r\n                        this._simplexSolverSolve2d(info, maxSurfaceVelocity, sci1, sci2, velocityIn, velocityOut);\r\n                    }\r\n\r\n                    return;\r\n                }\r\n\r\n                const t = this._tmpVecs[2];\r\n                t.set(sci0.planeNormal.dot(sci0.velocity), sci1.planeNormal.dot(sci1.velocity), sci2.planeNormal.dot(sci2.velocity));\r\n                const m = Matrix.FromValues(r0.x, r0.y, r0.z, 0, r1.x, r1.y, r1.z, 0, r2.x, r2.y, r2.z, 0, 0, 0, 0, 1);\r\n                pointVel = Vector3.TransformNormal(t, m);\r\n                pointVel.scaleInPlace(1 / det);\r\n                if (Math.abs(pointVel.x) > maxSurfaceVelocity.x || Math.abs(pointVel.y) > maxSurfaceVelocity.y || Math.abs(pointVel.z) > maxSurfaceVelocity.z) {\r\n                    solveSequentially = true;\r\n                } else {\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n        velocityOut.copyFrom(pointVel);\r\n    }\r\n\r\n    protected _simplexSolverExamineActivePlanes(info: SimplexSolverInfo, maxSurfaceVelocity: Vector3, velocityIn: Vector3, velocityOut: Vector3) {\r\n        // eslint-disable-next-line no-constant-condition\r\n        while (true) {\r\n            switch (info.numSupportPlanes) {\r\n                case 1: {\r\n                    const sci = info.supportPlanes[0].constraint;\r\n                    this._simplexSolverSolve1d(info, sci, velocityIn, velocityOut);\r\n                    return;\r\n                }\r\n                case 2: {\r\n                    const velocity = Vector3.Zero();\r\n                    this._simplexSolverSolve1d(info, info.supportPlanes[1].constraint, velocityIn, velocity);\r\n                    const plane0Used = this._simplexSolverSolveTest1d(info.supportPlanes[0].constraint, velocity);\r\n                    if (!plane0Used) {\r\n                        // Only need plane 1, so remove plane 0\r\n                        info.supportPlanes[0].copyFrom(info.supportPlanes[1]);\r\n                        info.numSupportPlanes = 1;\r\n                        velocityOut.copyFrom(velocity);\r\n                    } else {\r\n                        this._simplexSolverSolve2d(info, maxSurfaceVelocity, info.supportPlanes[0].constraint, info.supportPlanes[1].constraint, velocityIn, velocityOut);\r\n                    }\r\n                    return;\r\n                }\r\n                case 3: {\r\n                    // Try to drop both planes\r\n                    {\r\n                        const velocity = Vector3.Zero();\r\n                        this._simplexSolverSolve1d(info, info.supportPlanes[2].constraint, velocityIn, velocityOut);\r\n\r\n                        const plane0Used = this._simplexSolverSolveTest1d(info.supportPlanes[0].constraint, velocity);\r\n                        if (!plane0Used) {\r\n                            const plane1Used = this._simplexSolverSolveTest1d(info.supportPlanes[1].constraint, velocity);\r\n                            if (!plane1Used) {\r\n                                velocityOut.copyFrom(velocity);\r\n                                info.supportPlanes[0].copyFrom(info.supportPlanes[2]);\r\n                                info.numSupportPlanes = 1;\r\n                                continue;\r\n                            }\r\n                        }\r\n                    }\r\n\r\n                    //  Try to drop plane 0 or 1\r\n                    {\r\n                        let droppedAPlane = false;\r\n                        for (let testPlane = 0; testPlane < 2; testPlane++) {\r\n                            const velocity = Vector3.Zero();\r\n                            this._simplexSolverSolve2d(\r\n                                info,\r\n                                maxSurfaceVelocity,\r\n                                info.supportPlanes[testPlane].constraint,\r\n                                info.supportPlanes[2].constraint,\r\n                                velocityIn,\r\n                                velocityOut\r\n                            );\r\n                            const planeUsed = this._simplexSolverSolveTest1d(info.supportPlanes[1 - testPlane].constraint, velocity);\r\n                            if (!planeUsed) {\r\n                                info.supportPlanes[0].copyFrom(info.supportPlanes[testPlane]);\r\n                                info.supportPlanes[1].copyFrom(info.supportPlanes[2]);\r\n                                info.numSupportPlanes--;\r\n                                droppedAPlane = true;\r\n                                break;\r\n                            }\r\n                        }\r\n\r\n                        if (droppedAPlane) {\r\n                            continue;\r\n                        }\r\n                    }\r\n\r\n                    // Otherwise, try and solve all three planes:\r\n                    this._simplexSolverSolve3d(\r\n                        info,\r\n                        maxSurfaceVelocity,\r\n                        info.supportPlanes[0].constraint,\r\n                        info.supportPlanes[1].constraint,\r\n                        info.supportPlanes[2].constraint,\r\n                        true,\r\n                        velocityIn,\r\n                        velocityOut\r\n                    );\r\n                    return;\r\n                }\r\n                case 4: {\r\n                    this._simplexSolverSortInfo(info);\r\n                    let droppedAPlane = false;\r\n\r\n                    for (let i = 0; i < 3; i++) {\r\n                        const velocity = Vector3.Zero();\r\n                        this._simplexSolverSolve3d(\r\n                            info,\r\n                            maxSurfaceVelocity,\r\n                            info.supportPlanes[(i + 1) % 3].constraint,\r\n                            info.supportPlanes[(i + 2) % 3].constraint,\r\n                            info.supportPlanes[3].constraint,\r\n                            false,\r\n                            velocityIn,\r\n                            velocity\r\n                        );\r\n                        const planeUsed = this._simplexSolverSolveTest1d(info.supportPlanes[i].constraint, velocity);\r\n                        if (!planeUsed) {\r\n                            info.supportPlanes[i].copyFrom(info.supportPlanes[2]);\r\n                            info.supportPlanes[2].copyFrom(info.supportPlanes[3]);\r\n                            info.numSupportPlanes = 3;\r\n                            droppedAPlane = true;\r\n                            break;\r\n                        }\r\n                    }\r\n\r\n                    if (droppedAPlane) {\r\n                        continue;\r\n                    }\r\n\r\n                    // Nothing can be dropped so we've failed to solve\r\n                    // Now we try all 3d combinations\r\n                    {\r\n                        const velocity = velocityIn.clone();\r\n                        const sci0 = info.supportPlanes[0].constraint;\r\n                        const sci1 = info.supportPlanes[1].constraint;\r\n                        const sci2 = info.supportPlanes[2].constraint;\r\n                        const sci3 = info.supportPlanes[3].constraint;\r\n                        const oldNum = info.numSupportPlanes;\r\n                        if (oldNum == info.numSupportPlanes) {\r\n                            this._simplexSolverSolve3d(info, maxSurfaceVelocity, sci0, sci1, sci2, false, velocity, velocity);\r\n                            // eslint-disable-next-line no-dupe-else-if\r\n                        } else if (oldNum == info.numSupportPlanes) {\r\n                            this._simplexSolverSolve3d(info, maxSurfaceVelocity, sci0, sci1, sci3, false, velocity, velocity);\r\n                            // eslint-disable-next-line no-dupe-else-if\r\n                        } else if (oldNum == info.numSupportPlanes) {\r\n                            this._simplexSolverSolve3d(info, maxSurfaceVelocity, sci0, sci2, sci3, false, velocity, velocity);\r\n                            // eslint-disable-next-line no-dupe-else-if\r\n                        } else if (oldNum == info.numSupportPlanes) {\r\n                            this._simplexSolverSolve3d(info, maxSurfaceVelocity, sci1, sci2, sci3, false, velocity, velocity);\r\n                        }\r\n\r\n                        velocityOut.copyFrom(velocity);\r\n                    }\r\n\r\n                    //  Search a plane to drop\r\n                    {\r\n                        //  Search the highest penalty value\r\n                        let maxStatus = SurfaceConstraintInteractionStatus.OK;\r\n                        for (let i = 0; i < 4; i++) {\r\n                            maxStatus = Math.max(maxStatus, info.supportPlanes[i].interaction.status);\r\n                        }\r\n\r\n                        // Remove the place with the lowest priority and the highest penalty\r\n                        let i = 0;\r\n                        for (; i < 4; i++) {\r\n                            if (maxStatus == info.supportPlanes[i].interaction.status) {\r\n                                info.supportPlanes[i].copyFrom(info.supportPlanes[3]);\r\n                                break;\r\n                            }\r\n                            info.numSupportPlanes--;\r\n                        }\r\n                    }\r\n\r\n                    //  Clear penalty flags for the other planes\r\n                    for (let i = 0; i < 3; i++) {\r\n                        info.supportPlanes[i].interaction.status = SurfaceConstraintInteractionStatus.OK;\r\n                    }\r\n\r\n                    continue;\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    public _simplexSolverSolve(\r\n        constraints: SurfaceConstraintInfo[],\r\n        velocity: Vector3,\r\n        deltaTime: number,\r\n        minDeltaTime: number,\r\n        up: Vector3,\r\n        maxSurfaceVelocity: Vector3\r\n    ): SimplexSolverOutput {\r\n        const eps = 1e-6;\r\n        const output = new SimplexSolverOutput();\r\n        output.position = Vector3.Zero();\r\n        output.velocity = velocity.clone();\r\n        output.planeInteractions = [];\r\n        let remainingTime = deltaTime;\r\n\r\n        for (let i = 0; i < constraints.length; i++) {\r\n            output.planeInteractions.push({\r\n                touched: false,\r\n                stopped: false,\r\n                surfaceTime: 0,\r\n                penaltyDistance: 0,\r\n                status: SurfaceConstraintInteractionStatus.OK,\r\n            });\r\n        }\r\n\r\n        const info = new SimplexSolverInfo();\r\n        info.inputConstraints = constraints;\r\n        info.outputInteractions = output.planeInteractions;\r\n        info.supportPlanes[0] = new SimplexSolverActivePlanes();\r\n        info.supportPlanes[1] = new SimplexSolverActivePlanes();\r\n        info.supportPlanes[2] = new SimplexSolverActivePlanes();\r\n        info.supportPlanes[3] = new SimplexSolverActivePlanes();\r\n\r\n        while (remainingTime > 0) {\r\n            // search for a plane which collides our current direction\r\n            let hitIndex = -1;\r\n            let minCollisionTime = remainingTime;\r\n            for (let i = 0; i < constraints.length; i++) {\r\n                //  Do not search existing active planes\r\n                if (info.numSupportPlanes >= 1 && info.supportPlanes[0].index == i) continue;\r\n                if (info.numSupportPlanes >= 2 && info.supportPlanes[1].index == i) continue;\r\n                if (info.numSupportPlanes >= 3 && info.supportPlanes[2].index == i) continue;\r\n                if (output.planeInteractions[i].status != SurfaceConstraintInteractionStatus.OK) {\r\n                    continue;\r\n                }\r\n\r\n                // Try to find the plane with the shortest time to move\r\n                const sci = constraints[i];\r\n                const relativeVel = this._tmpVecs[25];\r\n                output.velocity.subtractToRef(sci.velocity, relativeVel);\r\n                const relativeProjectedVel = -relativeVel.dot(sci.planeNormal);\r\n                // if projected velocity is pointing away skip it\r\n                if (relativeProjectedVel <= 0) {\r\n                    continue;\r\n                }\r\n\r\n                //  Calculate the time of impact\r\n                const relativePos = this._tmpVecs[26];\r\n                sci.velocity.scaleToRef(info.currentTime, this._tmpVecs[27]);\r\n                output.position.subtractToRef(this._tmpVecs[27], relativePos);\r\n                let projectedPos = sci.planeNormal.dot(relativePos);\r\n\r\n                // treat penetrations\r\n                const penaltyDist = output.planeInteractions[i].penaltyDistance;\r\n                if (penaltyDist < eps) {\r\n                    projectedPos = 0;\r\n                }\r\n                projectedPos += penaltyDist;\r\n\r\n                // check for new hit\r\n                if (projectedPos < minCollisionTime * relativeProjectedVel) {\r\n                    minCollisionTime = projectedPos / relativeProjectedVel;\r\n                    hitIndex = i;\r\n                }\r\n            }\r\n\r\n            //  integrate: Walk to our hitPosition we must walk more than 10 microseconds into the future to consider it valid.\r\n            const minAcceptableCollisionTime = 1e-4;\r\n            if (minCollisionTime > minAcceptableCollisionTime) {\r\n                info.currentTime += minCollisionTime;\r\n                remainingTime -= minCollisionTime;\r\n                output.position.addInPlace(output.velocity.scale(minCollisionTime));\r\n                for (let i = 0; i < info.numSupportPlanes; i++) {\r\n                    info.supportPlanes[i].interaction.surfaceTime += minCollisionTime;\r\n                    info.supportPlanes[i].interaction.touched = true;\r\n                }\r\n\r\n                output.deltaTime = info.currentTime;\r\n                if (info.currentTime > minDeltaTime) {\r\n                    return output;\r\n                }\r\n            }\r\n\r\n            //  If we have no hit than we are done\r\n            if (hitIndex < 0) {\r\n                output.deltaTime = deltaTime;\r\n                break;\r\n            }\r\n\r\n            //  Add our hit to our current list of active planes\r\n            const supportPlane = info.supportPlanes[info.numSupportPlanes++];\r\n            supportPlane.constraint = constraints[hitIndex];\r\n            supportPlane.interaction = output.planeInteractions[hitIndex];\r\n            supportPlane.interaction.penaltyDistance = (supportPlane.interaction.penaltyDistance + eps) * 2.0;\r\n            supportPlane.index = hitIndex;\r\n\r\n            // Move our character along the current set of active planes\r\n            this._simplexSolverExamineActivePlanes(info, maxSurfaceVelocity, velocity, output.velocity);\r\n        }\r\n\r\n        return output;\r\n    }\r\n\r\n    /**\r\n     * Compute a CharacterSurfaceInfo from current state and a direction\r\n     * @param deltaTime frame delta time in seconds. When using scene.deltaTime divide by 1000.0\r\n     * @param direction direction to check, usually gravity direction\r\n     * @returns a CharacterSurfaceInfo object\r\n     */\r\n    public checkSupport(deltaTime: number, direction: Vector3): CharacterSurfaceInfo {\r\n        const surfaceInfo = {\r\n            isSurfaceDynamic: false,\r\n            supportedState: CharacterSupportedState.UNSUPPORTED,\r\n            averageSurfaceNormal: Vector3.Zero(),\r\n            averageSurfaceVelocity: Vector3.Zero(),\r\n            averageAngularSurfaceVelocity: Vector3.Zero(),\r\n        };\r\n        this.checkSupportToRef(deltaTime, direction, surfaceInfo);\r\n        return surfaceInfo;\r\n    }\r\n\r\n    /**\r\n     * Compute a CharacterSurfaceInfo from current state and a direction\r\n     * @param deltaTime frame delta time in seconds. When using scene.deltaTime divide by 1000.0\r\n     * @param direction direction to check, usually gravity direction\r\n     * @param surfaceInfo output for surface info\r\n     */\r\n    public checkSupportToRef(deltaTime: number, direction: Vector3, surfaceInfo: CharacterSurfaceInfo): void {\r\n        const eps = 1e-4;\r\n\r\n        this._validateManifold();\r\n        const constraints = this._createConstraintsFromManifold(deltaTime, 0.0);\r\n        const storedVelocities: Vector3[] = [];\r\n        // Remove velocities and friction to make this a query of the static geometry\r\n        for (let i = 0; i < constraints.length; i++) {\r\n            storedVelocities.push(constraints[i].velocity.clone());\r\n            constraints[i].velocity.setAll(0);\r\n        }\r\n\r\n        const maxSurfaceVelocity = this._tmpVecs[3];\r\n        maxSurfaceVelocity.set(this.maxCharacterSpeedForSolver, this.maxCharacterSpeedForSolver, this.maxCharacterSpeedForSolver);\r\n        const output = this._simplexSolverSolve(constraints, direction, deltaTime, deltaTime, this.up, maxSurfaceVelocity);\r\n\r\n        surfaceInfo.averageSurfaceVelocity.setAll(0);\r\n        surfaceInfo.averageAngularSurfaceVelocity.setAll(0);\r\n        surfaceInfo.averageSurfaceNormal.setAll(0);\r\n\r\n        // If the constraints did not affect the character movement then it is unsupported and we can finish\r\n        if (output.velocity.equalsWithEpsilon(direction, eps)) {\r\n            surfaceInfo.supportedState = CharacterSupportedState.UNSUPPORTED;\r\n            return;\r\n        }\r\n\r\n        // Check how was the input velocity modified to determine if the character is supported or sliding\r\n        if (output.velocity.lengthSquared() < eps) {\r\n            surfaceInfo.supportedState = CharacterSupportedState.SUPPORTED;\r\n        } else {\r\n            output.velocity.normalize();\r\n            const angleSin = output.velocity.dot(direction);\r\n            const cosSqr = 1 - angleSin * angleSin;\r\n            if (cosSqr < this.maxSlopeCosine * this.maxSlopeCosine) {\r\n                surfaceInfo.supportedState = CharacterSupportedState.SLIDING;\r\n            } else {\r\n                surfaceInfo.supportedState = CharacterSupportedState.SUPPORTED;\r\n            }\r\n        }\r\n\r\n        // Add all supporting constraints to the ground information\r\n        let numTouching = 0;\r\n        for (let i = -0; i < constraints.length; i++) {\r\n            if (output.planeInteractions[i].touched && constraints[i].planeNormal.dot(direction) < -0.08) {\r\n                surfaceInfo.averageSurfaceNormal.addInPlace(constraints[i].planeNormal);\r\n                surfaceInfo.averageSurfaceVelocity.addInPlace(storedVelocities[i]);\r\n                surfaceInfo.averageAngularSurfaceVelocity.addInPlace(constraints[i].angularVelocity);\r\n                numTouching++;\r\n            }\r\n        }\r\n\r\n        if (numTouching > 0) {\r\n            surfaceInfo.averageSurfaceNormal.normalize();\r\n            surfaceInfo.averageSurfaceVelocity.scaleInPlace(1 / numTouching);\r\n            surfaceInfo.averageAngularSurfaceVelocity.scaleInPlace(1 / numTouching);\r\n        }\r\n    }\r\n\r\n    protected _castWithCollectors(startPos: Vector3, endPos: Vector3, castCollector: any /*HP_CollectorId*/, startCollector?: any /*HP_CollectorId*/) {\r\n        const hk = this._scene.getPhysicsEngine()!.getPhysicsPlugin() as HavokPlugin;\r\n        const hknp = hk._hknp;\r\n\r\n        const startNative = [startPos.x, startPos.y, startPos.z];\r\n        const orientation = [this._orientation.x, this._orientation.y, this._orientation.z, this._orientation.w];\r\n        if (startCollector != null) {\r\n            const query /*: ShapeProximityInput*/ = [\r\n                this._shape._pluginData,\r\n                //@ts-ignore\r\n                startNative,\r\n                //@ts-ignore\r\n                orientation,\r\n                this.keepDistance + this.keepContactTolerance, // max distance\r\n                false, // should hit triggers\r\n                [BigInt(0)], // body to ignore //<todo allow for a proxy body!\r\n            ];\r\n            hknp.HP_World_ShapeProximityWithCollector(hk.world, startCollector, query);\r\n        }\r\n\r\n        {\r\n            const query /*: ShapeCastInput*/ = [\r\n                this._shape._pluginData,\r\n                //@ts-ignore\r\n                orientation,\r\n                //@ts-ignore\r\n                startNative,\r\n                [endPos.x, endPos.y, endPos.z],\r\n                false, // should hit triggers\r\n                [BigInt(0)], // body to ignore //<todo allow for proxy body\r\n            ];\r\n            hknp.HP_World_ShapeCastWithCollector(hk.world, castCollector, query);\r\n        }\r\n    }\r\n\r\n    protected _resolveContacts(deltaTime: number, gravity: Vector3) {\r\n        const eps = 1e-12;\r\n        //<todo object interactions out\r\n        for (let i = 0; i < this._manifold.length; i++) {\r\n            const contact = this._manifold[i];\r\n            const bodyB = this._manifold[i].bodyB;\r\n\r\n            //<todo test if bodyB is another character with a proxy body\r\n\r\n            // Skip fixed or keyframed bodies as we won't apply impulses to them\r\n            if (bodyB.body.getMotionType(bodyB.index) != PhysicsMotionType.DYNAMIC) {\r\n                continue;\r\n            }\r\n\r\n            // Calculate and apply impulse on contacted body\r\n            {\r\n                //<todo input/output for callbacks\r\n                let inputObjectMassInv = 0;\r\n                let inputObjectImpulse = 0;\r\n                let outputObjectImpulse = Vector3.Zero();\r\n                const outputImpulsePosition = contact.position;\r\n\r\n                // Calculate relative normal velocity of the contact point in the contacted body\r\n                const pointRelVel = this._tmpVecs[19];\r\n                this._getPointVelocityToRef(bodyB, contact.position, pointRelVel);\r\n                pointRelVel.subtractInPlace(this._velocity);\r\n                const inputProjectedVelocity = pointRelVel.dot(contact.normal);\r\n                const dampFactor = 0.9;\r\n\r\n                // Change velocity\r\n                let deltaVelocity = -inputProjectedVelocity * dampFactor;\r\n\r\n                // Apply an extra impulse if the collision is actually penetrating\r\n                if (contact.distance < 0) {\r\n                    const recoveryTau = 0.4;\r\n                    deltaVelocity += (contact.distance * recoveryTau) / deltaTime;\r\n                }\r\n\r\n                // Apply impulse if required to keep bodies apart\r\n                if (deltaVelocity < 0) {\r\n                    //  Calculate the impulse magnitude\r\n                    const invInertia = this._getInverseInertiaWorld(bodyB);\r\n                    const comWorld = this._tmpVecs[15];\r\n                    this._getComWorldToRef(bodyB, comWorld);\r\n                    const r = this._tmpVecs[16];\r\n                    contact.position.subtractToRef(comWorld, r);\r\n                    const jacAng = this._tmpVecs[17];\r\n                    Vector3.CrossToRef(r, contact.normal, jacAng);\r\n                    const rc = this._tmpVecs[18];\r\n                    Vector3.TransformNormalToRef(jacAng, invInertia, rc);\r\n                    inputObjectMassInv = rc.dot(jacAng) + this._getInvMass(bodyB);\r\n                    inputObjectImpulse = deltaVelocity / inputObjectMassInv;\r\n\r\n                    // Clamp impulse magnitude if required and apply it to the normal direction\r\n                    const maxPushImpulse = -this.characterStrength * deltaTime;\r\n                    if (inputObjectImpulse < maxPushImpulse) {\r\n                        inputObjectImpulse = maxPushImpulse;\r\n                    }\r\n                    outputObjectImpulse = contact.normal.scale(inputObjectImpulse);\r\n                } else {\r\n                    inputObjectImpulse = 0;\r\n                    inputObjectMassInv = this._getInvMass(bodyB);\r\n                }\r\n\r\n                // Add gravity\r\n                {\r\n                    // Calculate effect of gravity on the velocity of the character in the contact normal direction\r\n                    let relVelN = contact.normal.dot(gravity.scale(deltaTime));\r\n                    // If it is a separating contact subtract the separation velocity\r\n                    if (inputProjectedVelocity < 0) {\r\n                        relVelN -= inputProjectedVelocity;\r\n                    }\r\n                    // If the resulting velocity is negative an impulse is applied to stop the character from falling into\r\n                    // the contacted body\r\n                    if (relVelN < -eps) {\r\n                        outputObjectImpulse.addInPlace(contact.normal.scale(this.characterMass * relVelN));\r\n                    }\r\n                }\r\n\r\n                //<todo Fire callback to allow user to change impulse + use the info / play sounds\r\n\r\n                bodyB.body.applyImpulse(outputObjectImpulse, outputImpulsePosition, bodyB.index);\r\n            }\r\n        }\r\n    }\r\n\r\n    protected _getInverseInertiaWorld(body: { body: PhysicsBody; index: number }): DeepImmutableObject<Matrix> {\r\n        const mp = body.body.getMassProperties(body.index);\r\n        if (!mp.inertia || !mp.inertiaOrientation) {\r\n            return Matrix.IdentityReadOnly;\r\n        }\r\n        const invOrientation = Matrix.FromQuaternionToRef(mp.inertiaOrientation, TmpVectors.Matrix[0]).invert();\r\n        const it = TmpVectors.Matrix[1];\r\n\r\n        const ir = invOrientation.getRowToRef(0, TmpVectors.Vector4[0]);\r\n        it.setRowFromFloats(0, mp.inertia.x * ir.x, mp.inertia.x * ir.y, mp.inertia.x * ir.z, 0);\r\n        invOrientation.getRowToRef(1, ir);\r\n        it.setRowFromFloats(0, mp.inertia.y * ir.x, mp.inertia.y * ir.y, mp.inertia.y * ir.z, 0);\r\n        invOrientation.getRowToRef(2, ir);\r\n        it.setRowFromFloats(0, mp.inertia.z * ir.x, mp.inertia.z * ir.y, mp.inertia.z * ir.z, 0);\r\n        invOrientation.multiplyToRef(it, this._tmpMatrix);\r\n        return this._tmpMatrix;\r\n    }\r\n\r\n    protected _getComWorldToRef(body: { body: PhysicsBody; index: number }, result: Vector3) {\r\n        const mp = body.body.getMassProperties(body.index);\r\n        Vector3.TransformCoordinatesToRef(mp.centerOfMass!, body.body.transformNode.getWorldMatrix(), result);\r\n    }\r\n\r\n    protected _getInvMass(body: { body: PhysicsBody; index: number }): number {\r\n        return 1 / body.body.getMassProperties(body.index).mass!;\r\n    }\r\n\r\n    /**\r\n     * Update internal state. Must be called once per frame\r\n     * @param deltaTime frame delta time in seconds. When using scene.deltaTime divide by 1000.0\r\n     * @param surfaceInfo surface information returned by checkSupport\r\n     * @param gravity gravity applied to the character. Can be different that world gravity\r\n     */\r\n    public integrate(deltaTime: number, surfaceInfo: CharacterSurfaceInfo, gravity: Vector3) {\r\n        const hk = this._scene.getPhysicsEngine()!.getPhysicsPlugin() as HavokPlugin;\r\n\r\n        const invDeltaTime = 1 / deltaTime;\r\n        let remainingTime = deltaTime;\r\n        let newVelocity = Vector3.Zero();\r\n\r\n        // If the difference between the cast displacement and the simplex solver output position is less than this\r\n        // value (per component), do not do a second cast to check if it's possible to reach the output position.\r\n        const displacementEps = 1e-4;\r\n        const epsSqrd = 1e-8;\r\n\r\n        // Choose the first cast direction.  If velocity hasn't changed from the previous integrate, guess that the\r\n        // displacement will be the same as last integrate, scaled by relative step length.  Otherwise, guess based\r\n        // on current velocity.\r\n        {\r\n            const tolerance = displacementEps * invDeltaTime;\r\n            if (this._velocity.equalsWithEpsilon(this._lastVelocity, tolerance)) {\r\n                this._lastDisplacement.scaleInPlace(remainingTime * this._lastInvDeltaTime);\r\n            } else {\r\n                const displacementVelocity = this._velocity;\r\n                if (surfaceInfo.supportedState == CharacterSupportedState.SUPPORTED) {\r\n                    const relativeVelocity = this._tmpVecs[28];\r\n                    this._velocity.subtractToRef(surfaceInfo.averageSurfaceVelocity, relativeVelocity);\r\n                    const normalDotVelocity = surfaceInfo.averageSurfaceNormal.dot(relativeVelocity);\r\n                    if (normalDotVelocity < 0) {\r\n                        relativeVelocity.subtractInPlace(surfaceInfo.averageSurfaceNormal.scale(normalDotVelocity));\r\n                        displacementVelocity.copyFrom(relativeVelocity);\r\n                        displacementVelocity.addInPlace(surfaceInfo.averageSurfaceVelocity);\r\n                    }\r\n                }\r\n                this._lastDisplacement.copyFrom(displacementVelocity);\r\n                this._lastDisplacement.scaleInPlace(remainingTime);\r\n            }\r\n            this._lastVelocity.copyFrom(this._velocity);\r\n            this._lastInvDeltaTime = invDeltaTime;\r\n        }\r\n\r\n        // Make sure that contact with bodies that have been removed since the call to checkSupport() are removed from the\r\n        // manifold\r\n        this._validateManifold();\r\n\r\n        for (let iter = 0; iter < this.maxCastIterations && remainingTime > 1e-5; iter++) {\r\n            this._castWithCollectors(this._position, this._position.add(this._lastDisplacement), this._castCollector, this._startCollector);\r\n            const updateResult = this._updateManifold(this._startCollector, this._castCollector, this._lastDisplacement);\r\n\r\n            // Create surface constraints from the manifold contacts.\r\n            const constraints = this._createConstraintsFromManifold(deltaTime, deltaTime - remainingTime);\r\n            const maxSurfaceVelocity = this._tmpVecs[3];\r\n            maxSurfaceVelocity.set(this.maxCharacterSpeedForSolver, this.maxCharacterSpeedForSolver, this.maxCharacterSpeedForSolver);\r\n            const minDeltaTime = this._velocity.lengthSquared() == 0 ? 0.0 : (0.5 * this.keepDistance) / this._velocity.length();\r\n            const solveResults = this._simplexSolverSolve(constraints, this._velocity, remainingTime, minDeltaTime, this.up, maxSurfaceVelocity);\r\n            const newDisplacement = solveResults.position;\r\n            const solverDeltaTime = solveResults.deltaTime;\r\n            newVelocity = solveResults.velocity;\r\n\r\n            this._resolveContacts(deltaTime, gravity);\r\n\r\n            let newContactIndex = -1;\r\n            // todo if (updateResult == hit multiple bodies) ... cast again\r\n\r\n            // If castCollector had hits on different bodies (so we're not sure if some non-closest body could be in our way) OR\r\n            // the simplex has given an output direction different from the cast guess\r\n            // we re-cast to check we can move there. There is no need to get the start points again.\r\n            if (updateResult != 0 || (newDisplacement.lengthSquared() > epsSqrd && !this._lastDisplacement.equalsWithEpsilon(newDisplacement, displacementEps))) {\r\n                this._castWithCollectors(this._position, this._position.add(newDisplacement), this._castCollector, this._startCollector);\r\n                const hknp = hk._hknp;\r\n                const numCastHits = hknp.HP_QueryCollector_GetNumHits(this._castCollector)[1];\r\n                // Find the first contact that isn't already in the manifold\r\n                if (numCastHits > 0) {\r\n                    //<todo sortHits()\r\n                    for (let i = 0; i < numCastHits; i++) {\r\n                        // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n                        const [fraction, _hitLocal, hitWorld] = hknp.HP_QueryCollector_GetShapeCastResult(this._castCollector, i)[1];\r\n                        const newContact = contactFromCast(hk, hitWorld, newDisplacement, fraction, this.keepDistance);\r\n                        if (this._findContact(newContact, this._manifold, 0.1) == -1) {\r\n                            //<todo fireContactAdded\r\n                            newContactIndex = this._manifold.length;\r\n                            this._manifold.push(newContact);\r\n                            //<todo updateTriggersSeen()\r\n                            break;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n\r\n            if (newContactIndex >= 0) {\r\n                const newContact = this._manifold[newContactIndex];\r\n                const displacementLengthInv = 1.0 / newDisplacement.length();\r\n                const angleBetweenMovementAndSurface = newDisplacement.dot(newContact.normal) * displacementLengthInv;\r\n                const keepDistanceAlongMovement = this.keepDistance / -angleBetweenMovementAndSurface;\r\n                const distance = newContact.fraction;\r\n                let fraction = distance - keepDistanceAlongMovement * displacementLengthInv;\r\n                fraction = Math.min(Math.max(fraction, 0.0), 1.0);\r\n\r\n                const displacement = newDisplacement.scale(fraction);\r\n                this._position.addInPlace(displacement);\r\n                remainingTime -= solverDeltaTime * fraction;\r\n            } else {\r\n                this._position.addInPlace(newDisplacement);\r\n                remainingTime -= solverDeltaTime;\r\n            }\r\n            this._lastDisplacement.copyFrom(newDisplacement);\r\n        }\r\n\r\n        this._velocity.copyFrom(newVelocity);\r\n    }\r\n\r\n    /**\r\n     * Helper function to calculate velocity based on surface informations and current velocity state and target\r\n     * @param deltaTime frame delta time in seconds. When using scene.deltaTime divide by 1000.0\r\n     * @param forwardWorld character forward in world coordinates\r\n     * @param surfaceNormal surface normal direction\r\n     * @param currentVelocity current velocity\r\n     * @param surfaceVelocity velocity induced by the surface\r\n     * @param desiredVelocity desired character velocity\r\n     * @param upWorld up vector in world space\r\n     * @param result resulting velocity vector\r\n     * @returns boolean true if result has been computed\r\n     */\r\n    public calculateMovementToRef(\r\n        deltaTime: number,\r\n        forwardWorld: Vector3,\r\n        surfaceNormal: Vector3,\r\n        currentVelocity: Vector3,\r\n        surfaceVelocity: Vector3,\r\n        desiredVelocity: Vector3,\r\n        upWorld: Vector3,\r\n        result: Vector3\r\n    ): boolean {\r\n        const eps = 1e-5;\r\n        let binorm = forwardWorld.cross(upWorld);\r\n        if (binorm.lengthSquared() < eps) {\r\n            return false;\r\n        }\r\n        binorm.normalize();\r\n        const tangent = binorm.cross(surfaceNormal);\r\n        tangent.normalize();\r\n        binorm = tangent.cross(surfaceNormal);\r\n        binorm.normalize();\r\n\r\n        const surfaceFrame = Matrix.FromValues(\r\n            tangent.x,\r\n            tangent.y,\r\n            tangent.z,\r\n            0,\r\n            binorm.x,\r\n            binorm.y,\r\n            binorm.z,\r\n            0,\r\n            surfaceNormal.x,\r\n            surfaceNormal.y,\r\n            surfaceNormal.z,\r\n            0,\r\n            0,\r\n            0,\r\n            0,\r\n            1\r\n        );\r\n        const invSurfaceFrame = surfaceFrame.clone().invert();\r\n\r\n        currentVelocity.subtractToRef(surfaceVelocity, this._tmpVecs[29]);\r\n        const relative = this._tmpVecs[30];\r\n        Vector3.TransformNormalToRef(this._tmpVecs[29], invSurfaceFrame, relative);\r\n\r\n        const sideVec = upWorld.cross(forwardWorld);\r\n        const fwd = desiredVelocity.dot(forwardWorld);\r\n        const side = desiredVelocity.dot(sideVec);\r\n        const len = desiredVelocity.length();\r\n\r\n        const desiredVelocitySF = this._tmpVecs[4];\r\n        desiredVelocitySF.set(-fwd, side, 0);\r\n        desiredVelocitySF.normalize();\r\n        desiredVelocitySF.scaleInPlace(len);\r\n        const diff = this._tmpVecs[5];\r\n        desiredVelocitySF.subtractToRef(relative, diff);\r\n\r\n        // Clamp it by maxVelocityDelta and limit it by gain.\r\n        {\r\n            const lenSq = diff.lengthSquared();\r\n            const gain = 0.05;\r\n            const maxVelocityDelta = 50.0 * deltaTime;\r\n            let tmp: number;\r\n            if (lenSq * gain * gain > maxVelocityDelta * maxVelocityDelta) {\r\n                tmp = maxVelocityDelta / Math.sqrt(lenSq);\r\n            } else {\r\n                tmp = gain;\r\n            }\r\n            diff.scaleInPlace(tmp);\r\n        }\r\n\r\n        relative.addInPlace(diff);\r\n\r\n        // Transform back to world space and apply\r\n        Vector3.TransformNormalToRef(relative, surfaceFrame, result);\r\n\r\n        // Add back in the surface velocity\r\n        result.addInPlace(surfaceVelocity);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Helper function to calculate velocity based on surface informations and current velocity state and target\r\n     * @param deltaTime frame delta time in seconds. When using scene.deltaTime divide by 1000.0\r\n     * @param forwardWorld character forward in world coordinates\r\n     * @param surfaceNormal surface normal direction\r\n     * @param currentVelocity current velocity\r\n     * @param surfaceVelocity velocity induced by the surface\r\n     * @param desiredVelocity desired character velocity\r\n     * @param upWorld up vector in world space\r\n     * @returns a new velocity vector\r\n     */\r\n    public calculateMovement(\r\n        deltaTime: number,\r\n        forwardWorld: Vector3,\r\n        surfaceNormal: Vector3,\r\n        currentVelocity: Vector3,\r\n        surfaceVelocity: Vector3,\r\n        desiredVelocity: Vector3,\r\n        upWorld: Vector3\r\n    ): Vector3 {\r\n        const result = new Vector3(0, 0, 0);\r\n        this.calculateMovementToRef(deltaTime, forwardWorld, surfaceNormal, currentVelocity, surfaceVelocity, desiredVelocity, upWorld, result);\r\n        return result;\r\n    }\r\n}\r\n"],
  "mappings": "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",
  "names": ["PhysicsMaterialCombineMode", "CharacterSupportedState", "SurfaceConstraintInteractionStatus", "i"]
}
